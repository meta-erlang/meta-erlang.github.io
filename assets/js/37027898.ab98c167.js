"use strict";(self.webpackChunkmeta_erlang_github_io=self.webpackChunkmeta_erlang_github_io||[]).push([[2401],{62564:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var i=r(28969),a=r(74848),t=r(28453);const l={title:"Erlang-Red, recipe introduction",authors:["joaohf"],tags:["meta-erlang","erlang-red"]},s=void 0,o={authorsImageUrls:[void 0]},d=[{value:"Erlang-Red",id:"erlang-red",level:2},{value:"The Erlang-Red recipe",id:"the-erlang-red-recipe",level:2},{value:"Setup bitbake and Yocto",id:"setup-bitbake-and-yocto",level:2},{value:"Fetching source code",id:"fetching-source-code",level:3},{value:"Sourcing build environment",id:"sourcing-build-environment",level:3},{value:"Adding meta-erlang layer",id:"adding-meta-erlang-layer",level:3},{value:"Configuring the build environment",id:"configuring-the-build-environment",level:3},{value:"Build erlang-red recipe",id:"build-erlang-red-recipe",level:3},{value:"A basic image with erlang-red enabled",id:"a-basic-image-with-erlang-red-enabled",level:2},{value:"Running erlang-red with QEMU emulator",id:"running-erlang-red-with-qemu-emulator",level:2},{value:"Erlang-Red runtime analysis",id:"erlang-red-runtime-analysis",level:2},{value:"What about the disk footprint ?",id:"what-about-the-disk-footprint-",level:3},{value:"And about memory footprint ?",id:"and-about-memory-footprint-",level:3},{value:"What has next ?",id:"what-has-next-",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/gorenje/erlang-red",children:"Erlang-Red"})," is an experimental Erlang\nbackend to replace ",(0,a.jsx)(n.a,{href:"https://nodered.org/",children:"Node-RED"}),". This blog post introduces\nthe erlang-red recipe available in meta-erlang layer."]}),"\n",(0,a.jsx)(n.p,{children:"The purpose here is to get a virtual environment with Erlang-Red installed where\nit is possible to start creating basic flow and explore possibilities using\nYocto and Erlang-Red."}),"\n",(0,a.jsx)(n.h2,{id:"erlang-red",children:"Erlang-Red"}),"\n",(0,a.jsxs)(n.p,{children:["According to ",(0,a.jsx)(n.a,{href:"https://github.com/gorenje/erlang-red",children:"Erlang-Red"}),", it is:"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Experimental Erlang backend to replace Node-REDs existing NodeJS backend,\naiming for 100% compatible with existing flow code."}),"\n",(0,a.jsx)(n.p,{children:"The goal is bring the advantages of low-code visual flow-based programming to\na programming language that is designed for message passing and concurrency\nfrom the ground up, hence Erlang. More details described in the corresponding\nblog post."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A few months ago I was reading ",(0,a.jsx)(n.a,{href:"https://erlangforums.com",children:"Erlang Forums"})," when I\nsaw a thread about\n",(0,a.jsx)(n.a,{href:"https://erlangforums.com/t/erlang-red-erlang-interpreter-for-node-red-flow-code-visual-flow-based-programming/4678",children:"Erlang-RED - Erlang interpreter for Node-RED flow code (visual flow based programming)"}),".\nIt looked so fantastic that someone was trying to implement a new backend for\nNode-RED, moreover it is written in Erlang/OTP."]}),"\n",(0,a.jsxs)(n.p,{children:["In order to get a better view of Erlang-Red philosophy and internals I recommend\nreading this blog post:\n",(0,a.jsx)(n.a,{href:"https://blog.openmindmap.org/erlang-red",children:"The Erlang-Red Project"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["I thought that writing an\n",(0,a.jsx)(n.a,{href:"https://layers.openembedded.org/layerindex/recipe/464852/",children:"Erlang-Red Yocto recipe"}),"\ncould be useful for anyone interested in applying flow based programming in the\ncontext of linux embedded projects."]}),"\n",(0,a.jsx)(n.h2,{id:"the-erlang-red-recipe",children:"The Erlang-Red recipe"}),"\n",(0,a.jsxs)(n.p,{children:["As everything else in OpenEmbedded / Yocto land, it is necessary a recipe in\norder to get any software installed in the final image built with Yocto. Some\nrecipes are easy, while others are more complicated. As Erlang-Red uses rebar3\nas build tool, it was easy to build, release and package it using\n",(0,a.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-erlang/blob/master/classes/rebar3.bbclass",children:"rebar3.bbclass"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["A full working\n",(0,a.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-erlang/blob/master/recipes-extended/erlang-red/erlang-red_git.bb",children:"erlang-red bitbake recipe"}),"\nis now available on meta-erlang layer. And in the rest of this blog post I will\nguide you to get a basic image working."]}),"\n",(0,a.jsx)(n.p,{children:"I have added erlang-red recipe to meta-erlang master branch. I did not test it\nusing others Yocto branches. But the recipe will work in other branches with\nsmall fixes."}),"\n",(0,a.jsx)(n.h2,{id:"setup-bitbake-and-yocto",children:"Setup bitbake and Yocto"}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This is the point where reading the\n",(0,a.jsx)(n.a,{href:"https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html",children:"Yocto Project Quick Build"}),"\ndocumentation can help to understand basic principles. In this section I\nextracted the commands that I used to run this use case."]})}),"\n",(0,a.jsx)(n.h3,{id:"fetching-source-code",children:"Fetching source code"}),"\n",(0,a.jsx)(n.p,{children:"Cloning all repositories for master branch:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"git clone --branch master git://git.yoctoproject.org/poky\ngit clone --branch master https://github.com/meta-erlang/meta-erlang\n"})}),"\n",(0,a.jsx)(n.h3,{id:"sourcing-build-environment",children:"Sourcing build environment"}),"\n",(0,a.jsx)(n.p,{children:"Source the init build environment script:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd poky\nsource oe-init-build-env ../build\n"})}),"\n",(0,a.jsx)(n.h3,{id:"adding-meta-erlang-layer",children:"Adding meta-erlang layer"}),"\n",(0,a.jsx)(n.p,{children:"Add the needed layers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"bitbake-layers add-layer ../meta-erlang\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuring-the-build-environment",children:"Configuring the build environment"}),"\n",(0,a.jsxs)(n.p,{children:["For this use case, the quickest way is to edit and add some snippets in the\nconfiguration file: ",(0,a.jsx)(n.em,{children:"conf/local.conf"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# select which machine we want to build\nMACHINE = "qemuriscv32"\n\n# systemd only\nINIT_MANAGER = "systemd"\n\n# install erlang-red when creating an image\nIMAGE_INSTALL:append = " erlang-red"\n\n# additional QEMU configuration for slirp mode, export 8080 tcp port\nQB_SLIRP_OPT = "-netdev user,id=net0,hostfwd=tcp::8080-:8080,hostfwd=tcp::2222-:22"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"build-erlang-red-recipe",children:"Build erlang-red recipe"}),"\n",(0,a.jsxs)(n.p,{children:["Right, the environment is configured. Have sourced the ",(0,a.jsx)(n.code,{children:"oe-init-build-env"}),", we\ncan build erlang-red recipe:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"bitbake erlang-red\n"})}),"\n",(0,a.jsx)(n.p,{children:"This bitbake command will build erlang-red and all its building dependencies."}),"\n",(0,a.jsx)(n.p,{children:"But to get something useful, we need to also build an image."}),"\n",(0,a.jsx)(n.h2,{id:"a-basic-image-with-erlang-red-enabled",children:"A basic image with erlang-red enabled"}),"\n",(0,a.jsx)(n.p,{children:"Next, we need to build the final image:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"bitbake core-image-full-cmdline\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Because we have added erlang-red to ",(0,a.jsx)(n.code,{children:"IMAGE_INSTALL"}),", the build image process\nwill install erlang-red."]}),"\n",(0,a.jsx)(n.p,{children:"With image ready, it is time to run it."}),"\n",(0,a.jsx)(n.h2,{id:"running-erlang-red-with-qemu-emulator",children:"Running erlang-red with QEMU emulator"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"runqemu core-image-full-cmdline serialstdio nographic\n\n....\n\nPoky (Yocto Project Reference Distro) 5.2.99+snapshot-bd4625cd4db0f02162092d85aeab3023914f768a qemuriscv32 ttyS0\n\nqemuriscv32 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n\nroot@qemuriscv32:~#\n"})}),"\n",(0,a.jsxs)(n.p,{children:["I used the arguments ",(0,a.jsx)(n.code,{children:"serialstdio"}),", to enable a serial console input attached to\nstdio; and ",(0,a.jsx)(n.code,{children:"nographic"})," to avoid starting QEMU GUI frontend."]}),"\n",(0,a.jsx)(n.p,{children:"In a new terminal, let's open a ssh session and start erlang-red using systemctl\ncommand:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"ssh root@192.168.7.2\n\nLast login: Fri Aug  1 18:50:29 2025 from 172.17.0.1\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n\nroot@qemuriscv32:~# systemctl status erlang-red\n\u25cf erlang-red.service - Breadboard Programming for Erlang inspired by Node-RED\n     Loaded: loaded (/usr/lib/systemd/system/erlang-red.service; enabled; preset: enabled)\n     Active: active (running) since Fri 2025-08-01 18:49:45 UTC; 55s ago\n"})}),"\n",(0,a.jsx)(n.p,{children:"Great, erlang-red is up and running."}),"\n",(0,a.jsxs)(n.p,{children:["In the host, open a browser at ",(0,a.jsx)(n.a,{href:"http://192.168.7.2:8080/erlang-red",children:"http://192.168.7.2:8080/erlang-red"})," to see the\nerlang-red web interface."]}),"\n",(0,a.jsx)(n.p,{children:"Well, now it is the right time to learn about flow based programming and start\nplaying with erlang-red."}),"\n",(0,a.jsx)(n.h2,{id:"erlang-red-runtime-analysis",children:"Erlang-Red runtime analysis"}),"\n",(0,a.jsx)(n.p,{children:"The Erlang-Red performance is relative as there is no much to say when emulating\nusing QEMU without KVM to improve performance. Some rough analises below:"}),"\n",(0,a.jsx)(n.h3,{id:"what-about-the-disk-footprint-",children:"What about the disk footprint ?"}),"\n",(0,a.jsxs)(n.p,{children:["The total erlang-red footprint is about 35Mb of disk space. It includes the ERTS\n(Erlang Runtime System) and all Erlang/Elixir dependencies. All files installed\non ",(0,a.jsx)(n.code,{children:"/usr/lib/erlang-red"})," folder. The erlang-red package also provides systemV\nand systemd start/stop scripts."]}),"\n",(0,a.jsx)(n.h3,{id:"and-about-memory-footprint-",children:"And about memory footprint ?"}),"\n",(0,a.jsx)(n.p,{children:"In this use case I used systemd because I want to get the memory footprint that\nsystemd was reporting:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"root@qemuriscv32:~# systemctl status erlang-red\n\u25cf erlang-red.service - Breadboard Programming for Erlang inspired by Node-RED\n     Loaded: loaded (/usr/lib/systemd/system/erlang-red.service; enabled; preset: enabled)\n     Active: active (running) since Fri 2025-08-01 18:49:45 UTC; 55s ago\n Invocation: 704b9bef5b384451932e15cadb7291fa\n   Main PID: 322 (beam.smp)\n      Tasks: 27 (limit: 4915)\n     Memory: 69.7M (peak: 75.4M)\n        CPU: 9.751s\n     CGroup: /system.slice/erlang-red.service\n             \u251c\u2500322 /usr/lib/erlang-red/bin/erlang_red -Bd -C multi_time_warp -- -root /usr/lib/erlang-red -bindir /usr/lib/erlang-red/erts-16.0.1/bin -progname usr/lib/erlang-red/bin/erlang_red -- -home /var/lib/erlang>\n             \u251c\u2500380 /usr/lib/erlang-red/erts-16.0.1/bin/epmd -daemon\n             \u251c\u2500435 erl_child_setup 1024\n             \u2514\u2500458 /usr/lib/erlang-red/lib/erlexec-2.2.0/priv/x86_64-pc-linux-gnu/exec-port\n\nAug 01 18:49:45 qemuriscv32 systemd[1]: Started Breadboard Programming for Erlang inspired by Node-RED.\nAug 01 18:49:47 qemuriscv32 erlang_red[322]: Exec: /usr/lib/erlang-red/erts-16.0.1/bin/erlexec -noinput +Bd -boot /usr/lib/erlang-red/releases/0.2.2/start -mode embedded -boot_var SYSTEM_LIB_DIR /usr/lib/erlang-red/lib>\nAug 01 18:49:47 qemuriscv32 erlang_red[322]: Root: /usr/lib/erlang-red\nAug 01 18:49:47 qemuriscv32 erlang_red[322]: /usr/lib/erlang-red\nAug 01 18:49:50 qemuriscv32 erlang_red[322]: warning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (which can>\nlines 1-19/19 (END)\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"So, 69.7M is the memory consumption."}),"\n",(0,a.jsx)(n.p,{children:"As Erlang-Red is in it's early development stages, I believe that are open space\nfor code optimization for reducing memory usage and also for tuning ERTS for the\nErlang-Red use case."}),"\n",(0,a.jsx)(n.h2,{id:"what-has-next-",children:"What has next ?"}),"\n",(0,a.jsx)(n.p,{children:"As a next project, I wish to install erlang-red into a Raspberry Pi platform and\ncontrol some external hardware. This is a pretty common scenario and let's see\nhow feasible it is with Erlang-Red."})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var i=r(96540);const a={},t=i.createContext(a);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},28969:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/07/27/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-07-27/index.md","source":"@site/blog/2025-07-27/index.md","title":"Erlang-Red, recipe introduction","description":"Erlang-Red is an experimental Erlang","date":"2025-07-27T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"erlang-red","permalink":"/blog/tags/erlang-red"}],"readingTime":5.55,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Erlang-Red, recipe introduction","authors":["joaohf"],"tags":["meta-erlang","erlang-red"]},"unlisted":false,"prevItem":{"title":"beamruntime","permalink":"/blog/2025/09/25/index"},"nextItem":{"title":"autotools as build tool for Erlang/OTP projects","permalink":"/blog/2025/05/11/index"}}')}}]);