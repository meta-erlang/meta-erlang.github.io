"use strict";(self.webpackChunkmeta_erlang_github_io=self.webpackChunkmeta_erlang_github_io||[]).push([[8749],{1895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2024/10/06/index","metadata":{"permalink":"/blog/2024/10/06/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-10-06/index.md","source":"@site/blog/2024-10-06/index.md","title":"Anatomy of erlang and elixir packages for YP/OE","description":"Usually, when designing a linux distribution using YP/OE we want a slim image","date":"2024-10-06T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"x32","permalink":"/blog/tags/x-32"}],"readingTime":7.725,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Anatomy of erlang and elixir packages for YP/OE","authors":["joaohf"],"tags":["meta-erlang","x32"]},"unlisted":false,"nextItem":{"title":"fwup for A/B image upgrades","permalink":"/blog/2024/09/24/index"}},"content":"Usually, when designing a linux distribution using YP/OE we want a slim image\\nwith only what we need to run a specific application (or applications). In this\\npost we\'ll discuss a bit about erlang and elixir packages that meta-erlang layer\\nprovides.\\n\\nIt\'s important to know how the packages are divided into smaller ones in order\\nto offer a better composition when creating linux distributions with YP/OE.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Environment setup\\n\\n1. Cloning all repositories for master branch:\\n\\n   ```bash\\n   git clone --branch master git://git.yoctoproject.org/poky\\n   git clone --branch master https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch master https://github.com/meta-erlang/meta-erlang\\n   git clone --branch master https://github.com/meta-erlang/meta-axon\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-erlang\\n   bitbake-layers add-layer ../meta-axon\\n   ```\\n\\n1. Configure the `conf/local.conf` and enable multiconfig builds:\\n\\n   ```bash\\n   tee -a <<EOF\\n   # debug-tweaks\\n   EXTRA_IMAGE_FEATURES ?= \\"debug-tweaks\\"\\n   USER_CLASSES ?= \\"buildhistory buildstats\\"\\n   BUILDHISTORY_COMMIT = \\"1\\"\\n   PACKAGE_CLASSES = \\"package_ipk\\"\\n   PATCHRESOLVE = \\"noop\\"\\n   INHERIT += \\"rm_work\\"\\n   RM_WORK_EXCLUDE = \\"erlang erlang-native nativesdk-erlang\\"\\n\\n   # diskmon\\n   BB_DISKMON_DIRS = \\"\\\\\\n       STOPTASKS,${TMPDIR},1G,100K \\\\\\n       STOPTASKS,${DL_DIR},1G,100K \\\\\\n       STOPTASKS,${SSTATE_DIR},1G,100K \\\\\\n       STOPTASKS,/tmp,100M,100K \\\\\\n       HALT,${TMPDIR},100M,1K \\\\\\n       HALT,${DL_DIR},100M,1K \\\\\\n       HALT,${SSTATE_DIR},100M,1K \\\\\\n       HALT,/tmp,10M,1K\\"\\n\\n   # general config\\n   SDKMACHINE = \\"x86_64\\"\\n\\n   # local\\n   CONNECTIVITY_CHECK_URIS = \\"https://www.google.com/\\"\\n\\n   # master\\n\\n   # qemu configuration\\n   PACKAGECONFIG:append:pn-qemu-system-native = \\" sdl\\"\\n   PACKAGECONFIG:append:pn-qemu-system-native = \\" gtk+\\"\\n\\n   # systemd only\\n   INIT_MANAGER = \\"systemd\\"\\n\\n   MACHINE ??= \\"qemuarm\\"\\n   DISTRO ??= \\"poky\\"\\n   BBMULTICONFIG ?= \\"qemux86-64-erlang-elixir qemuarm64-erlang-elixir qemuarm-erlang-elixir qemux86-erlang-elixir qemux86-64-x32-erlang-elixir\\"\\n\\n   # To disable QA checks for https://github.com/meta-erlang/meta-erlang/issues/328\\n   ERROR_QA:remove = \\"buildpaths\\"\\n\\n   EOF\\n   ```\\n\\n## multiconfig build\\n\\nYP/OE provides a smart way to build the same image (or different images) for\\nmultiple targets. It is called multiconfig build and it is fully described at\\n[Building Images for Multiple Targets Using Multiple Configurations](https://docs.yoctoproject.org/dev-manual/building.html?highlight=multiconfig#building-images-for-multiple-targets-using-multiple-configurations).\\n\\nFour our context, don\'t forget to checkout the section\\n[Environment setup](#environment-setup), we need to compare the erlang and\\nelixir packages using different processor architectures (_MACHINES_ in YP/OE\\nlanguage).\\n\\nWe can build five targets using the command below:\\n\\n```bash\\nbitbake -c build \\\\\\n    multiconfig:qemux86-64-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemux86-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemuarm-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemuarm64-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemux86-64-x32-erlang-elixir:core-image-minimal\\n\\n```\\n\\nThe multiconfig build was configured to create a specific TMPDIR for each\\nprocessor architecture. Then, the final results at build folder will be one\\nfolder for each architecture:\\n\\n```bash\\ntmp-qemuarm64-glibc-erlang-elixir\\ntmp-qemuarm-glibc-erlang-elixir\\ntmp-qemux86-64-glibc-erlang-elixir\\ntmp-qemux86-64-glibc-x32-erlang-elixir\\ntmp-qemux86-glibc-erlang-elixir\\n```\\n\\nThat way, it\'s easy to navigate into the final output files.\\n\\n## Introspection with buildhistory\\n\\nThe buildhistory is a YP/OE feature that writes some meta data into a git\\nrepository for further inspection. Then, it\'s possible check and interact with\\nfiles using standard linux tools like find and grep to collect insights. Using\\nbuildhistory is a shortcut because we can inspect how files would be installed\\ninto the final image, without having to burn the image and boot it on a real (or\\nvirtual) target.\\n\\n:::note\\nCheck out the\\n[Enabling and Disabling Build History](https://docs.yoctoproject.org/5.0.3/dev-manual/build-quality.html?highlight=buildhistory#enabling-and-disabling-build-history)\\ninstructions for how to enable buildhistory.\\n:::\\n\\nIn this post we are interested in check the size of erlang and elixir packages.\\n\\nAfter a success build and from the YP/OE build folder, it\'s possible to explore\\nthe buildhistory git repository:\\n\\n```bash\\ncd buildhistory/packages/cortexa57-poky-linux/erlang\\nfind -name latest -print0 | xargs -0 grep PKGSIZE | sort\\n...\\n\\ncd -\\ncd buildhistory/packages/cortexa57-poky-linux/elixir\\nfind -name latest -print0 | xargs -0 grep PKGSIZE | sort\\n...\\n```\\n\\n`PKGSIZE` gives to us the size in bytes of the final packages generated by\\nerlang and elixir recipes.\\n\\n## YP/OE packaging for erlang and elixir recipes\\n\\nThe nature of Erlang/OTP is to isolate erlang modules into applications. The\\nErlang/OTP source code embraces this philosophy and it is natural to transform\\neach application into an installed package (IPK, DEB, RPM). For that,\\nmeta-erlang uses a simple script that creates a recipe manifest (see\\n[erlang recipe manifest](https://github.com/meta-erlang/meta-erlang/blob/cb94887c108b63c6cba290cb019468f246df5ea4/scripts/contrib/erlang/generate-manifest#L76)\\nfor details).\\n\\nAn erlang recipe manifest, for example\\n[erlang-27.1-manifest.inc](https://github.com/meta-erlang/meta-erlang/blob/cb94887c108b63c6cba290cb019468f246df5ea4/recipes-devtools/erlang/erlang-27.1-manifest.inc),\\ndeclares each Erlang/OTP application. For each application there are five\\npackages:\\n\\n- `application_name-doc`: documentation, man pages and examples\\n- `application_name-dbg`: debug symbols, if any\\n- `application_name-dev`: development C headers, shared libraries (\\\\*.so)\\n- `application_name-staticdev`: static libraries (\\\\*.a)\\n- `application_name`: BEAM modules and files from `priv` folder\\n\\nWhere `application_name` is the name of the application like: kernel, stdlib,\\nsasl, ...\\n\\nThis separation is necessary because YP/OE splits the package of any recipe into\\ndoc, dbg, dev and staticdev. Then, the user have more control about what will be\\ninstalled into the final image.\\n\\nThe elixir recipe follows the same way, but simpler (check out the\\n[elixir.inc](https://github.com/meta-erlang/meta-erlang/blob/cb94887c108b63c6cba290cb019468f246df5ea4/recipes-devtools/elixir/elixir.inc)\\ninclude file).\\n\\n### Special metapackages\\n\\nAs there are many packages for erlang and elixir, sometimes we need to setup a\\ndevelopment environment will all erlang and elixir packages installed. Or a\\nminimum set of packages. There are a couple of metapackages created for that\\npurpose:\\n\\n- erlang-modules: install _all_ Erlang/OTP applications\\n- erlang-modules-dev: install _all_ Erlang/OTP applications development packages\\n- elixir-modules: install _all_ elixir applications\\n- elixir-modules-dev: install _all_ elixir applications development packages\\n- erlang: install the minimal Erlang/OTP applications\\n- elixir: install the minimal elixir applications\\n\\n### Where the files get installed ?\\n\\nThe best way to awnser this is to take a look into buildhistory data.\\n\\nAt the build folder there is a folder called buildhistory. That folder is split\\nby images and packages. And for each architecture, there is a specific folder.\\nSo, let\'s check the first 20 lines from file: files-in-packages.txt for\\nerlang-erts package:\\n\\n```bash\\nhead -n 20 buildhistory/packages/core2-32-poky-linux/erlang/erlang-erts/files-in-package.txt\\ndrwxr-xr-x root       root             4096 ./usr\\ndrwxr-xr-x root       root             4096 ./usr/bin\\nlrwxrwxrwx root       root               22 ./usr/bin/epmd -> ../lib/erlang/bin/epmd\\nlrwxrwxrwx root       root               21 ./usr/bin/erl -> ../lib/erlang/bin/erl\\nlrwxrwxrwx root       root               25 ./usr/bin/escript -> ../lib/erlang/bin/escript\\nlrwxrwxrwx root       root               25 ./usr/bin/run_erl -> ../lib/erlang/bin/run_erl\\nlrwxrwxrwx root       root               24 ./usr/bin/to_erl -> ../lib/erlang/bin/to_erl\\ndrwxr-xr-x root       root             4096 ./usr/lib\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/bin\\nlrwxrwxrwx root       root               21 ./usr/lib/erlang/bin/epmd -> ../erts-15.1/bin/epmd\\n-rwxr-xr-x root       root             1474 ./usr/lib/erlang/bin/erl\\n-rwxr-xr-x root       root           140752 ./usr/lib/erlang/bin/erl_call\\n-rwxr-xr-x root       root            38456 ./usr/lib/erlang/bin/escript\\n-rw-r--r-- root       root             6860 ./usr/lib/erlang/bin/no_dot_erlang.boot\\n-rwxr-xr-x root       root            25996 ./usr/lib/erlang/bin/run_erl\\n-rwxr-xr-x root       root             1745 ./usr/lib/erlang/bin/start\\n-rw-r--r-- root       root             6885 ./usr/lib/erlang/bin/start.boot\\n-rw-r--r-- root       root             6885 ./usr/lib/erlang/bin/start_clean.boot\\n-rwxr-xr-x root       root             1244 ./usr/lib/erlang/bin/start_erl\\n```\\n\\n## erlang package sizes\\n\\nWhen installing the metapackage called `erlang` the following packages will be\\nautomatically installed:\\n\\n- erlang-erts\\n- erlang-kernel\\n- erlang-stdlib\\n- erlang-sasl\\n\\nThese packages are the basic ones needed in order to run Erlang programs.\\n\\n:::note\\nActually, your application is in charge of making a proper Erlang/OTP\\nrelease. Installing the package `erlang` is an option if you need it installed\\ninto standard locations. Otherwise, your application should produce a valide\\nrelease with a builtin ERTS inside.\\n:::\\n\\nThe following charts are listed below to get a view about the size of those\\nbasic erlang packages.\\n\\nThe difference between each build, besides the processor architecture, is the\\nsize in bytes of the package erlang-erts. That makes sense because that package\\nis the ERTS (which is architecture dependent, like word size). On other hand,\\nthe packages kernel, stdlib, sasl have the same size across all builds.\\n\\n### qemux86\\n\\n```bash\\nbitbake -c build multiconfig:qemux86-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"core2-32-poky-linux (qemux86)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [5585259, 3421584, 7062547, 439445]\\n```\\n\\n### qemux86-64\\n\\n```bash\\nbitbake -c build multiconfig:qemux86-64-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"core2-64-poky-linux (qemux86-64)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [9472359, 3421584, 7062547, 439445]\\n```\\n\\n### qemux86-64 with x32 psABI\\n\\n```bash\\nbitbake -c build multiconfig:x86_64_x32-poky-linux-gnux32:core-image-minimal\\n```\\n\\n:::note\\nEnabling x32 psABI should be considered if your application needs to\\nhandle 64-bit features, but you can\'t afford wasting space with addressing. See\\nthe blog post [Exploring x32 psABI for Erlang/OTP](/blog/2023/09/02/index).\\n\\nThe package size difference in bytes between x32 build and a normal x86-64\\nis 4615556.\\n:::\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"x86_64_x32-poky-linux-gnux32 (qemux86-64 x32 psABI)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [4856803, 3421584, 7062547, 439445]\\n```\\n\\n### qemuarm64\\n\\n```bash\\nbitbake -c build multiconfig:qemuarm64-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"cortexa57-poky-linux (qemuarm64)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [6400695, 3421584, 7062547, 439445]\\n```\\n\\n### qemuarm\\n\\n```bash\\nbitbake -c build multiconfig:qemuarm-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"cortexa15t2hf-neon-poky-linux-gnueabi (qemuarm)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [3653615, 3421584, 7062547, 439445]\\n```\\n\\n## elixir package sizes\\n\\nWhen installing the metapackage called `elixir` the following packages will be\\nautomatically installed:\\n\\n- erlang (see [erlang package size for details](#erlang-package-sizes))\\n- erlang-compiler\\n\\nThat is because elixir package needs erlang (erts, kernel, stdlib and sasl)\\ninstalled. And, the erlang compiler is also a requirement.\\n\\n:::note\\nAgain, your application should manage a release for best results.\\nInstalling the package `elixir` only makes sense for testing purposes.\\n:::\\n\\nThe following table summarizes the packages sizes per processor architecture.\\n\\n| Processor architecture                | Package size in bytes |\\n| ------------------------------------- | --------------------- |\\n| core2-32-poky-linux (qemux86)         | 5760108               |\\n| core2-64-poky-linux (qemux86-64)      | 5760368               |\\n| qemux86-64-x32-erlang-elixir          | 5763392               |\\n| cortexa57-poky-linux (qemuarm64)      | 5760476               |\\n| cortexa15t2hf-neon-poky-linux-gnueabi | 5764076               |\\n\\nThere are slight size differences. It should not as there is no architecture\\ndependency on elixir beam files."},{"id":"/2024/09/24/index","metadata":{"permalink":"/blog/2024/09/24/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-09-24/index.md","source":"@site/blog/2024-09-24/index.md","title":"fwup for A/B image upgrades","description":"This blog post is a tutorial about how to make A/B software updates with fwup","date":"2024-09-24T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"fwup","permalink":"/blog/tags/fwup"}],"readingTime":8.935,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"fwup for A/B image upgrades","authors":["joaohf"],"tags":["meta-erlang","fwup"]},"unlisted":false,"prevItem":{"title":"Anatomy of erlang and elixir packages for YP/OE","permalink":"/blog/2024/10/06/index"},"nextItem":{"title":"New Erlang releases 27.0","permalink":"/blog/2024/05/31/index"}},"content":"This blog post is a tutorial about how to make A/B software updates with fwup\\ntool and Yocto Project.\\n\\n## Objectives and Tools\\n\\nA short sentence as requirement for this tutorial is:\\n\\n> I wish to make an image using Yocto Project and be able to run software\\n> updates using A/B approach.\\n\\nThere are many references on the Internet for A/B software updates. It\'s a\\nwell-known approach with many different implementations. In short it\'s strategy\\nto minimize downtime when changing the firmware of embedded devices. While the\\nnew software gets written to the unused slot and the current slot is still\\nrunning. When everything are ready to swap, the system gets restarted. Booting\\nusing the unused slot (now it becomes the current slot).\\n\\nSo, in this blog post we are going to play with A/B software updates using fwup\\ntool.\\n\\n## What is fwup ?\\n\\nThe best [fwup](https://github.com/fwup-home/fwup) definition is from its\\nofficial project home:\\n\\n> fwup is a configurable image-based software update utility for embedded\\n> Linux-based systems. It primarily supports software upgrade strategies that\\n> update entire root filesystem images at once. This includes strategies like\\n> swapping back and forth between A and B partitions, recovery partitions, and\\n> various trial update/failback scenarios. All software update information is\\n> combined into a ZIP archive that may optionally be cryptographically signed.\\n> fwup has minimal dependencies and runtime requirements. Scripts are\\n> intentionally limited to make failure scenarios easier to reason about.\\n> Distribution of software update archives is not a feature. Users can call out\\n> to fwup to run upgrades from external media, stream them from the network, or\\n> script them using a tool like Ansible if so desired.\\n\\nIn practice, fwup is simple and easy to use.\\n\\n## YP/OE setup\\n\\nI\'ll try to simplify the YP/OE setup to just tree small steps:\\n\\n:::note\\n\\nThe YP documentation is very good. I strong recommend its reading. For this\\nsection the release version used is\\n[scarthgap](https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html).\\n\\nOne important point is to double check the\\n[Required Packages for the Build Host](https://docs.yoctoproject.org/ref-manual/system-requirements.html#required-packages-for-the-build-host.)\\n\\n:::\\n\\n1. Cloning all repositories for scarthgap release:\\n\\n   ```bash\\n   git clone --branch scarthgap git://git.yoctoproject.org/poky\\n   git clone --branch scarthgap https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch scarthgap https://github.com/fwup-home/meta-fwup\\n   git clone --branch scarthgap https://github.com/meta-erlang/meta-erlang\\n   git clone --branch scarthgap https://github.com/meta-erlang/meta-axon\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-erlang\\n   bitbake-layers add-layer ../meta-axon\\n   bitbake-layers add-layer ../meta-fwup\\n   ```\\n\\nWhy four layers are needed ? Because the YP/OE approach is to isolate components\\ninto layer in order to maximize the software reusability.\\n\\n## Configuring the build environment\\n\\nFor this tutorial, the quickest way is edit and add the _conf/local.conf_\\nconfiguration file.\\n\\nWe start defining the MACHINE and DISTRO:\\n\\n```bash\\nMACHINE = \\"raspberrypi0-wifi\\"\\nDISTRO = \\"poky\\"\\n```\\n\\nThe layer\\n[meta-raspberry](https://meta-raspberrypi.readthedocs.io/en/latest/readme.html)\\nprovides the machine _raspberrypi0-wifi_ which is what I\'m using for this\\ndemonstration as my current development board is a raspberry pi 0.\\n\\nNext, we need to enable some raspberry features like UART and USB host support\\n(it\'s important to get some network connectivity):\\n\\n```bash\\ntee -a <<EOF\\n# https://meta-raspberrypi.readthedocs.io/en/latest/extra-build-config.html#enable-uart\\nENABLE_UART = \\"1\\"\\n\\n# https://meta-raspberrypi.readthedocs.io/en/latest/extra-build-config.html#enable-usb-host-support\\nENABLE_DWC2_PERIPHERAL = \\"1\\"\\n\\n# add some package to allow networking\\nIMAGE_INSTALL:append = \\" raspi2go kernel-module-libcomposite kernel-module-g-ether kernel-module-dwc2\\"\\nEOF\\n```\\n\\nAs YP/OE supports many types of image outputs, we want to be specific here and\\npick only the _fwup_ type.\\n\\n```bash\\ntee -a <<EOF\\n# enable support for making fwup images\\nIMAGE_CLASSES += \\"image_types_fwup\\"\\nIMAGE_FSTYPES = \\"fwup\\"\\nEOF\\n```\\n\\nThe fwup type is provided by the bbclass\\n[image_types_fwup.bbclass](https://github.com/fwup-home/meta-fwup/blob/master/classes/image_types_fwup.bbclass).\\nIt relies on wic image generator and uses their build artifacts for bootloader\\nand rootfs.\\n\\nOk, now we also want to include Erlang/OTP and Elixir. As meta-erlang provides\\nmany versions, I recommend to stick with a specific one. In our case the latest\\n1.17.x and 27.0.x are good:\\n\\n```bash\\ntee -a <<EOF\\n# select specific elixir and erlang versions\\nPREFERRED_VERSION_elixir = \\"1.17%\\"\\nPREFERRED_VERSION_elixir-native = \\"1.17%\\"\\nPREFERRED_VERSION_nativesdk-elixir = \\"1.17%\\"\\nPREFERRED_VERSION_erlang = \\"27.0%\\"\\nPREFERRED_VERSION_erlang-native = \\"27.0%\\"\\nPREFERRED_VERSION_nativesdk-erlang = \\"27.0%\\"\\nEOF\\n```\\n\\nFinally, add erlang and elixir to the image:\\n\\n```bash\\ntee -a <<EOF\\n# add erlang and elixir into image\\nIMAGE_INSTALL:append = \\" erlang elixir\\"\\nEOF\\n```\\n\\nNow that the configuration is over. Let\'s start a build:\\n\\n```bash\\nbitbake core-image-full-cmdline\\n```\\n\\n:::note\\n\\nIt might take some time for the first build. As YP/OE will build everything from\\nscratch. The next builds should be faster.\\n\\n:::\\n\\nOnce the build has finished, let\'s inspect the build outputs:\\n\\n```bash\\ncd tmp/deploy/images/raspberrypi0-wifi\\nls -l core-image-full-cmdline*\\n-rw-r--r-- 2 builder builder 68465478 Sep 24 21:19 core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw\\nlrwxrwxrwx 2 builder builder       66 Sep 24 21:19 core-image-full-cmdline-raspberrypi0-wifi.rootfs.fw -> core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw\\n```\\n\\nThe folder _tmp/deploy/images/raspberrypi0-wifi_ has many files generated from\\nthe build tasks. We are interested only the final .fw file. In this case we the\\nfile _core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw_ is\\nwhat we need.\\n\\n## Deploying .fw images\\n\\nBefore deploying, let\'s understand a bit the image partition layout created by\\nYP/OE and fwup tool:\\n\\n```\\n# +----------------------------+\\n# | MBR                        |\\n# +----------------------------+\\n# | Firmware configuration data|\\n# | (formatted as uboot env)   |\\n# +----------------------------+\\n# | p0*: Boot A (FAT32)        |\\n# | zImage, bootcode.bin,      |\\n# | config.txt, etc.           |\\n# +----------------------------+\\n# | p0*: Boot B (FAT32)        |\\n# +----------------------------+\\n# | p1*: Rootfs A (ext4)       |\\n# +----------------------------+\\n# | p1*: Rootfs B (ext4)       |\\n# +----------------------------+\\n# | p2: Application (ext4)     |\\n# +----------------------------+\\n```\\n\\nThere is a total of three partitions. Where partition p0 and p1 have been\\ndivided by half each one. It\'s not clear to get this idea. So, I recommend you\\nto take a look into fwup configuration file used by this tutorial,\\n[core-image-full-cmdline.raspberrypi0-wifi.fwup](https://github.com/meta-erlang/meta-axon/blob/master/fwup/core-image-full-cmdline.raspberrypi0-wifi.fwup).\\nThat file has been adapted from the original\\n[nerves_system_rpi0 fwup configuration](https://github.com/nerves-project/nerves_system_rpi0/blob/main/fwup.conf).\\n\\n### burn a complete image\\n\\nMy target sdcard has 16GB there is enough space for the core-image-full-cmdline\\nimage. To start using it we need write a _complete_ image to the sdcard. By\\ncomplete image also means the the partition A will be used when the board gets\\nbooted.\\n\\n```bash\\n$ sudo fwup -a -d /dev/sda -t complete -i core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw\\n100% [====================================] 68.46 MB in / 382.20 MB out\\nSuccess!\\nElapsed time: 55.932 s\\n```\\n\\nWhen I inserted the sdcard into my workstation, my host Linux recognized it as\\n_/dev/sda_ device, using sudo when calling fwup took almost 56 seconds to write\\n382 MB to the sdcard.\\n\\nThat is all we need to get the sdcard and boot it into raspberry board.\\n\\n:::note\\n\\nThe next output is just the partition layout for a real board booted from the\\nsdcard.\\n\\n:::\\n\\nAnd in fact, it works as expected:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# sfdisk -l /dev/mmcblk0\\nDisk /dev/mmcblk0: 14.84 GiB, 15931539456 bytes, 31116288 sectors\\nUnits: sectors of 1 * 512 = 512 bytes\\nSector size (logical/physical): 512 bytes / 512 bytes\\nI/O size (minimum/optimal): 512 bytes / 512 bytes\\nDisklabel type: dos\\nDisk identifier: 0x00000000\\n\\nDevice         Boot   Start      End  Sectors  Size Id Type\\n/dev/mmcblk0p1 *         63   266302   266240  130M  c W95 FAT32 (LBA)\\n/dev/mmcblk0p2       532543  1011774   479232  234M 83 Linux\\n/dev/mmcblk0p3      1491007 31116287 29625281 14.1G 83 Linux\\n```\\n\\nChecking erl and iex versions:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# erl\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nEshell V15.0.1 (press Ctrl+G to abort, type help(). for help)\\n1>\\nUser switch command (type h for help)\\n --\x3e q\\n\\nroot@raspberrypi0-wifi:~# iex\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nwarning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (whiche\\nInteractive Elixir (1.17.1) - press Ctrl+C to exit (type h() ENTER for help)\\niex(1)>\\n```\\n\\n### move to B partition\\n\\nStill using the image\\ncore-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw, I want to\\ntest the B upgrade path. For that, the easiest way is to call fwup (which has\\nbeen installed into the image) passing some usual flags for this\\n[kind of operation](https://github.com/fwup-home/fwup?tab=readme-ov-file#whats-something-cool-that-you-can-do-with-fwup):\\n\\n:::note\\n\\nThe instructions for setting board\'s network stack using USB is not part of the\\nscope of this tutorial.\\n\\n:::\\n\\n```bash\\n$ cat core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw | ssh root@192.168.7.7 \'fwup -v -a -U -d /dev/mmcblk0 -t upgrade.b\'\\nfwup: require-partition-offset(1, 532543) -> met\\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_platform) -> met\\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_architecture) -> met\\nfwup: Upgrading partition B\\n100% [====================================] 68.46 MB in / 381.82 MB out\\nSuccess!\\nElapsed time: 1 min 30 s\\n```\\n\\nThe important argument is the `-t upgrade.b` telling to fwup which partition\\nwill be upgraded.\\n\\n:::note\\n\\nIn my setup I called `reboot` to get raspberry rebooted.\\n\\n:::\\n\\nChecking erl and iex versions:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# erl\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nEshell V15.0.1 (press Ctrl+G to abort, type help(). for help)\\n1>\\nUser switch command (type h for help)\\n --\x3e q\\n\\nroot@raspberrypi0-wifi:~# iex\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nwarning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (whiche\\nInteractive Elixir (1.17.1) - press Ctrl+C to exit (type h() ENTER for help)\\niex(1)>\\n```\\n\\nThe versions are still 1.17.x and 27.0.x, as expected.\\n\\n### move from B to A partition\\n\\nFor testing purposes, let\'s change the Elixir preferred version from 1.17.x to\\n1.16.x. For that, edit the local.conf file and change the\\n`PREFERRED_VERSION_elixir*` variables:\\n\\n```bash\\ntee -a <<EOF\\n# select specific elixir and erlang versions\\nPREFERRED_VERSION_elixir = \\"1.16%\\"\\nPREFERRED_VERSION_elixir-native = \\"1.16%\\"\\nPREFERRED_VERSION_nativesdk-elixir = \\"1.16%\\"\\nEOF\\n```\\n\\nRunning the build again:\\n\\n```bash\\nbitbake core-image-full-cmdline\\n```\\n\\nThe result will be a new core-image-full-cmdline-raspberrypi0-wifi.rootfs-\\\\*.fw\\nfilename which is ready to be used:\\n\\n```bash\\n$ cat core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240920190231.fw | ssh root@192.168.7.7 \'fwup -v -a -U -d /dev/mmcblk0 -t upgrade.a\'\\nfwup: require-partition-offset(1, 1011775) -> met\\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_platform) -> met\\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_architecture) -> met\\nfwup: Upgrading partition A\\n100% [====================================] 68.46 MB in / 381.82 MB out\\nSuccess!\\nElapsed time: 1 min 30 s\\n```\\n\\nRebooting the board and checking the iex version, we get:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# erl\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nEshell V15.0.1 (press Ctrl+G to abort, type help(). for help)\\n1>\\nUser switch command (type h for help)\\n --\x3e q\\nroot@raspberrypi0-wifi:~# iex\\nwarning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (whiche\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nInteractive Elixir (1.16.3) - press Ctrl+C to exit (type h() ENTER for help)\\n```\\n\\nThat works! Erlang/OTP 27 and Elixir 1.16.3.\\n\\n## Conclusions\\n\\nThe [fwup](https://github.com/fwup-home/fwup) tool has shown as a feasibly\\napproach for image A/B software upgrades. It is integrated into YP/OE ecosystem\\nthrough [meta-fwup](https://github.com/fwup-home/meta-fwup) layer and ready to\\ntry.\\n\\nfwup is also used by Nerves Project together with others Elixir components in\\norder to provide a full\\n[OTA updates](https://en.wikipedia.org/wiki/Over-the-air_update)."},{"id":"/2024/05/31/index","metadata":{"permalink":"/blog/2024/05/31/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-05-31/index.md","source":"@site/blog/2024-05-31/index.md","title":"New Erlang releases 27.0","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2024-05-31T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.52,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 27.0","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"fwup for A/B image upgrades","permalink":"/blog/2024/09/24/index"},"nextItem":{"title":"livebook server","permalink":"/blog/2024/04/28/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version      |\\n| ------------------ | ----------------------- |\\n| scarthgap          | 25.3.2.12, 26.2.5, 27.0 |\\n| master             | 25.3.2.12, 26.2.5, 27.0 |\\n\\nAnd the following Elixir releases:\\n\\n| meta-erlang branch | Elixir version                 |\\n| ------------------ | ------------------------------ |\\n| scarthgap          | 1.13.4, 1.14.4, 1.15.7, 1.16.3 |\\n| master             | 1.13.4, 1.14.4, 1.15.7, 1.16.3 |\\n\\nI was planing to also add Erlang/OTP 27.0 to LTS kirkstone release. However it\\nis not feasible as Erlang/OTP 27 uses autoconf 2.72 and kirkstone uses 2.71.\\nThus, there is an incompatible related to build system."},{"id":"/2024/04/28/index","metadata":{"permalink":"/blog/2024/04/28/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-04-28/index.md","source":"@site/blog/2024-04-28/index.md","title":"livebook server","description":"Intro","date":"2024-04-28T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"livebook","permalink":"/blog/tags/livebook"}],"readingTime":1.28,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"livebook server","authors":["joaohf"],"tags":["meta-erlang","livebook"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 27.0","permalink":"/blog/2024/05/31/index"},"nextItem":{"title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","permalink":"/blog/2024/04/21/index"}},"content":"## Intro\\n\\nFrom [livebook.dev](https://livebook.dev) website:\\n\\n> Automate code & data workflows with interactive notebooks.\\n\\nLivebook is getting famous for modern notebooks. It helps a lot for several\\ntasks and to solve issues where documentation and code have to walk together.\\n\\nLive book has been added to the standard beamtools SDK. That is very handy\\nbecause one can start livebook quickly and it will work with all SDK tools. That\\nmeans, we don\'t need to install anything else. It\'s all integrated.\\n\\nIf one more tool is needed, it\'s just a matter of including it into SDK and it\\nwill be ready to use.\\n\\nThe following section is a step by step in order to install livebook in any\\nmodern Linux server.\\n\\n### livebook as a Linux systemd service\\n\\nAll commands as sudo:\\n\\n```\\nwget -O /tmp/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh https://github.com/meta-erlang/meta-erlang/releases/download/beamtools-0.9.1/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh\\n\\nchmod +x /tmp/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh\\n\\nadduser --group livebook livebook\\nmkdir /home/livebook/sdk\\n\\n/tmp/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh -y -d /home/livebook/sdk/5.0.2\\n\\nchown -R livebook:livebook /home/livebook/sdk/5.0.2\\n```\\n\\nCreate a file at /etc/livebook/livebook.conf with permission livebook:livebook\\nand the following configuration:\\n\\n```\\nLIVEBOOK_DEFAULT_RUNTIME=standalone\\nLIVEBOOK_IP=0.0.0.0\\nLIVEBOOK_PORT=8080\\nLIVEBOOK_PASSWORD=livebook-instance\\nLIVEBOOK_HOME=/home/livebook\\n```\\n\\nCreate a systemd service file at /lib/systemd/system/livebook.service with the\\nfollowing:\\n\\n```\\n[Unit]\\nDescription=Livebook\\n\\n[Service]\\nType=simple\\nUser=livebook\\nGroup=livebook\\nEnvironment=SHELL=/bin/sh\\nEnvironment=HOME=/home/livebook\\nEnvironmentFile=/etc/livebook/livebook.conf\\nWorkingDirectory=/home/livebook\\nExecStart=/home/livebook/livebook.sh start\\nExecStop=/home/livebook/livebook.sh stop\\nRestart=on-failure\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nCreate a file /home/livebook/livebook.sh, change permission to\\nlivebook:livebook.\\n\\nWith the following contents:\\n\\n```\\n#!/bin/bash\\n\\n# Load SDK environment\\nsource /home/livebook/sdk/5.0.2/environment-setup-x86_64-pokysdk-linux\\n\\n# Start/Stop livebook\\nlivebook $@\\n```\\n\\nIn order to start and stop livebook, it\'s all about systemctl commands:\\n\\n- start: `systemctl start livebook`\\n- stop: `systemctl stop livebook`\\n- check status: `systemctl status livebook`"},{"id":"/2024/04/21/index","metadata":{"permalink":"/blog/2024/04/21/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-04-21/index.md","source":"@site/blog/2024-04-21/index.md","title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2024-04-21T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.175,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"livebook server","permalink":"/blog/2024/04/28/index"},"nextItem":{"title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","permalink":"/blog/2024/03/17/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version           |\\n| ------------------ | ---------------------------- |\\n| kirkstone          | 24.3.4.17, 25.3.2.12, 26.2.5 |\\n| master             | 25.3.2.12, 26.2.5, 27.0-rc3  |"},{"id":"/2024/03/17/index","metadata":{"permalink":"/blog/2024/03/17/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-03-17/index.md","source":"@site/blog/2024-03-17/index.md","title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2024-03-17T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.195,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","permalink":"/blog/2024/04/21/index"},"nextItem":{"title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","permalink":"/blog/2023/12/25/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version           |\\n| ------------------ | ---------------------------- |\\n| dunfell            | 24.3.4.16                    |\\n| kirkstone          | 24.3.4.16, 25.3.2.10, 26.2.3 |\\n| master             | 25.3.2.10, 26.2.3            |"},{"id":"/2023/12/25/index","metadata":{"permalink":"/blog/2023/12/25/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-12-25/index.md","source":"@site/blog/2023-12-25/index.md","title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-12-25T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.375,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","permalink":"/blog/2024/03/17/index"},"nextItem":{"title":"meta-erlang meets atomvm","permalink":"/blog/2023/11/02/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version          |\\n| ------------------ | --------------------------- |\\n| dunfell            | 24.3.4.15                   |\\n| kirkstone          | 24.3.4.15, 25.3.2.8, 26.2.1 |\\n| master             | 25.3.2.8, 26.2.1            |\\n\\nIn additional to those new versions, now it\'s possible to read Erlang/OTP\\ndocumentation in Erlang shell. The docs .chunk files get generated during build\\ntime and one could easily install it by adding the package _erlang-modules-dev_."},{"id":"/2023/11/02/index","metadata":{"permalink":"/blog/2023/11/02/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-11-02/index.md","source":"@site/blog/2023-11-02/index.md","title":"meta-erlang meets atomvm","description":"Intro","date":"2023-11-02T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"atomvm","permalink":"/blog/tags/atomvm"}],"readingTime":3.975,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang meets atomvm","authors":["joaohf"],"tags":["meta-erlang","atomvm"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","permalink":"/blog/2023/12/25/index"},"nextItem":{"title":"Exploring x32 psABI for Erlang/OTP","permalink":"/blog/2023/09/02/index"}},"content":"## Intro\\n\\nFrom [atomvm.net](https://www.atomvm.net/) website, atomvm is:\\n\\n> AtomVM is a lightweight implementation of the the Bogdan Erlang Abstract\\n> Machine (aka, the BEAM), a virtual machine that can execute byte-code\\n> instructions compiled from Erlang or Elixir source code. AtomVM supports a\\n> limited but functional subset of the BEAM opcodes, and also includes a small\\n> subset of the Erlang/OTP standard libraries, all optimized to run on tiny\\n> micro-controllers. With AtomVM, you can write your IoT applications in a\\n> functional programming language, using a modern actor-based concurrency model,\\n> making them vastly easier to write and understand!\\n\\nOne of the atomvm goals is the possibility to run BEAM code on really small\\nsystems like MCUs.\\n\\nFor a while, I was wondering what could be the benefits of integrating atomvm\\ninto meta-erlang recipes. It didn\'t look to make any sense for me. Then, I\\nstarted playing with that just to see if I was able to run an atomvm program in\\nQemu emulation.\\n\\nSuddenly, I ended up with all pieces to run atomvm programs integrated with\\nmeta-erlang. So this post is about how it is possible to use atomvm in Linux\\nimages based on YP/OE.\\n\\n### atomvm recipe\\n\\nThe\\n[atomvm.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-devtools/atomvm/atomvm_0.6.0-alpha1.bb)\\nrecipe is very simple because the atomvm project is based on CMake and YP has\\nsupport to it.\\n\\nHowever, I had to make a specific recipe to isolate the tool packbeam. The\\npackbeam tool lives inside atomvm source code I\'ve created a recipe called\\n[packbeam.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-devtools/atomvm/packbeam_0.6.0-alpha1.bb)\\nwhich compiles packbeam as native (that is runs on build host machine). That was\\nnecessary because the atomvm recipe crosscompile the atomvm and packbeam is used\\nby CMake to pack all .beam files to create .avm files.\\n\\nTo make atomvm recipe works, I applied a patch\\n([0001-Remove-PackBEAM-dependency-rules.patch](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-devtools/atomvm/files/0001-Remove-PackBEAM-dependency-rules.patch))\\nto disable the packbeam dependency internally. That allows me to use my packbeam\\ntool from sysroot-native instead.\\n\\n:::note\\n\\nThe mentioned patch works for my needs but is not target for sending a PR to\\natomvm project.\\n\\n:::\\n\\n### atomvm examples\\n\\nThere is the [atomvm_examples](https://github.com/atomvm/atomvm_examples)\\nproject that provides great source of ideas and examples. I wish to create some\\nrecipes to build and pack each example. So I started with the\\n[system_info](https://github.com/atomvm/atomvm_examples/tree/master/erlang/system_info).\\n\\nThe following code is the\\n[atomvm-examples-system-info_0.1.0.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-examples/atomvm-examples/atomvm-examples-system-info_0.1.0.bb)\\nrecipe. And should be enough for any Erlang project build which uses\\n[atomvm_rebar3_plugin](https://github.com/atomvm/atomvm_rebar3_plugin).\\n\\n```\\nSUMMARY = \\"Collects and displays various information about AtomVM and the environment in which it is running.\\"\\nSECTION = \\"examples\\"\\nLICENSE = \\"Apache-2.0\\"\\nLIC_FILES_CHKSUM = \\"file://LICENSE;md5=745e8b23501916820b8a509f8e3ba3d4\\"\\n\\nATOMVM_EXAMPLE = \\"erlang/system_info\\"\\n\\nS = \\"${WORKDIR}/system_info\\"\\n\\nSRCREV = \\"8e54aaf475a74b59a20f914e575202b1810a7954\\"\\nPV = \\"0.1.0+git${SRCPV}\\"\\nSRC_URI = \\"git://github.com/atomvm/atomvm_examples;branch=master;subpath=${ATOMVM_EXAMPLE};protocol=https\\"\\n\\ninherit atomvm\\n```\\n\\nThe `inherit atomvm` inherits the\\n[atomvm.bbclass](https://github.com/meta-erlang/meta-erlang/blob/master/classes/atomvm.bbclass)\\nwhich implements rebar3 commands to compile and create avm files.\\n\\n### Build and run session\\n\\nTo build the atomvm-examples-system-info recipe, we call bitbake like that:\\n\\n```\\nbitbake atomvm-examples-system-info\\n```\\n\\nNow, we want to run system_info application inside Qemu. The first step is to\\ninstall the atomvm-examples-system-info in the final image.\\n\\nIn _conf/local.conf_ file add the recipe name to the IMAGE_INSTALL variable:\\n\\n```\\nIMAGE_INSTALL:append:pn-core-image-minimal = \\" atomvm-examples-system-info\\"\\n```\\n\\nWhen building the core-image-minimal image and running it with Qemu:\\n\\n```\\nrunqemu core-image-minimal slirp nographic serialstdio\\n```\\n\\nInside the Qemu, let\'s run our first atomvm program:\\n\\n```\\nroot@qemux86-64:~# uname -a\\nLinux qemux86-64 6.5.7-yocto-standard #1 SMP PREEMPT_DYNAMIC Thu Oct 19 14:51:09 UTC 2023 x86_64 GNU/Linux\\nroot@qemux86-64:~# atomvm /usr/share/atomvm-examples-system-info/system_info.avm\\nUnsupported line_ref tag: 0\\nSystemInfo:\\n===========\\natom_count: 162\\nport_count: 0\\nprocess_count: 1\\nsystem_architecture: <<\\"Linux--x86_64\\">>\\nword_size: 8\\n\\nPlatformInfo:\\n=============\\n\\nProcessInfo:\\n============\\nPid: <0.1.0>\\nheap_size: 51\\nmemory: 848\\nmessage_queue_len: 0\\nstack_size: 9\\n\\nReturn value: ok\\n```\\n\\nThat works as expected.\\n\\n### Integration outcomes and questions\\n\\nThe recipes created so far covers running atomvm for generic unix (Linux in my\\ncase). Well, if you can afford running Erlang/Elixir on Linux, then there is no\\nselling point to use atomvm. That is true if we look at the current state of\\natomvm project for generic unix platform.\\n\\nMaybe in the future we can see extensions to generic unix allowing it to talk\\nwith i2c, gpio, spi on Linux for example, then atomvm and meta-erlang starts to\\ncover a lot of possibilities. Projects like\\n[Eclipse Mraa](https://github.com/eclipse/mraa) could be integrated with atomvm\\nproviding all the low level access for low speed IO.\\n\\nThere is another idea for meta-erlang and atomvm which is the heterogeneous\\nsystem with a combination of:\\n\\n- Linux based images running on the \\"application processing unit\\" (CPU)\\n- and \\"real-time processing unit\\" (MCU) running an atomvm program.\\n\\nmeta-erlang could build atomvm images for MCU as well for CPU. The seeds for\\nthis integration was described in this talk\\n[One Build to Rule Them All: Building FreeRTOS & Linux Using Yocto - Alejandro Hernandez](https://www.youtube.com/watch?v=mFgiIXv7b5U)\\n(the pdf is\\n[here](https://elinux.org/images/9/9f/ELC_Europe_2019_Presentation_AlejandroHernandez_FreeRTOS_ToUpload.pdf)).\\nIn that talk Alejandro shows how YP/OE projects can build MCU target images.\\nUsing the same principles also works for meta-erlang."},{"id":"/2023/09/02/index","metadata":{"permalink":"/blog/2023/09/02/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-09-02/index.md","source":"@site/blog/2023-09-02/index.md","title":"Exploring x32 psABI for Erlang/OTP","description":"Intro","date":"2023-09-02T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"x32","permalink":"/blog/tags/x-32"}],"readingTime":3.865,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Exploring x32 psABI for Erlang/OTP","authors":["joaohf"],"tags":["meta-erlang","x32"]},"unlisted":false,"prevItem":{"title":"meta-erlang meets atomvm","permalink":"/blog/2023/11/02/index"},"nextItem":{"title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","permalink":"/blog/2023/07/01/index"}},"content":"## Intro\\n\\nAccording to [Wikipedia X32 ABI](https://en.wikipedia.org/wiki/X32_ABI) page:\\n\\n> The x32 ABI is an application binary interface (ABI) and one of the interfaces\\n> of the Linux kernel. The x32 ABI provides 32-bit integers, long and pointers\\n> (ILP32) on Intel and AMD 64-bit hardware. The ABI allows programs to take\\n> advantage of the benefits of x86-64 instruction set (larger number of CPU\\n> registers, better floating-point performance, faster position-independent\\n> code, shared libraries, function parameters passed via registers, faster\\n> syscall instruction) while using 32-bit pointers and thus avoiding the\\n> overhead of 64-bit pointers.\\n\\nSo, I\'m wondering if it would be possible to enable x32 support in Erlang/OTP\\nbuild. That way, I could make a Yocto image for x32 that runs on x86-64\\nmachines.\\n\\nHere is some references about the subject:\\n\\n- [Yocto, Using x32 psABI](https://docs.yoctoproject.org/dev-manual/x32-psabi.html)\\n- [x32-abi](https://sites.google.com/site/x32abi/home?authuser=0)\\n- [X32 \u2013 A Native 32bit ABI For X86-64](http://linuxplumbersconf.org/2011/ocw//system/presentations/531/original/x32-LPC-2011-0906.pptx)\\n- [Debian x32 port](https://wiki.debian.org/X32Port)\\n- [System V Application Binary Interface AMD64 Architecture Processor Supplement (With LP64 and ILP32 Programming Models](https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf)\\n\\nIn fact, x32 seems to be around since 2011/2012 and has been integrated in many\\nplatforms. Like Ubuntu, Debian, Gentoo.\\n\\n## Building Erlang/OTP using x32 toolchain\\n\\n:::note\\n\\nA toolchain with x32 support is necessary. However, it\'s not easy to find one.\\nInstead projects like [crosstool-NG](https://crosstool-ng.github.io/) and\\n[Yocto Project](https://www.yoctoproject.org/) have tools to make a toolchain\\nwith x32 support enabled.\\n\\n:::\\n\\nIn order to follow this experiment, you can download a specific toolchain with\\nx32 enabled here:\\n[poky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh](https://github.com/meta-erlang/meta-erlang.github.io/releases/tag/x32-toolchain).\\n\\nIt will be necessary to install it in a temporary folder like the steps below:\\n\\n```\\nchmod +x poky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh\\npoky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh -y -d /tmp/poky/4.2\\n```\\n\\nFollowing the Erlang/OTP\\n[INSTALL-CROSS.md](https://github.com/erlang/otp/blob/master/HOWTO/INSTALL-CROSS.md)\\ndocument, we first need to build a Bootstrap System:\\n\\n```\\ncd $ERL_TOP\\n./configure --enable-bootstrap-only\\nmake\\n```\\n\\nNext, we have to source the toolchain environment configurations:\\n\\n```\\n. /tmp/poky/4.2/environment-setup-x86_64_x32-poky-linux-gnux32\\n```\\n\\nAfter sourcering the environment variable, the shell gets configured with some\\nextra variables using during the build:\\n\\n```\\nx86_64-poky-linux-gnux32-gcc -mx32 \\\\\\n -fstack-protector-strong \\\\\\n -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security \\\\\\n --sysroot=/tmp/poky/4.2/sysroots/x86_64_x32-poky-linux-gnux32\\n```\\n\\nIt\'s important to not the GCC flag\\n[-mx32](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#index-mx32):\\n\\n> The -mx32 option sets int, long, and pointer types to 32 bits, and generates\\n> code for the x86-64 architecture.\\n\\nFinally, start the second part of Erlang/OTP build, which is the Cross Build:\\n\\n```\\n./configure  $CONFIGURE_FLAGS  --disable-silent-rules --disable-dependency-tracking \\\\\\n\\t--with-ssl-rpath=no --disable-static  --without-javac --without-dynamic-trace --without-observer --without-odbc\\n```\\n\\nInstalling the build output and inspecting the `erlexec` binary to see what it\\nlooks like:\\n\\n```\\nmake install DESTDIR=/tmp/e\\n\\nfile /tmp/e/usr/local/lib/erlang/erts-14.0.2/bin/erlexec\\nerlexec: ELF 32-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /libx32/ld-linux-x32.so.2, BuildID[sha1]=013e32ef8c57686a59a812ca452f09d677ff8e37, for GNU/Linux 5.15.0, with debug_info, not stripped\\n```\\n\\nWell, the build is correct. But I couldn\'t test this build in my machine.\\n\\n## Enabling Erlang for Yocto\\n\\nIn the previous section we just build Erlang/OTP using a toolchain with x32\\nsupport. Now, it\'s time to build Erlang/OTP inside the Yocto project and test\\nthe results using qemu instance.\\n\\nEnabling it for Yocto is simple, just adding the follow snippet in your\\nlocal.conf file:\\n\\n```\\nMACHINE = \\"qemux86-64\\"\\nDEFAULTTUNE = \\"x86-64-x32\\"\\nbaselib = \\"${@d.getVar(\'BASE_LIB:tune-\' + (d.getVar(\'DEFAULTTUNE\') or \'INVALID\')) or \'lib\'}\\"\\n```\\n\\nThen, building erlang:\\n\\n```\\nbitbake erlang\\n```\\n\\n:::note\\n\\nFor those that want to check all configure and compiler flags, I\'m including the\\nlinks to those logs:\\n\\n- [Configure log output](pathname:///assets/log.do_configure)\\n- [Compile log output](pathname:///assets/log.do_compile)\\n\\n:::\\n\\nThe build failed in one point related to ASM code in\\n[erts/lib_src/pthread/ethread.c](https://github.com/erlang/otp/blob/maint-26/erts/lib_src/pthread/ethread.c#L193).\\nLooks like an ASM incompatibility issue. In order to address it here is\\n[a patch](https://github.com/joaohf/otp/commit/6cd15d5888a536af97f5d8e26b2db2e379fa7eab)\\nthat just adds one more compiler check to pick up the correct ifdef branch.\\n\\nAfer that, the build runs as expected. And testing it using QEMU shows exactly\\nwhat I had in mind:\\n\\n```\\nrunqemu core-image-minimal-qemux86-64.ext4 slirp nographic serialstdio\\n```\\n\\n- check the current kernel\\n\\n```\\nroot@qemux86-64:~# uname -a\\nLinux qemux86-64 6.1.32-yocto-standard #1 SMP PREEMPT_DYNAMIC Mon Jun  5 13:43:33 UTC 2023 x86_64 GNU/Linux\\n```\\n\\n- check /proc/cpuinfo to see the \'lm\' (long mode)\\n\\n```\\nroot@qemux86-64:~# grep -o -w \'lm\' /proc/cpuinfo\\nlm\\n```\\n\\n- check Erlang shell\\n\\n```\\nErlang/OTP 26 [erts-14.0.2] [source] [32-bit] [smp:4:4] [ds:4:4:10] [async-threads:1]\\n\\nEshell V14.0.2 (press Ctrl+G to abort, type help(). for help)\\n1> application:ensure_all_started(crypto).\\n{ok,[crypto]}\\n```\\n\\nWell, looks like we are running Erlang/OTP 32-bits in a x86_64 machine. Also, it\\nwas able to correct load the crypto (with ssl libraries compiled for x32 too).\\nBy the way, there is a second\\n[patch need to proper compile the crypto application](https://github.com/joaohf/otp/commit/e63b5b703ffa0005bf6a8f4d3bcec18f786bda92).\\n\\nSome raised questions for further investigations:\\n\\n- What tests are necessary to prove that the x32 Erlang build is safe ?\\n- Are there any other code change in order to fit the x32 build ?\\n- Would [BeamAsm](https://www.erlang.org/doc/apps/erts/beamasm#faq) be available\\n  for x32 ?"},{"id":"/2023/07/01/index","metadata":{"permalink":"/blog/2023/07/01/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-07-01/index.md","source":"@site/blog/2023-07-01/index.md","title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-07-01T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.335,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"Exploring x32 psABI for Erlang/OTP","permalink":"/blog/2023/09/02/index"},"nextItem":{"title":"New meta-erlang branch mickledore","permalink":"/blog/2023/06/09/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version          |\\n| ------------------ | --------------------------- |\\n| dunfell            | 24.3.4.13                   |\\n| kirkstone          | 24.3.4.13, 25.3.2.3, 26.0.2 |\\n| mickledore         | 25.3.2.3, 26.0.2            |\\n\\nIn additional to those new versions, a new\\n[beamtools](https://meta-erlang.github.io/docs/guides/guides-beamtools/) is\\navailable\\n[here](https://github.com/meta-erlang/meta-erlang/releases/tag/beamtools-0.7.0).\\n\\nThis new version was made with\\n[Yocto mickledore](https://docs.yoctoproject.org/dev/migration-guides/migration-4.2.html)\\nrelease and brings Erlang/OTP 26.0.2 and Elixir 1.15.2."},{"id":"/2023/06/09/index","metadata":{"permalink":"/blog/2023/06/09/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-06-09/index.md","source":"@site/blog/2023-06-09/index.md","title":"New meta-erlang branch mickledore","description":"Yocto Project has released a new","date":"2023-06-09T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.365,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New meta-erlang branch mickledore","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","permalink":"/blog/2023/07/01/index"},"nextItem":{"title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","permalink":"/blog/2023/05/07/index"}},"content":"Yocto Project has [released](https://wiki.yoctoproject.org/wiki/Releases) a new\\n[version 4.2 (Mickledore)](https://docs.yoctoproject.org/dev/migration-guides/migration-4.2.html).\\nAs consequence meta-erlang brings a new branch mickledore updating most of the\\nrecipes. mickledore release is not a LTS release and community support will be\\navailable until November 2023.\\n\\nWe\'ve also upgraded to the latest Erlang/OTP and Elixir releases supporting the\\nfollowing new Erlang/OTP releases:\\n\\n- Erlang/OTP 26.0.1\\n- Erlang/OTP 25.3.2.2\\n- Elixir 1.14.4\\n\\nIt\'s worth mentioning the meta-erlang master has also been updated."},{"id":"/2023/05/07/index","metadata":{"permalink":"/blog/2023/05/07/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-05-07/index.md","source":"@site/blog/2023-05-07/index.md","title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-05-07T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.645,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New meta-erlang branch mickledore","permalink":"/blog/2023/06/09/index"},"nextItem":{"title":"meta-erlang on cloud II: building your own application","permalink":"/blog/2023/02/04/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version |\\n| ------------------ | ------------------ |\\n| dunfell            | 24.3.4.11          |\\n| kirkstone          | 24.3.4.11, 25.3.2  |\\n| langdale           | 25.3.2             |\\n\\nRemoved recipes:\\n\\n- For langdale the recipes ejabberd and emqx have been removed due the lack of\\n  supporting cross-compilation build in a stable way.\\n\\nUpdated recipes:\\n\\n- For langdale the following recipes have been updated: lux, vernemq, yaws,\\n  tsung, riak, couchdb. It is important to mention about langdale\\n  [EOL in May 2023](https://wiki.yoctoproject.org/wiki/Releases). So, this\\n  branch will not receive updates.\\n\\nIt has been decided:\\n\\n- Dropped support to Erlang/OTP 24 in langdale. Due the lack of deterministic\\n  build flags in 24. Elixir 1.12 has also been dropped (because it dependes on\\n  Erlang/OTP 24)."},{"id":"/2023/02/04/index","metadata":{"permalink":"/blog/2023/02/04/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-02-04/index.md","source":"@site/blog/2023-02-04/index.md","title":"meta-erlang on cloud II: building your own application","description":"\x3c!---","date":"2023-02-04T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":3.98,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang on cloud II: building your own application","authors":["joaohf"],"tags":["meta-erlang","cloud"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","permalink":"/blog/2023/05/07/index"},"nextItem":{"title":"meta-erlang on cloud I: EWAOL based","permalink":"/blog/2023/01/29/index"}},"content":"\x3c!---\\n\\n- The previous blog has showed how to use EWAOL and adds meta-erlang support to it\\n- Now it\'s time to create something more tiny with only the components that we need\\n- meta-xpto for cloud erlang/elixir services\\n- How to create an image\\n- Publish to AWS AMI\\n- Run a instance\\n- Conclusion\\n\\n--\x3e\\n\\n## Intro\\n\\nThe\\n[meta-erlang on cloud II, build your own application](/blog/2023/02/04/index)\\npost has shown the basic idea for how would be possible (and in fact it is\\npossible) to build a custom Linux distribution and run it on Graviton AWS\\ninstances.\\n\\nNow, it\'s time to refactor out the previous result. Removing what are not\\nnecessary in order to create a slim meta-erlang cloud ready image.\\n\\nSo, this post is more like a tutorial to reach two main targets:\\n\\n- Explore a demo Yocto layer which shows the basic pieces to run a distro on\\n  Graviton\\n- Add [livebook](https://livebook.dev/) to that image and try it on cloud. Why\\n  not trying some GPU processing :)\\n\\n## meta-axon cloud aware\\n\\n[meta-axon](https://github.com/meta-erlang/meta-axon) is my playground layer\\nfocused on demonstrate how Erlang and Elixir applications could be integrated\\nwith Yocto ecosystem. Until now, meta-axon has been tailored to run on embedded\\ndevices (like raspberry pi). But, I\'m also added, along side with the former\\n[axon-slim](https://github.com/meta-erlang/meta-axon/conf/distro/axon.conf), a\\nnew distro called\\n[axon](https://github.com/meta-erlang/meta-axon/conf/distro/axon.conf). The axon\\ndistro is focused on cloud, for the purpose of this tutorial AWS cloud.\\n\\n:::tip\\n\\nIf you are new to the Yocto Project; remember some basic\\n[concepts here](https://docs.yoctoproject.org/overview-manual/concepts.html#yocto-project-concepts).\\n\\n:::\\n\\nI also introduced a new image called\\n[axon-image-cloud](https://github.com/meta-erlang/meta-axon/recipes-extented/image/axon-image-cloud.bb)\\nwith all the pieces needed to run it on Graviton instances. This image relies on\\nsystemd plus [cloud-init](https://cloud-init.io/) scripts.\\n\\nIt is important to mention that to run images on Graviton it is necessary to add\\ntwo layer dependencies:\\n\\n- [meta-arm](https://git.yoctoproject.org/git/meta-arm), implementing a generic\\n  ARM 64 bits machine\\n- [meta-virtualization](https://git.yoctoproject.org/git/meta-virtualization),\\n  bringing cloud-init recipe\\n\\nThe rest of the needed components are all provided by standard Yocto layers\\n(like: poky and meta-openembedded).\\n\\n## Build instructions\\n\\nWe want fast feedback and test the build results quickly. So here is the\\nprocedure that will build an distro linux image with Erlang, Elixir and\\n[livebook](https://livebook.dev/):\\n\\n:::note\\n\\nI\'m assuming a working Linux environment in order to run the below commands.\\n\\n:::\\n\\n1. Clone the meta-axon layer:\\n\\n   ```bash\\n   git clone https://github.com/meta-erlang/meta-axon.git\\n   cd meta-axon\\n   ```\\n\\n1. Install the [kas](https://kas.readthedocs.io/en/latest/) tool to setup a\\n   bitbake based project.\\n\\n   ```bash\\n   git clone https://github.com/siemens/kas\\n   cd kas\\n   pip3 install .\\n   ```\\n\\n1. Call kas tool to build everything:\\n\\n   ```bash\\n   kas build kas/machines/meta-erlang-graviton2-livebook.yaml\\n   ```\\n\\n   :::note\\n\\n   The final image has been created in the deploy folder:\\n   _tmp/deploy/images/generic-arm64_.\\n\\n   :::\\n\\n1. Run the script _create-ami.sh_ to convert and upload a image made with Yocto\\n   into AWS AMI. Use your s3 bucket and specific how much extra space you want:\\n\\n   ```bash\\n   ../scripts/create-ami.sh <add your s3 bucket here> 8\\n   ```\\n\\n:::info\\n\\nThe script _create_ami.sh_ may need a fix in order to find the correct place for\\nthe _qemu-img_ tool. Would be nice to have some sort of Yocto bbclass to\\nautomatically convert and push the AMI image to AWS. But it is not the case yet.\\n\\n:::\\n\\n## Launching EC2 instances\\n\\nAfter uploading the image, it\'s time to lunch an EC2 instance like the\\nfollowing:\\n\\n:::tip\\n\\nRemember to use a _Free Trial available_ instance type. When I wrote this post,\\nthe eligible tier was the t4g.small.\\n\\n:::\\n\\n![alt Launching a new EC2 instance](ec2_instance.jpg \'Launching a new EC2 instance\')\\n\\nAnd, finally here is it running:\\n\\n![alt Running a new EC2 instance](ec2_running.jpg \'Running a new EC2 instance\')\\n\\nAccessing the instance via ssh and login with the user _axon_ should work as\\nexpected. After all it is a normal Linux distro.\\n\\n## Results\\n\\nThe following two screenshots show the livebook instance up and running on\\nGraviton EC2 instance. It is pretty cool.\\n\\nJust showing the `top` command to check all the running process:\\n\\n![alt Livebook instance Graviton](livebook_instance.jpg \'Livebook instance on Graviton\')\\n\\nAnd here is the livebook system dashboard to inspect some usage statistics, and\\nsystem information:\\n\\n![alt Livebook dashboard on Graviton](livebook_dashboard.jpg \'Livebook dashboard on Graviton\')\\n\\nAs you can see, it is running on ARM64, with JIT enable.\\n\\n## Conclusion\\n\\nNow we are converging to create the basic building blocks for creating custom\\nLinux distribution based on Yocto Project that runs on Cloud.\\n\\nThat could be the perfect case for projects that need to take control on every\\ndetail of the software stack. From linx kernel configuration, building flags,\\nsoftware configuration flags, anything. It\'s really flexible.\\n\\nAnd for projects that relies on Erlang and Elixir, it is also amazing bringing\\nit to Cloud ecosystem.\\n\\nThe first blog part\\n[meta-erlang on cloud I: EWAOL based](/blog/2023/01/29/index) has introduced\\nwhat is possible to build. This blog post is more related to explore the\\nintroduced idea into something feasible and aligned with meta-erlang purposes."},{"id":"/2023/01/29/index","metadata":{"permalink":"/blog/2023/01/29/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-01-29/index.md","source":"@site/blog/2023-01-29/index.md","title":"meta-erlang on cloud I: EWAOL based","description":"\x3c!---","date":"2023-01-29T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":4.07,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang on cloud I: EWAOL based","authors":["joaohf"],"tags":["meta-erlang","cloud"]},"unlisted":false,"prevItem":{"title":"meta-erlang on cloud II: building your own application","permalink":"/blog/2023/02/04/index"},"nextItem":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","permalink":"/blog/2023/01/22/index"}},"content":"\x3c!---\\n\\n- Describe what is the idea: create meta-erlang YP based images with Erlang/OTP and Elixir\\n- Be able to generate images and push them to AWS\\n- Instantiate https://aws.amazon.com/ec2/graviton/ instances\\n- Run Erlang/OTP and Elixir based services like couchdb, riak, livebook\\n- Points some future directions and what would be possible to create\\n\\n--\x3e\\n\\n## Intro\\n\\nThe [Yocto Project](https://www.yoctoproject.org/) has been made to create\\nspecific embedded Linux distributions. And still does a great job on this field\\nmaking it possible to run softwares in a range of target architectures.\\n\\nBut, the term _embedded Linux distribution_ should be expanded a bit more; it\'s\\nnot only about creating tiny filesystem within cross-compiled software, scripts\\nand configurations targeting platforms with small footprint, CPU and memory\\nconstraints.\\n\\nWe could do more, actually there are people using the not so newly but still new\\nARM processors that runs on cloud environment. For sure the most famous one is\\nthe\\n[Graviton EC2 instances, on AWS cloud](https://aws.amazon.com/ec2/graviton/).\\n\\nLooking into these Graviton processors and Yocto Project, what would it be\\npossible ? Maybe running Yocto images on Graviton instances could be feasible\\nenough to run some workload. And what about adding Erlang/OTP and Elixir to that\\nmix ? Or running some advanced database or broker made with Erlang ?\\n\\nThat is exactly what we will try to experiment. In this first post about running\\nmeta-erlang on cloud, we are going to look how it would be possible.\\n\\nActually there are folks whose made possible to run Yocto images on Graviton\\ninstances. Technically is pretty simple and all bits and bytes have been\\ndescribed in the blog post\\n[Building an Automotive Embedded Linux Image for Edge and Cloud Using Arm-based Graviton Instances, Yocto Project, and SOAFEE](https://aws.amazon.com/blogs/industries/building-an-automotive-embedded-linux-image-for-edge-using-arm-graviton-yocto-project-soafee/).\\nThe companion repository also worth the reading\\n[The meta-aws-ewaol repository](https://github.com/aws4embeddedlinux/meta-aws-ewaol).\\n\\nThe idea that [1] brings is part of another idea related to Software-Defined\\nVehicles through Cloud [2] which is very excited. These references also cites a\\nframework to build Edge Workloads [3] and in fact the EWAOL (Edge Workload\\nAbstraction and Orchestration Layer) was used as a base to produce the\\n[meta-aws-ewaol](https://github.com/aws4embeddedlinux/meta-aws-ewaol) layer.\\n\\n## Putting everything together, first experiment\\n\\nSo, based on all what has been described so far and as a first experience, I\'ve\\ntested meta-aws-ewaol setup and added meta-erlang into that. The aim was to run\\n`erl` and `iex` console on Graviton EC2 instances.\\n\\nI had to make a few fixes on meta-aws-ewaol and pushed the results here:\\n[meta-aws-ewaol with meta-erlang](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang).\\nThe rest of this session is a small guide that I made in order to run our first\\nexperiment.\\n\\nWith a ready Yocto environment, following the\\n[Building EWAOL](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#building-ewaol)\\nsession is enough to get the system built. It\'s just Yocto, nothing more.\\n\\n:::tip\\n\\n- You can create a free AWS account. There are Graviton instances included in\\n  the AWS free tier. It\'s more than sufficient.\\n- Bear in mind that you don\'t need to be an AWS master but you will end up\\n  spending some time learning how to create AWS services.\\n\\n:::\\n\\nThe next step is to create and setup all the AWS infrastructure needed in order\\nto push the Yocto image as AWS AMI and start the Graviton Instance. Lucky, there\\nis a Cloud Formation template which performs the initial setup. The session\\n[Pre-requisites](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#pre-requisites)\\nhelps to clarify it.\\n\\nThen, having the Yocto image and the basic AWS account in place. It\'s time to\\nuse\\n[a special script](https://github.com/joaohf/meta-aws-ewaol/blob/main-add-meta-erlang/scripts/create-ami.sh)\\nto convert Yocto image to an AMI image. Most of the job is done by awscli\\ncommands. There is nothing related to Yocto here. The session\\n[Creating AMI from image file](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#creating-ami-from-image-file)\\ntells what is necessary to do.\\n\\nFinally, the last part. After pushing the AMI image to the S3 bucket. The fun\\npart is to instantiate a Graviton instance (please refer to the session\\n[Launch the EC2 Image as usual using your newly created AMI](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#launch-the-ec2-image-as-usual-using-your-newly-created-ami))\\nan run the EWAOL based image and test how Erlang and Elixir looks like.\\n\\nI\'ve added two screenshots below just to have a taste of the final results:\\n\\n![alt Erlang console](meta-erlang-gravitron-erl.jpg \'Erlang console\')\\n\\n![alt Elixir console](meta-erlang-gravitron-iex.jpg \'Elixir console\')\\n\\n## Conclusion\\n\\nThis first experiment has finished and I can conclude two main bullets:\\n\\n- It is possible to build a Yocto image and run it on Graviton instances\\n- meta-aws-ewaol is a great start point. And the EWAOL framework looks solid for\\n  what it has been planned for.\\n\\nHowever, what I am looking for is to run a tiny image with just the necessary to\\ninstantiate an ARM cloud instance running Erlang/Elixir. That is what the next\\nblog post will do:\\n[meta-erlang on cloud II, build your own application](/blog/2023/02/04/index)\\n\\n## References\\n\\n- [1]:\\n  [Building an Automotive Embedded Linux Image for Edge and Cloud Using Arm-based Graviton Instances, Yocto Project, and SOAFEE](https://aws.amazon.com/blogs/industries/building-an-automotive-embedded-linux-image-for-edge-using-arm-graviton-yocto-project-soafee/)\\n- [2]:\\n  [Accelerating Software-Defined Vehicles through Cloud-To-Vehicle Edge Environmental Parity](https://armkeil.blob.core.windows.net/developer/Files/pdf/white-paper/arm-aws-edge-environmental-parity-wp.pdf)\\n- [3]:\\n  [Edge Workload Abstraction and Orchestration Layer (EWAOL) Documentation](https://ewaol.docs.arm.com/en/kirkstone-dev/index.html)"},{"id":"/2023/01/22/index","metadata":{"permalink":"/blog/2023/01/22/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-01-22/index.md","source":"@site/blog/2023-01-22/index.md","title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-01-22T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.685,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"meta-erlang on cloud I: EWAOL based","permalink":"/blog/2023/01/29/index"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version         |\\n| ------------------ | -------------------------- |\\n| dunfell            | 24.3.4.8                   |\\n| kirkstone          | 24.3.4.8, 25.1.2.1, 25.2.1 |\\n| langdale           | 24.3.4.8, 25.1.2.1, 25.2.1 |\\n\\nFixed bugs:\\n\\n- [QA Issue buildpaths (reproducible builds) when building with langdale](https://github.com/meta-erlang/meta-erlang/issues/205),\\n  a specific patch has been integrated in order to avoid building flags into the\\n  final beam.smp binary.\\n\\nTo be decided:\\n\\n- Yocto Langdale release has enabled reproducible build checks. Erlang/OTP from\\n  25 and later implements special flags to fix reproducible issues. But\\n  Erlang/OTP 24 does not have these special flags as a consequence langdale\\n  Erlang/OTP 24 builds warns about: _packages contains reference to TMPDIR\\n  [buildpaths]_. There are two paths that we could get. One is to drop\\n  Erlang/OTP 24 support OR disable QA buildpaths checking."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2022-12-30-welcome/index.md","source":"@site/blog/2022-12-30-welcome/index.md","title":"Welcome","description":"This new website is based on Docusaurus documentation","date":"2022-12-30T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.33,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","permalink":"/blog/2023/01/22/index"}},"content":"This new website is based on [Docusaurus](https://docusaurus.io) documentation\\nframework. The previous site was using [docsify](https://docsify.js.org/#/),\\nwhich is also great. But Docusaurus address others concerns when writing\\ndocumentation for open source project.\\n\\nSo, the site has a new frontend page and a blog session where we want to add\\nlatest meta-erlang release highlights. The documentation session is pretty much\\nthe same plus some improvements on\\n[Introduction](https://meta-erlang.github.io/docs/) chapter."}]}}')}}]);