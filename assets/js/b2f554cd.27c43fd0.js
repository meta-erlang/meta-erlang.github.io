"use strict";(self.webpackChunkmeta_erlang_github_io=self.webpackChunkmeta_erlang_github_io||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/02/04/index","metadata":{"permalink":"/blog/2023/02/04/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-02-04/index.md","source":"@site/blog/2023-02-04/index.md","title":"meta-erlang on cloud II: building your own application","description":"\x3c!---","date":"2023-02-04T00:00:00.000Z","formattedDate":"February 4, 2023","tags":[{"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":3.98,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf"}],"frontMatter":{"title":"meta-erlang on cloud II: building your own application","authors":["joaohf"],"tags":["meta-erlang","cloud"]},"nextItem":{"title":"meta-erlang on cloud I: EWAOL based","permalink":"/blog/2023/01/29/index"}},"content":"\x3c!---\\n\\n- The previous blog has showed how to use EWAOL and adds meta-erlang support to it\\n- Now it\'s time to create something more tiny with only the components that we need\\n- meta-xpto for cloud erlang/elixir services\\n- How to create an image\\n- Publish to AWS AMI\\n- Run a instance\\n- Conclusion\\n\\n--\x3e\\n\\n## Intro\\n\\nThe\\n[meta-erlang on cloud II, build your own application](/blog/2023/02/04/index)\\npost has shown the basic idea for how would be possible (and in fact it is\\npossible) to build a custom Linux distribution and run it on Graviton AWS\\ninstances.\\n\\nNow, it\'s time to refactor out the previous result. Removing what are not\\nnecessary in order to create a slim meta-erlang cloud ready image.\\n\\nSo, this post is more like a tutorial to reach two main targets:\\n\\n- Explore a demo Yocto layer which shows the basic pieces to run a distro on\\n  Graviton\\n- Add [livebook](https://livebook.dev/) to that image and try it on cloud. Why\\n  not trying some GPU processing :)\\n\\n## meta-axon cloud aware\\n\\n[meta-axon](https://github.com/meta-erlang/meta-axon) is my playground layer\\nfocused on demonstrate how Erlang and Elixir applications could be integrated\\nwith Yocto ecosystem. Until now, meta-axon has been tailored to run on embedded\\ndevices (like raspberry pi). But, I\'m also added, along side with the former\\n[axon-slim](https://github.com/meta-erlang/meta-axon/conf/distro/axon.conf), a\\nnew distro called\\n[axon](https://github.com/meta-erlang/meta-axon/conf/distro/axon.conf). The axon\\ndistro is focused on cloud, for the purpose of this tutorial AWS cloud.\\n\\n:::tip\\n\\nIf you are new to the Yocto Project; remember some basic\\n[concepts here](https://docs.yoctoproject.org/overview-manual/concepts.html#yocto-project-concepts).\\n\\n:::\\n\\nI also introduced a new image called\\n[axon-image-cloud](https://github.com/meta-erlang/meta-axon/recipes-extented/image/axon-image-cloud.bb)\\nwith all the pieces needed to run it on Graviton instances. This image relies on\\nsystemd plus [cloud-init](https://cloud-init.io/) scripts.\\n\\nIt is important to mention that to run images on Graviton it is necessary to add\\ntwo layer dependencies:\\n\\n- [meta-arm](https://git.yoctoproject.org/git/meta-arm), implementing a generic\\n  ARM 64 bits machine\\n- [meta-virtualization](https://git.yoctoproject.org/git/meta-virtualization),\\n  bringing cloud-init recipe\\n\\nThe rest of the needed components are all provided by standard Yocto layers\\n(like: poky and meta-openembedded).\\n\\n## Build instructions\\n\\nWe want fast feedback and test the build results quickly. So here is the\\nprocedure that will build an distro linux image with Erlang, Elixir and\\n[livebook](https://livebook.dev/):\\n\\n:::note\\n\\nI\'m assuming a working Linux environment in order to run the below commands.\\n\\n:::\\n\\n1. Clone the meta-axon layer:\\n\\n   ```bash\\n   git clone https://github.com/meta-erlang/meta-axon.git\\n   cd meta-axon\\n   ```\\n\\n1. Install the [kas](https://kas.readthedocs.io/en/latest/) tool to setup a\\n   bitbake based project.\\n\\n   ```bash\\n   git clone https://github.com/siemens/kas\\n   cd kas\\n   pip3 install .\\n   ```\\n\\n1. Call kas tool to build everything:\\n\\n   ```bash\\n   kas build kas/machines/meta-erlang-graviton2-livebook.yaml\\n   ```\\n\\n   :::note\\n\\n   The final image has been created in the deploy folder:\\n   _tmp/deploy/images/generic-arm64_.\\n\\n   :::\\n\\n1. Run the script _create-ami.sh_ to convert and upload a image made with Yocto\\n   into AWS AMI. Use your s3 bucket and specific how much extra space you want:\\n\\n   ```bash\\n   ../scripts/create-ami.sh <add your s3 bucket here> 8\\n   ```\\n\\n:::info\\n\\nThe script _create_ami.sh_ may need a fix in order to find the correct place for\\nthe _qemu-img_ tool. Would be nice to have some sort of Yocto bbclass to\\nautomatically convert and push the AMI image to AWS. But it is not the case yet.\\n\\n:::\\n\\n## Launching EC2 instances\\n\\nAfter uploading the image, it\'s time to lunch an EC2 instance like the\\nfollowing:\\n\\n:::tip\\n\\nRemember to use a _Free Trial available_ instance type. When I wrote this post,\\nthe eligible tier was the t4g.small.\\n\\n:::\\n\\n![alt Launching a new EC2 instance](ec2_instance.jpg \'Launching a new EC2 instance\')\\n\\nAnd, finally here is it running:\\n\\n![alt Running a new EC2 instance](ec2_running.jpg \'Running a new EC2 instance\')\\n\\nAccessing the instance via ssh and login with the user _axon_ should work as\\nexpected. After all it is a normal Linux distro.\\n\\n## Results\\n\\nThe following two screenshots show the livebook instance up and running on\\nGraviton EC2 instance. It is pretty cool.\\n\\nJust showing the `top` command to check all the running process:\\n\\n![alt Livebook instance Graviton](livebook_instance.jpg \'Livebook instance on Graviton\')\\n\\nAnd here is the livebook system dashboard to inspect some usage statistics, and\\nsystem information:\\n\\n![alt Livebook dashboard on Graviton](livebook_dashboard.jpg \'Livebook dashboard on Graviton\')\\n\\nAs you can see, it is running on ARM64, with JIT enable.\\n\\n## Conclusion\\n\\nNow we are converging to create the basic building blocks for creating custom\\nLinux distribution based on Yocto Project that runs on Cloud.\\n\\nThat could be the perfect case for projects that need to take control on every\\ndetail of the software stack. From linx kernel configuration, building flags,\\nsoftware configuration flags, anything. It\'s really flexible.\\n\\nAnd for projects that relies on Erlang and Elixir, it is also amazing bringing\\nit to Cloud ecosystem.\\n\\nThe first blog part\\n[meta-erlang on cloud I: EWAOL based](/blog/2023/01/29/index) has introduced\\nwhat is possible to build. This blog post is more related to explore the\\nintroduced idea into something feasible and aligned with meta-erlang purposes."},{"id":"/2023/01/29/index","metadata":{"permalink":"/blog/2023/01/29/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-01-29/index.md","source":"@site/blog/2023-01-29/index.md","title":"meta-erlang on cloud I: EWAOL based","description":"\x3c!---","date":"2023-01-29T00:00:00.000Z","formattedDate":"January 29, 2023","tags":[{"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":4.07,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf"}],"frontMatter":{"title":"meta-erlang on cloud I: EWAOL based","authors":["joaohf"],"tags":["meta-erlang","cloud"]},"prevItem":{"title":"meta-erlang on cloud II: building your own application","permalink":"/blog/2023/02/04/index"},"nextItem":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","permalink":"/blog/2023/01/22/index"}},"content":"\x3c!---\\n\\n- Describe what is the idea: create meta-erlang YP based images with Erlang/OTP and Elixir\\n- Be able to generate images and push them to AWS\\n- Instantiate https://aws.amazon.com/ec2/graviton/ instances\\n- Run Erlang/OTP and Elixir based services like couchdb, riak, livebook\\n- Points some future directions and what would be possible to create\\n\\n--\x3e\\n\\n## Intro\\n\\nThe [Yocto Project](https://www.yoctoproject.org/) has been made to create\\nspecific embedded Linux distributions. And still does a great job on this field\\nmaking it possible to run softwares in a range of target architectures.\\n\\nBut, the term _embedded Linux distribution_ should be expanded a bit more; it\'s\\nnot only about creating tiny filesystem within cross-compiled software, scripts\\nand configurations targeting platforms with small footprint, CPU and memory\\nconstraints.\\n\\nWe could do more, actually there are people using the not so newly but still new\\nARM processors that runs on cloud environment. For sure the most famous one is\\nthe\\n[Graviton EC2 instances, on AWS cloud](https://aws.amazon.com/ec2/graviton/).\\n\\nLooking into these Graviton processors and Yocto Project, what would it be\\npossible ? Maybe running Yocto images on Graviton instances could be feasible\\nenough to run some workload. And what about adding Erlang/OTP and Elixir to that\\nmix ? Or running some advanced database or broker made with Erlang ?\\n\\nThat is exactly what we will try to experiment. In this first post about running\\nmeta-erlang on cloud, we are going to look how it would be possible.\\n\\nActually there are folks whose made possible to run Yocto images on Graviton\\ninstances. Technically is pretty simple and all bits and bytes have been\\ndescribed in the blog post\\n[Building an Automotive Embedded Linux Image for Edge and Cloud Using Arm-based Graviton Instances, Yocto Project, and SOAFEE](https://aws.amazon.com/blogs/industries/building-an-automotive-embedded-linux-image-for-edge-using-arm-graviton-yocto-project-soafee/).\\nThe companion repository also worth the reading\\n[The meta-aws-ewaol repository](https://github.com/aws4embeddedlinux/meta-aws-ewaol).\\n\\nThe idea that [1] brings is part of another idea related to Software-Defined\\nVehicles through Cloud [2] which is very excited. These references also cites a\\nframework to build Edge Workloads [3] and in fact the EWAOL (Edge Workload\\nAbstraction and Orchestration Layer) was used as a base to produce the\\n[meta-aws-ewaol](https://github.com/aws4embeddedlinux/meta-aws-ewaol) layer.\\n\\n## Putting everything together, first experiment\\n\\nSo, based on all what has been described so far and as a first experience, I\'ve\\ntested meta-aws-ewaol setup and added meta-erlang into that. The aim was to run\\n`erl` and `iex` console on Graviton EC2 instances.\\n\\nI had to make a few fixes on meta-aws-ewaol and pushed the results here:\\n[meta-aws-ewaol with meta-erlang](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang).\\nThe rest of this session is a small guide that I made in order to run our first\\nexperiment.\\n\\nWith a ready Yocto environment, following the\\n[Building EWAOL](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#building-ewaol)\\nsession is enough to get the system built. It\'s just Yocto, nothing more.\\n\\n:::tip\\n\\n- You can create a free AWS account. There are Graviton instances included in\\n  the AWS free tier. It\'s more than sufficient.\\n- Bear in mind that you don\'t need to be an AWS master but you will end up\\n  spending some time learning how to create AWS services.\\n\\n:::\\n\\nThe next step is to create and setup all the AWS infrastructure needed in order\\nto push the Yocto image as AWS AMI and start the Graviton Instance. Lucky, there\\nis a Cloud Formation template which performs the initial setup. The session\\n[Pre-requisites](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#pre-requisites)\\nhelps to clarify it.\\n\\nThen, having the Yocto image and the basic AWS account in place. It\'s time to\\nuse\\n[a special script](https://github.com/joaohf/meta-aws-ewaol/blob/main-add-meta-erlang/scripts/create-ami.sh)\\nto convert Yocto image to an AMI image. Most of the job is done by awscli\\ncommands. There is nothing related to Yocto here. The session\\n[Creating AMI from image file](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#creating-ami-from-image-file)\\ntells what is necessary to do.\\n\\nFinally, the last part. After pushing the AMI image to the S3 bucket. The fun\\npart is to instantiate a Graviton instance (please refer to the session\\n[Launch the EC2 Image as usual using your newly created AMI](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#launch-the-ec2-image-as-usual-using-your-newly-created-ami))\\nan run the EWAOL based image and test how Erlang and Elixir looks like.\\n\\nI\'ve added two screenshots below just to have a taste of the final results:\\n\\n![alt Erlang console](meta-erlang-gravitron-erl.jpg \'Erlang console\')\\n\\n![alt Elixir console](meta-erlang-gravitron-iex.jpg \'Elixir console\')\\n\\n## Conclusion\\n\\nThis first experiment has finished and I can conclude two main bullets:\\n\\n- It is possible to build a Yocto image and run it on Graviton instances\\n- meta-aws-ewaol is a great start point. And the EWAOL framework looks solid for\\n  what it has been planned for.\\n\\nHowever, what I am looking for is to run a tiny image with just the necessary to\\ninstantiate an ARM cloud instance running Erlang/Elixir. That is what the next\\nblog post will do:\\n[meta-erlang on cloud II, build your own application](/blog/2023/02/04/index)\\n\\n## References\\n\\n- [1]:\\n  [Building an Automotive Embedded Linux Image for Edge and Cloud Using Arm-based Graviton Instances, Yocto Project, and SOAFEE](https://aws.amazon.com/blogs/industries/building-an-automotive-embedded-linux-image-for-edge-using-arm-graviton-yocto-project-soafee/)\\n- [2]:\\n  [Accelerating Software-Defined Vehicles through Cloud-To-Vehicle Edge Environmental Parity](https://armkeil.blob.core.windows.net/developer/Files/pdf/white-paper/arm-aws-edge-environmental-parity-wp.pdf)\\n- [3]:\\n  [Edge Workload Abstraction and Orchestration Layer (EWAOL) Documentation](https://ewaol.docs.arm.com/en/kirkstone-dev/index.html)"},{"id":"/2023/01/22/index","metadata":{"permalink":"/blog/2023/01/22/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-01-22/index.md","source":"@site/blog/2023-01-22/index.md","title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-01-22T00:00:00.000Z","formattedDate":"January 22, 2023","tags":[{"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.685,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf"}],"frontMatter":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","authors":["joaohf"],"tags":["meta-erlang","news"]},"prevItem":{"title":"meta-erlang on cloud I: EWAOL based","permalink":"/blog/2023/01/29/index"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version         |\\n| ------------------ | -------------------------- |\\n| dunfell            | 24.3.4.8                   |\\n| kirkstone          | 24.3.4.8, 25.1.2.1, 25.2.1 |\\n| langdale           | 24.3.4.8, 25.1.2.1, 25.2.1 |\\n\\nFixed bugs:\\n\\n- [QA Issue buildpaths (reproducible builds) when building with langdale](https://github.com/meta-erlang/meta-erlang/issues/205),\\n  a specific patch has been integrated in order to avoid building flags into the\\n  final beam.smp binary.\\n\\nTo be decided:\\n\\n- Yocto Langdale release has enabled reproducible build checks. Erlang/OTP from\\n  25 and later implements special flags to fix reproducible issues. But\\n  Erlang/OTP 24 does not have these special flags as a consequence langdale\\n  Erlang/OTP 24 builds warns about: _packages contains reference to TMPDIR\\n  [buildpaths]_. There are two paths that we could get. One is to drop\\n  Erlang/OTP 24 support OR disable QA buildpaths checking."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2022-12-30-welcome/index.md","source":"@site/blog/2022-12-30-welcome/index.md","title":"Welcome","description":"This new website is based on Docusaurus documentation","date":"2022-12-30T00:00:00.000Z","formattedDate":"December 30, 2022","tags":[{"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.33,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["joaohf"],"tags":["meta-erlang","news"]},"prevItem":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","permalink":"/blog/2023/01/22/index"}},"content":"This new website is based on [Docusaurus](https://docusaurus.io) documentation\\nframework. The previous site was using [docsify](https://docsify.js.org/#/),\\nwhich is also great. But Docusaurus address others concerns when writing\\ndocumentation for open source project.\\n\\nSo, the site has a new frontend page and a blog session where we want to add\\nlatest meta-erlang release highlights. The documentation session is pretty much\\nthe same plus some improvements on\\n[Introduction](https://meta-erlang.github.io/docs/) chapter."}]}')}}]);