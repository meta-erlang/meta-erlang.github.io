"use strict";(self.webpackChunkmeta_erlang_github_io=self.webpackChunkmeta_erlang_github_io||[]).push([[4927],{4065:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=t(4848),o=t(8453);const r={title:"Exploring x32 psABI for Erlang/OTP",authors:["joaohf"],tags:["meta-erlang","x32"]},s=void 0,l={permalink:"/blog/2023/09/02/index",editUrl:"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-09-02/index.md",source:"@site/blog/2023-09-02/index.md",title:"Exploring x32 psABI for Erlang/OTP",description:"Intro",date:"2023-09-02T00:00:00.000Z",tags:[{inline:!0,label:"meta-erlang",permalink:"/blog/tags/meta-erlang"},{inline:!0,label:"x32",permalink:"/blog/tags/x-32"}],readingTime:3.865,hasTruncateMarker:!1,authors:[{name:"Jo\xe3o Henrique Ferreira de Freitas",title:"Maintainer of meta-erlang",url:"https://github.com/joaohf",imageURL:"https://github.com/joaohf.png",key:"joaohf",page:null}],frontMatter:{title:"Exploring x32 psABI for Erlang/OTP",authors:["joaohf"],tags:["meta-erlang","x32"]},unlisted:!1,prevItem:{title:"meta-erlang meets atomvm",permalink:"/blog/2023/11/02/index"},nextItem:{title:"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2",permalink:"/blog/2023/07/01/index"}},a={authorsImageUrls:[void 0]},c=[{value:"Intro",id:"intro",level:2},{value:"Building Erlang/OTP using x32 toolchain",id:"building-erlangotp-using-x32-toolchain",level:2},{value:"Enabling Erlang for Yocto",id:"enabling-erlang-for-yocto",level:2}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"intro",children:"Intro"}),"\n",(0,i.jsxs)(n.p,{children:["According to ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/X32_ABI",children:"Wikipedia X32 ABI"})," page:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The x32 ABI is an application binary interface (ABI) and one of the interfaces\nof the Linux kernel. The x32 ABI provides 32-bit integers, long and pointers\n(ILP32) on Intel and AMD 64-bit hardware. The ABI allows programs to take\nadvantage of the benefits of x86-64 instruction set (larger number of CPU\nregisters, better floating-point performance, faster position-independent\ncode, shared libraries, function parameters passed via registers, faster\nsyscall instruction) while using 32-bit pointers and thus avoiding the\noverhead of 64-bit pointers."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"So, I'm wondering if it would be possible to enable x32 support in Erlang/OTP\nbuild. That way, I could make a Yocto image for x32 that runs on x86-64\nmachines."}),"\n",(0,i.jsx)(n.p,{children:"Here is some references about the subject:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.yoctoproject.org/dev-manual/x32-psabi.html",children:"Yocto, Using x32 psABI"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://sites.google.com/site/x32abi/home?authuser=0",children:"x32-abi"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://linuxplumbersconf.org/2011/ocw//system/presentations/531/original/x32-LPC-2011-0906.pptx",children:"X32 \u2013 A Native 32bit ABI For X86-64"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://wiki.debian.org/X32Port",children:"Debian x32 port"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf",children:"System V Application Binary Interface AMD64 Architecture Processor Supplement (With LP64 and ILP32 Programming Models"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In fact, x32 seems to be around since 2011/2012 and has been integrated in many\nplatforms. Like Ubuntu, Debian, Gentoo."}),"\n",(0,i.jsx)(n.h2,{id:"building-erlangotp-using-x32-toolchain",children:"Building Erlang/OTP using x32 toolchain"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["A toolchain with x32 support is necessary. However, it's not easy to find one.\nInstead projects like ",(0,i.jsx)(n.a,{href:"https://crosstool-ng.github.io/",children:"crosstool-NG"})," and\n",(0,i.jsx)(n.a,{href:"https://www.yoctoproject.org/",children:"Yocto Project"})," have tools to make a toolchain\nwith x32 support enabled."]})}),"\n",(0,i.jsxs)(n.p,{children:["In order to follow this experiment, you can download a specific toolchain with\nx32 enabled here:\n",(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-erlang.github.io/releases/tag/x32-toolchain",children:"poky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It will be necessary to install it in a temporary folder like the steps below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"chmod +x poky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh\npoky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh -y -d /tmp/poky/4.2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Following the Erlang/OTP\n",(0,i.jsx)(n.a,{href:"https://github.com/erlang/otp/blob/master/HOWTO/INSTALL-CROSS.md",children:"INSTALL-CROSS.md"}),"\ndocument, we first need to build a Bootstrap System:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"cd $ERL_TOP\n./configure --enable-bootstrap-only\nmake\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next, we have to source the toolchain environment configurations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:". /tmp/poky/4.2/environment-setup-x86_64_x32-poky-linux-gnux32\n"})}),"\n",(0,i.jsx)(n.p,{children:"After sourcering the environment variable, the shell gets configured with some\nextra variables using during the build:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"x86_64-poky-linux-gnux32-gcc -mx32 \\\n -fstack-protector-strong \\\n -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security \\\n --sysroot=/tmp/poky/4.2/sysroots/x86_64_x32-poky-linux-gnux32\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It's important to not the GCC flag\n",(0,i.jsx)(n.a,{href:"https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#index-mx32",children:"-mx32"}),":"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The -mx32 option sets int, long, and pointer types to 32 bits, and generates\ncode for the x86-64 architecture."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Finally, start the second part of Erlang/OTP build, which is the Cross Build:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"./configure  $CONFIGURE_FLAGS  --disable-silent-rules --disable-dependency-tracking \\\n\t--with-ssl-rpath=no --disable-static  --without-javac --without-dynamic-trace --without-observer --without-odbc\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Installing the build output and inspecting the ",(0,i.jsx)(n.code,{children:"erlexec"})," binary to see what it\nlooks like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"make install DESTDIR=/tmp/e\n\nfile /tmp/e/usr/local/lib/erlang/erts-14.0.2/bin/erlexec\nerlexec: ELF 32-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /libx32/ld-linux-x32.so.2, BuildID[sha1]=013e32ef8c57686a59a812ca452f09d677ff8e37, for GNU/Linux 5.15.0, with debug_info, not stripped\n"})}),"\n",(0,i.jsx)(n.p,{children:"Well, the build is correct. But I couldn't test this build in my machine."}),"\n",(0,i.jsx)(n.h2,{id:"enabling-erlang-for-yocto",children:"Enabling Erlang for Yocto"}),"\n",(0,i.jsx)(n.p,{children:"In the previous section we just build Erlang/OTP using a toolchain with x32\nsupport. Now, it's time to build Erlang/OTP inside the Yocto project and test\nthe results using qemu instance."}),"\n",(0,i.jsx)(n.p,{children:"Enabling it for Yocto is simple, just adding the follow snippet in your\nlocal.conf file:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"MACHINE = \"qemux86-64\"\nDEFAULTTUNE = \"x86-64-x32\"\nbaselib = \"${@d.getVar('BASE_LIB:tune-' + (d.getVar('DEFAULTTUNE') or 'INVALID')) or 'lib'}\"\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then, building erlang:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"bitbake erlang\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.p,{children:"For those that want to check all configure and compiler flags, I'm including the\nlinks to those logs:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"pathname:///assets/log.do_configure",children:"Configure log output"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"pathname:///assets/log.do_compile",children:"Compile log output"})}),"\n"]})]}),"\n",(0,i.jsxs)(n.p,{children:["The build failed in one point related to ASM code in\n",(0,i.jsx)(n.a,{href:"https://github.com/erlang/otp/blob/maint-26/erts/lib_src/pthread/ethread.c#L193",children:"erts/lib_src/pthread/ethread.c"}),".\nLooks like an ASM incompatibility issue. In order to address it here is\n",(0,i.jsx)(n.a,{href:"https://github.com/joaohf/otp/commit/6cd15d5888a536af97f5d8e26b2db2e379fa7eab",children:"a patch"}),"\nthat just adds one more compiler check to pick up the correct ifdef branch."]}),"\n",(0,i.jsx)(n.p,{children:"Afer that, the build runs as expected. And testing it using QEMU shows exactly\nwhat I had in mind:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"runqemu core-image-minimal-qemux86-64.ext4 slirp nographic serialstdio\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"check the current kernel"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@qemux86-64:~# uname -a\nLinux qemux86-64 6.1.32-yocto-standard #1 SMP PREEMPT_DYNAMIC Mon Jun  5 13:43:33 UTC 2023 x86_64 GNU/Linux\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"check /proc/cpuinfo to see the 'lm' (long mode)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@qemux86-64:~# grep -o -w 'lm' /proc/cpuinfo\nlm\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"check Erlang shell"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Erlang/OTP 26 [erts-14.0.2] [source] [32-bit] [smp:4:4] [ds:4:4:10] [async-threads:1]\n\nEshell V14.0.2 (press Ctrl+G to abort, type help(). for help)\n1> application:ensure_all_started(crypto).\n{ok,[crypto]}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Well, looks like we are running Erlang/OTP 32-bits in a x86_64 machine. Also, it\nwas able to correct load the crypto (with ssl libraries compiled for x32 too).\nBy the way, there is a second\n",(0,i.jsx)(n.a,{href:"https://github.com/joaohf/otp/commit/e63b5b703ffa0005bf6a8f4d3bcec18f786bda92",children:"patch need to proper compile the crypto application"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Some raised questions for further investigations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What tests are necessary to prove that the x32 Erlang build is safe ?"}),"\n",(0,i.jsx)(n.li,{children:"Are there any other code change in order to fit the x32 build ?"}),"\n",(0,i.jsxs)(n.li,{children:["Would ",(0,i.jsx)(n.a,{href:"https://www.erlang.org/doc/apps/erts/beamasm#faq",children:"BeamAsm"})," be available\nfor x32 ?"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);