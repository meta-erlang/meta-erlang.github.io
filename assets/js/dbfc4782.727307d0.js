"use strict";(self.webpackChunkmeta_erlang_github_io=self.webpackChunkmeta_erlang_github_io||[]).push([[8749],{91895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2026/01/02/index","metadata":{"permalink":"/blog/2026/01/02/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2026-01-02/index.md","source":"@site/blog/2026-01-02/index.md","title":"meta-erlang Yocto Project Compatible v3 Layers Accepted","description":"This post is to inform that meta-erlang has been accepted as Yocto Project","date":"2026-01-02T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"}],"readingTime":1.49,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang Yocto Project Compatible v3 Layers Accepted","authors":["joaohf"],"tags":["meta-erlang"]},"unlisted":false,"nextItem":{"title":"Testing meta-erlang with LuX","permalink":"/blog/2025/09/26/index"}},"content":"This post is to inform that meta-erlang has been accepted as Yocto Project\\nCompatible v3 Layer.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe\\n[Yocto Project Compatible Layers](https://www.yoctoproject.org/development/yocto-project-compatible-layers/)\\nis a program to evaluate and list all layers that follows\\n[The Yocto Project Layer Model](https://docs.yoctoproject.org/current/overview-manual/yp-intro.html#the-yocto-project-layer-model).\\n\\nOn last December/2025, I received an email from Yocto Project managers saying as\\nfollows:\\n\\n```\\nDear Yocto Layer Maintainer,\\n\\nCongratulations! Your layer has been successfully reviewed and is now recognized as Yocto Project Compatible v3.\\n\\nAs part of this recognition, you are granted the right to display the Yocto Project Compatible badge in association with your layer and related materials.\\nWhat\u2019s Included in This Email:\\n\\n    \u2705 Your Rights: You may now publicly use the \u201cYocto Project Compatible\u201d badge to promote your layer.\\n\\n    \ud83d\udd17 Links to Entry: Your layer listing can be found on the Yocto Project Layer Index: https://layers.openembedded.org/layerindex/branch/master/layers/\\n\\n    \ud83e\uddea Layer Compatibility Check: Your layer has passed compatibility validation with the current Yocto Project release v3.\\n\\n    \ud83d\udcce Attached:\\n\\n        The official Yocto Project Compatible badge\\n\\n        Branding Guidelines to help you use the badge properly\\n```\\n\\nIn fact, I have applied meta-erlang through\\n[Yocto Project Compatible Layer Registration](https://www.yoctoproject.org/compatible-registration/).\\nAnd there was the final result.\\n\\n## What does it mean ?\\n\\nThe rights to officially promote meta-erlang as \u201cYocto Project Compatible\u201d and\\npublicly use a badge which informs the end user that meta-erlang has passed to\\nall\\n[compatibility checks](https://docs.yoctoproject.org/current/dev-manual/layers.html#making-sure-your-layer-is-compatible-with-yocto-project).\\nThis is the real value of the compatible layer program.\\n\\n![alt Yocto Project Compatible badge](YoctoCompatibleBadge.png \'Yocto Project Compatible badge\')\\n\\nAlso, meta-erlang is listed as compatible with a small badge on the Yocto\\nProject Layer Index:\\nhttps://layers.openembedded.org/layerindex/branch/master/layers/\\n\\nIn practical terms, I also\\n[added a new lux test](https://github.com/meta-erlang/kas-meta-erlang/blob/main/lux/test/yocto_layer_compatible_check.lux)\\nwhich executes the yocto-check-layer check script in order to verify if\\nmeta-erlang is compatible and keeps compatible,\\n[Making Sure Your Layer is Compatible With Yocto Project](https://docs.yoctoproject.org/current/dev-manual/layers.html#making-sure-your-layer-is-compatible-with-yocto-project)."},{"id":"/2025/09/26/index","metadata":{"permalink":"/blog/2025/09/26/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-09-26/index.md","source":"@site/blog/2025-09-26/index.md","title":"Testing meta-erlang with LuX","description":"In this post we will get a overview about how testimage feature has been enabled","date":"2025-09-26T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"test","permalink":"/blog/tags/test"}],"readingTime":5.315,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Testing meta-erlang with LuX","authors":["joaohf"],"tags":["meta-erlang","test"]},"unlisted":false,"prevItem":{"title":"meta-erlang Yocto Project Compatible v3 Layers Accepted","permalink":"/blog/2026/01/02/index"},"nextItem":{"title":"beamruntime","permalink":"/blog/2025/09/25/index"}},"content":"In this post we will get a overview about how testimage feature has been enabled\\ninto recipe images examples in order to implement tests.\\n\\nAs meta-erlang layer provides many\\n[recipes for Erlang and Elixir application](https://layers.openembedded.org/layerindex/branch/master/layer/meta-erlang/),\\ntesting and verifying if each supported application is still working between\\nYocto releases is very important.\\n\\nSo, this post is mostly about Yocto oeqa framework and\\n[lux tool](https://github.com/hawk/lux).\\n\\n\x3c!-- truncate --\x3e\\n\\n## Yocto oeqa framework\\n\\nThe Yocto Project provides a framework called\\n[oeqa](https://git.yoctoproject.org/poky/tree/meta/lib/oeqa) and integrated with\\nYocto ecosystem for testing. It is able to test many aspects like: image test,\\nSDK, build performance, bitbake. All those tests are implemented with python\\nunittest.\\n\\nThe documentation section called\\n[Yocto Project Test Environment Manual](https://docs.yoctoproject.org/test-manual/index.html)\\nexplains how everything works.\\n\\nFor the meta-erlang context, we are interesting in two types of tests:\\n\\n- [testimage](https://docs.yoctoproject.org/test-manual/intro.html#testimage),\\n  these tests run once an image is up and running. Let\'s suppose an image with\\n  riak installed is up and running, we want to check if riak is online, restart,\\n  start again and run health checks\\n- [ptest](https://docs.yoctoproject.org/test-manual/ptest.html#testing-packages-with-ptest),\\n  package level test; it is not the focus today\\n\\nFor a full oeqa view, the source code is\\n[here](https://github.com/meta-erlang/meta-erlang/tree/master/lib/oeqa/runtime).\\n\\noeqa framework has all the elements needed in order to write unit tests. But, I\\nwas not willing to write unit tests in python way. Instead, I was looking into a\\ndifferent way for _test image_ type of tests.\\n\\n## Lux, LUcid eXpect scripting\\n\\nLux is an amazing application written in Erlang/OTP. It\'s aim is for test\\nautomation. Its github [hawk/lux](https://github.com/hawk/lux) is full of\\nexamples and\\n[lux documentation](https://github.com/hawk/lux/blob/master/doc/lux.md) is also\\ngreat. From its github\'s page:\\n\\n```\\nWith Lux it is possible to\\n\\n    simplify automated testing\\n    control interactive programs by sending textual input to them and using [regular expression][]s to ensure that their output matches the expectations\\n    perform detailed post mortem analyzis of test suite results\\n```\\n\\nThere is a talk about Lux presented at the Erlang User Conference 2019:\\n[Cons T Ahs and Hakan Mattsson - LUX - an expect like test tool | Code BEAM STO 19](https://www.youtube.com/watch?v=Nu15YOpmCKQ)\\nand it explains all internal details that make lux an excellent tool for writing\\nautomated tests.\\n\\nLet\'s see a simple lux script example where I want to verify if riak service is\\nok. The test case is named\\n[start_restart_stop.lux](https://github.com/meta-erlang/meta-erlang/blob/master/lib/oeqa/runtime/files/lux/riak/start_restart_stop.lux):\\n\\n```\\n[doc Test if riak is able to start, restart and stop]\\n\\n[include ../support/luxinc/utils.luxinc]\\n\\n# riak is not so fast when starting\\n[config timeout=30000]\\n\\n[shell cmd]\\n\\n    # Right after a boot, riak needs some time\\n    # mainly because clutterfish processing\\n    [sleep 30]\\n\\n    [doc2 Stop riak]\\n    !systemctl stop riak\\n    [invoke ok]\\n\\n    [doc2 Start riak]\\n    !systemctl start riak\\n    [invoke ok]\\n\\n    [doc2 Check if riak is up and running]\\n    !SYSTEMD_COLORS=0 systemctl status --line=0 --no-pager riak\\n    ?.*Active: active \\\\(running\\\\).*\\n    [invoke check-exitcode 0]\\n\\n    # After a start, give some time to riak.\\n    [sleep 30]\\n\\n    [doc2 Ping riak]\\n    !/usr/lib/riak/bin/riak ping\\n    ?pong\\n    [invoke check-exitcode 0]\\n\\n    [doc2 Stop riak]\\n    !systemctl stop riak\\n    [invoke ok]\\n\\n    [doc2 Check if riak has been stop without any issue]\\n    !SYSTEMD_COLORS=0 systemctl status --line=0 --no-pager riak\\n    ?.*Active: inactive \\\\(dead\\\\).*\\n    [invoke check-exitcode 3]\\n\\n[cleanup]\\n    !systemctl stop riak\\n    [invoke ok]\\n```\\n\\nThe above test starts a shell, named \'cmd\'. And tries to:\\n\\n- stop\\n- start\\n- check riak service status\\n- ping riak\\n- stop\\n- check if riak was stopped\\n\\nThe key point to understand lux scripts is that whatever you do as a human, lux\\nwill also do in order to test the above commands; lux script will work in the\\nsame way but faster.\\n\\nFor instance, to check if systemd was able to start riak one could check the\\nresult of the command `systemctl start riak` and after that the output of\\n`systemctl status riak` in order to conclude or not if riak has been started\\nproperly.\\n\\nThere are some lux scripts implemented for each application that meta-erlang has\\na recipe\\n[lib/oeqa/runtime/files/lux](https://github.com/meta-erlang/meta-erlang/tree/master/lib/oeqa/runtime/files/lux).\\n\\n## Mixing lux and oeqa into meta-erlang for testing image\\n\\n### Preparing testable images\\n\\nYocto documentation says that when testimage feature is enabled, the TEST_SUITES\\nimage variable is used to setup and run image tests.\\n\\nThe following recipe called\\n[riak-image.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-examples/images/riak-image.bb)\\nadds riak into TEST_SUITES variable only for qemu MACHINES:\\n\\n```\\nSUMMARY = \\"A console-only image with more full-featured Linux system \\\\\\nfunctionality installed with OpenRiak installed.\\"\\n\\nLICENSE = \\"MIT\\"\\n\\ninclude common.inc\\ninclude testimage-common.inc\\n\\nAPPLICATION = \\"riak\\"\\nAPPLICATION += \\"${@bb.utils.contains(\'IMAGE_CLASSES\', \'testimage\', \'curl\', \'\', d)}\\"\\n\\ninherit core-image\\n\\nTEST_SUITES:qemuall += \\"riak\\"\\n\\nQB_MEM ?= \\"-m 1024\\"\\nIMAGE_ROOTFS_EXTRA_SPACE = \\"256000\\"\\n```\\n\\nThe testimage-common.inc will install lux package when IMAGE_CLASSES variable\\ncontains testimage feature.\\n\\nSo, we need to have an image that declares what are the test suites that will be\\nexecutable and the image is up and running. It\'s important to mention that these\\ntests will be executable inside a QEMU instance.\\n\\n### Adding support for running lux scripts\\n\\nNow, it\'s time to get an idea about how to implement an oeqa test which will\\ncall a lux script.\\n\\nAs a test case example, let\'s dissect a test\\n[case for riak](https://github.com/meta-erlang/meta-erlang/blob/master/lib/oeqa/runtime/cases/riak.py):\\n\\n```python\\nfrom oeqa.core.decorator.depends import OETestDepends\\nfrom oeqa.core.decorator.oetimeout import OETimeout\\nfrom oeqa.runtime.decorator.package import OEHasPackage\\nfrom oeqa.runtime.decorator.lux import LuxTestCase\\nfrom oeqa.runtime.meta_erlang import MetaErlangTestCase\\n\\nclass RiakTest(MetaErlangTestCase):\\n\\n    @OETimeout(300)\\n    @OEHasPackage([\\"lux\\"])\\n    @OETestDepends([\'ssh.SSHTest.test_ssh\'])\\n    @LuxTestCase(\\"start_restart_stop.lux\\", \\"riak\\")\\n    def test_start_restart_stop(self):\\n        self.run_lux_test_case()\\n```\\n\\nThe test case is written in python and uses some decorators available in oeqa\\nframework and some\\n[extra one to support lux](https://github.com/meta-erlang/meta-erlang/blob/master/lib/oeqa/runtime/decorator/lux.py).\\nThe purpose of these decorators is mainly to check conditions and configure lux\\nscripts like what is the name of lux script which (e.g.:\\n_start_restart_stop.lux_) implements the test and what folder it is located\\n(e.g.: _riak_).\\n\\nThe\\n[MetaErlangTestCase](https://github.com/meta-erlang/meta-erlang/blob/master/lib/oeqa/runtime/meta_erlang.py)\\nclass implements the function _run_lux_test_case_ and it is responsible for:\\n\\n- copy test case to DUT (Device Under Test)\\n- copy lux support configuration files and macros\\n- execute lux test cases\\n- check the results\\n- copy logs from DUT into host\\n\\nThe python test case above is needed as a bridge to call lux inside DUT. As the\\nmain purpose is to use lux running on target for testing.\\n\\n## Conclusion\\n\\nThis sort of integration is like eating your own dog food. That means, using\\ncomponents from Yocto Project and meta-erlang for testing all the work.\\n\\noeqa is pretty solid and each Yocto release there are more and more tests\\ncovering many areas of the ecosystem. I think lux is the right tool to provide\\ntest cases without the needed to implement python code as with lux we can write\\nexactly how one does test."},{"id":"/2025/09/25/index","metadata":{"permalink":"/blog/2025/09/25/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-09-25/index.md","source":"@site/blog/2025-09-25/index.md","title":"beamruntime","description":"One of the coolest features from the Yocto Project is the ability of creating","date":"2025-09-25T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"beamruntime","permalink":"/blog/tags/beamruntime"}],"readingTime":5.915,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"beamruntime","authors":["joaohf"],"tags":["meta-erlang","beamruntime"]},"unlisted":false,"prevItem":{"title":"Testing meta-erlang with LuX","permalink":"/blog/2025/09/26/index"},"nextItem":{"title":"Erlang-Red, recipe introduction","permalink":"/blog/2025/07/27/index"}},"content":"One of the coolest features from the Yocto Project is the ability of creating\\ntoolchains and SDK for specific needs. There is a full session on Yocto\'s\\ndocumentation about\\n[Software Development Kits](https://docs.yoctoproject.org/sdk-manual/index.html).\\nAlso, many talks showing that feature in action, e.g.:\\n[Building Bare Metal Toolchains, Crosstool-ng and Yocto Project - Mark Hatle, Xilinx](https://www.youtube.com/watch?v=b0yXASkIIv8&t=2496s).\\n\\nWhile reading this discussion:\\n[It is possible that this project may expand to also provide Linux builds?](https://github.com/erlef/otp_builds/issues/39#issuecomment-3265877959),\\nI thought it would be interesting as a PoC to create a sort of _beamruntime_\\nYocto based toolchain with only Erlang/OTP and Elixir installed plus base\\nlibraries like libc, termcap, openssl. Nothing more. As meta-erlang layer has\\nall the components and infrastructure for that. See beamtools idea.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe target audience is for Linux boxes that does not have Erlang/OTP installed,\\nthen the user would install beamruntime and get access to a fresh and up to date\\nErlang/OTP and Elixir environment. As the SDK generated by Yocto is\\nself-content, there is no need to install anything else into Operational System.\\n\\nMoreover, beamruntime is linux distribution independent, it could run in any\\ndistribution for the target architecture.\\n\\nIn fact, this idea is not new in meta-erlang land, _beamtools_ uses exact the\\nsame approach. The difference is beamtools has development tools for building\\nErlang/OTP and Elixir application (like headers, rebar3, etc). While beamruntime\\nis just for running application, that is BEAM VM and modules.\\n\\nOne advantage of using Yocto for making SDKs is that Yocto is also a platform\\nwhere each component and version are well tested and all components for a Yocto\\nrelease is enough stable and are up to date versions. So, there is no need to\\nworry too much about what goes inside the SDK. If this is too important, it\'s\\npossible to provide a Software Bill of Materials for beamruntime.\\n\\nHowever, the key point is that it allows you to take control of the full process\\nand not only consume binaries from Internet. Of course it depends on each use\\ncase. But it\'s important to notice that building your own SDK is also feasible.\\n\\nI made all my tests using Yocto master branch which is for development only.\\nI\'ll update this post following the next Yocto release, by end of October. Then,\\nI\'ll also provide a stable beamruntime tools for testing.\\n\\n## beamruntime recipe\\n\\nI\'ve started with two architecture targets in mind: x86-64 and aarch64. And a\\nnew bitbake recipe called\\n[beamruntime-tarball](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-core/meta/beamruntime-tarball.bb).\\n\\nAfter building it using `bitbake beamruntime-tarball` a sdk was made and\\navailable at _tmp/deploy/sdk_ ready for use.\\n\\nI borrowed some ideas from the\\n[OE-core recipe from here](https://git.yoctoproject.org/poky/tree/meta/recipes-core/meta/buildtools-tarball.bb).\\nBecause the purpose is very similar.\\n\\n## Practical usage\\n\\nInstalling beamruntime is like running a selfextract shell script which install\\nbeamruntime in the target folder (-d option):\\n\\n```\\n$ x86_64-beamruntime-nativesdk-standalone-5.2.99+snapshot-musl-erlang-28.0.4-elixir-1.18.4.sh -d /tmp/test0\\nBEAM runtime installer version 5.2.99+snapshot-erlang-28.0.4-elixir-1.18.4\\n==========================================================================\\nYou are about to install the SDK to \\"/tmp/test0\\". Proceed [Y/n]?\\nExtracting SDK......done\\nSetting it up...done\\nSDK has been successfully set up and is ready to be used.\\nEach time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.\\n $ . /tmp/test0/environment-setup-x86_64-pokysdk-linux\\n```\\n\\nAfter the installation, and for each shell, it\'s necessary to source a script\\nthat will fix some environment variables:\\n\\n```\\n$ source /tmp/test0/environment-setup-x86_64-pokysdk-linux\\n\\n$ erl\\n\\nErlang/OTP 28 [erts-16.0.3] [source] [64-bit] [smp:12:12] [ds:12:12:10] [async-threads:1] [jit:ns]\\n\\nEshell V16.0.3 (press Ctrl+G to abort, type help(). for help)\\n1> application:start(crypto).\\nok\\n2>\\n```\\n\\nErlang shell is working as expected. Let\'s take a look in the image process\\nmapping to check from where the beam PID is getting libraries:\\n\\n```\\n$ cat /proc/142729/maps\\n60245d000000-60245d018000 rw-p 00a00000 fc:00 26099460                   /tmp/test0/sysroots/x86_64-pokysdk-linux/usr/lib/erlang/erts-16.0.3/bin/beam.smp\\n...\\n785f53fee000-785f53ff3000 rw-p 001de000 fc:00 26099940                   /tmp/test0/sysroots/x86_64-pokysdk-linux/lib/libc.so.6\\n...\\n785f54272000-785f54275000 rw-p 00271000 fc:00 20982895                   /tmp/test0/sysroots/x86_64-pokysdk-linux/usr/lib/libstdc++.so.6.0.34\\n...\\n785f542cf000-785f542d0000 rw-p 0002b000 fc:00 26099910                   /tmp/test0/sysroots/x86_64-pokysdk-linux/lib/libgcc_s.so.1\\n...\\n785f543c1000-785f543c2000 rw-p 000f0000 fc:00 26099961                   /tmp/test0/sysroots/x86_64-pokysdk-linux/lib/libm.so.6\\n...\\n785f543dc000-785f543dd000 rw-p 00019000 fc:00 20982885                   /tmp/test0/sysroots/x86_64-pokysdk-linux/usr/lib/libz.so.1.3.1\\n...\\n785f5440f000-785f54410000 rw-p 00031000 fc:00 26099959                   /tmp/test0/sysroots/x86_64-pokysdk-linux/lib/libtinfo.so.5.9\\n...\\n785f54451000-785f54452000 rw-p 00039000 fc:00 26099952                   /tmp/test0/sysroots/x86_64-pokysdk-linux/lib/ld-linux-x86-64.so.2\\n```\\n\\nAs expected every dependency is self-content from `/tmp/test0`. Even the openssl\\nlibs:\\n\\nGet some crypto info:\\n\\n```\\n2> crypto:info().\\n#{otp_crypto_version => \\"5.6\\",compile_type => normal,\\n  link_type => dynamic,\\n  cryptolib_version_compiled => \\"OpenSSL 3.5.2 5 Aug 2025\\",\\n  cryptolib_version_linked => \\"OpenSSL 3.5.2 5 Aug 2025\\",\\n  fips_provider_available => false}\\n3> crypto:info_lib().\\n[{<<\\"OpenSSL\\">>,810549280,<<\\"OpenSSL 3.5.2 5 Aug 2025\\">>}]\\n```\\n\\nMy Ubuntu (24.04) host has OpenSSL 3.0.13, not _3.5.2_. That is a good sign for\\nself-content approach.\\n\\nSo, beamruntime could be used as a generic Erlang/OTP and Elixir installation\\nfor Linux boxes.\\n\\n## More details\\n\\nThe file\\n_x86_64-beamruntime-nativesdk-standalone-5.2.99+snapshot-musl-erlang-28.0.4-elixir-1.18.4.sh_\\nhas 36291 KB and when installed it goes up to 78476 KB. The user can install it\\nin any folder.\\n\\n:::note\\n\\nThe size footprint is relative, as in this experience I was targeting a generic\\ninstallation. So, right now, it\'s not part of the scope the following Erlang/OTP\\nfeatures: odbc, sctp support, wx.\\n\\n:::\\n\\nbeamruntime provides the following packages:\\n\\n- libc (musl)\\n- terminfo\\n- zlib\\n- openssl\\n- Erlang/OTP\\n- Elixir\\n\\nA more detailed list with package size and theirs names:\\n\\n```\\n11825\\tKiB\\tnativesdk-erlang-erts\\n7018\\tKiB\\tnativesdk-elixir\\n6418\\tKiB\\tnativesdk-erlang-stdlib\\n5894\\tKiB\\tnativesdk-libcrypto3\\n4428\\tKiB\\tnativesdk-libc6\\n3248\\tKiB\\tnativesdk-erlang-compiler\\n3163\\tKiB\\tnativesdk-erlang-snmp\\n2890\\tKiB\\tnativesdk-glibc-binary-localedata-en-us.utf-8\\n2868\\tKiB\\tnativesdk-erlang-kernel\\n2681\\tKiB\\tnativesdk-erlang-public-key\\n2511\\tKiB\\tnativesdk-libstdc++6\\n2254\\tKiB\\tnativesdk-erlang-ssl\\n1971\\tKiB\\tnativesdk-erlang-xmerl\\n1893\\tKiB\\tnativesdk-erlang-common-test\\n1459\\tKiB\\tnativesdk-erlang-dialyzer\\n1267\\tKiB\\tnativesdk-erlang-ssh\\n1246\\tKiB\\tnativesdk-erlang-asn1\\n1158\\tKiB\\tnativesdk-erlang-mnesia\\n1137\\tKiB\\tnativesdk-erlang-diameter\\n848\\tKiB\\tnativesdk-erlang-inets\\n699\\tKiB\\tnativesdk-erlang-tools\\n594\\tKiB\\tnativesdk-erlang-edoc\\n472\\tKiB\\tnativesdk-erlang-emacs\\n467\\tKiB\\tnativesdk-erlang-reltool\\n449\\tKiB\\tnativesdk-erlang-syntax-tools\\n401\\tKiB\\tnativesdk-erlang-sasl\\n348\\tKiB\\tnativesdk-erlang-crypto\\n328\\tKiB\\tnativesdk-erlang-runtime-tools\\n261\\tKiB\\tnativesdk-erlang-parsetools\\n220\\tKiB\\tnativesdk-erlang-eunit\\n200\\tKiB\\tnativesdk-libtinfo5\\n177\\tKiB\\tnativesdk-erlang-eldap\\n175\\tKiB\\tnativesdk-libgcc1\\n159\\tKiB\\tnativesdk-erlang-os-mon\\n139\\tKiB\\tnativesdk-openssl-ossl-module-legacy\\n124\\tKiB\\tnativesdk-erlang-erl-interface\\n123\\tKiB\\tnativesdk-erlang-tftp\\n115\\tKiB\\tnativesdk-erlang-ftp\\n102\\tKiB\\tnativesdk-libz1\\n85\\tKiB\\tnativesdk-erlang-typer\\n66\\tKiB\\tnativesdk-erlang-epmd\\n26\\tKiB\\tnativesdk-ncurses-terminfo-base\\n24\\tKiB\\tnativesdk-openssl-conf\\n0\\tKiB\\tnativesdk-sdk-provides-dummy\\n0\\tKiB\\tnativesdk-erlang-modules\\n0\\tKiB\\tnativesdk-erlang-erl-docgen\\n0\\tKiB\\tnativesdk-erlang\\n```\\n\\nOn this Erlang/OTP installation, I did not enabled wx (wxwidget), odbc, lkscp\\noptions. And all Erlang/OTP modules have been installed. It\'s a pretty generic\\ninstallation, though.\\n\\nSome additional Yocto configuration for reducing size were applied. Like the\\nfollowing:\\n\\n- Disable locales:\\n\\n  ```\\n  ENABLE_BINARY_LOCALE_GENERATION       = \\"1\\"\\n  LOCALE_GENERATION_WITH_CROSS_LOCALEDEF = \\"1\\"\\n  GLIBC_INTERNAL_USE_BINARY_LOCALE     = \\"compile\\"\\n\\n  GLIBC_GENERATE_LOCALES                = \\"en_US.UTF-8\\"\\n  IMAGE_LINGUAS                         = \\"en-us\\"\\n\\n  LOCALE_UTF8_ONLY      = \\"1\\"\\n  LOCALE_UTF8_IS_DEFAULT = \\"1\\"\\n  ```\\n\\n- Use musl:\\n\\n  ```\\n  TCLIBC = \\"musl\\"\\n  ```\\n\\n- Disable opengl support:\\n\\n  ```\\n  DISTRO_FEATURES_FILTER_NATIVESDK:remove = \\"opengl\\"\\n  ```\\n\\n- Optional: disable termcap (reducing ~300KB)\\n\\n  ```\\n  PACKAGECONFIG:remove:pn-nativesdk-erlang = \\"termcap\\"\\n  ```\\n\\n## Next steps and ideas\\n\\n- Provide musl and glibc beamruntime packages for testing. Both versions of\\n  beamruntime work as expected.\\n- Enable static build, what would be the final footprint ?\\n- Make beamruntime a bit more generic like adding odbc, lksctp ?\\n- Or make it less generic removing some erlang application that does not make\\n  sense for runtime. Like: dialyzer, edoc, emacs, typer\\n- What does mean generic nowadays ? Providing a generic beamruntime is feasible\\n  and if a specific user wants to add or remove components it could be easily\\n  done building a beamruntime itself.\\n- How beamruntime could be useful for tools that expect a Erlang/OTP\\n  installation on the target host ?"},{"id":"/2025/07/27/index","metadata":{"permalink":"/blog/2025/07/27/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-07-27/index.md","source":"@site/blog/2025-07-27/index.md","title":"Erlang-Red, recipe introduction","description":"Erlang-Red is an experimental Erlang","date":"2025-07-27T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"erlang-red","permalink":"/blog/tags/erlang-red"}],"readingTime":5.55,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Erlang-Red, recipe introduction","authors":["joaohf"],"tags":["meta-erlang","erlang-red"]},"unlisted":false,"prevItem":{"title":"beamruntime","permalink":"/blog/2025/09/25/index"},"nextItem":{"title":"autotools as build tool for Erlang/OTP projects","permalink":"/blog/2025/05/11/index"}},"content":"[Erlang-Red](https://github.com/gorenje/erlang-red) is an experimental Erlang\\nbackend to replace [Node-RED](https://nodered.org/). This blog post introduces\\nthe erlang-red recipe available in meta-erlang layer.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe purpose here is to get a virtual environment with Erlang-Red installed where\\nit is possible to start creating basic flow and explore possibilities using\\nYocto and Erlang-Red.\\n\\n## Erlang-Red\\n\\nAccording to [Erlang-Red](https://github.com/gorenje/erlang-red), it is:\\n\\n> Experimental Erlang backend to replace Node-REDs existing NodeJS backend,\\n> aiming for 100% compatible with existing flow code.\\n>\\n> The goal is bring the advantages of low-code visual flow-based programming to\\n> a programming language that is designed for message passing and concurrency\\n> from the ground up, hence Erlang. More details described in the corresponding\\n> blog post.\\n\\nA few months ago I was reading [Erlang Forums](https://erlangforums.com) when I\\nsaw a thread about\\n[Erlang-RED - Erlang interpreter for Node-RED flow code (visual flow based programming)](https://erlangforums.com/t/erlang-red-erlang-interpreter-for-node-red-flow-code-visual-flow-based-programming/4678).\\nIt looked so fantastic that someone was trying to implement a new backend for\\nNode-RED, moreover it is written in Erlang/OTP.\\n\\nIn order to get a better view of Erlang-Red philosophy and internals I recommend\\nreading this blog post:\\n[The Erlang-Red Project](https://blog.openmindmap.org/erlang-red).\\n\\nI thought that writing an\\n[Erlang-Red Yocto recipe](https://layers.openembedded.org/layerindex/recipe/464852/)\\ncould be useful for anyone interested in applying flow based programming in the\\ncontext of linux embedded projects.\\n\\n## The Erlang-Red recipe\\n\\nAs everything else in OpenEmbedded / Yocto land, it is necessary a recipe in\\norder to get any software installed in the final image built with Yocto. Some\\nrecipes are easy, while others are more complicated. As Erlang-Red uses rebar3\\nas build tool, it was easy to build, release and package it using\\n[rebar3.bbclass](https://github.com/meta-erlang/meta-erlang/blob/master/classes/rebar3.bbclass).\\n\\nA full working\\n[erlang-red bitbake recipe](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-extended/erlang-red/erlang-red_git.bb)\\nis now available on meta-erlang layer. And in the rest of this blog post I will\\nguide you to get a basic image working.\\n\\nI have added erlang-red recipe to meta-erlang master branch. I did not test it\\nusing others Yocto branches. But the recipe will work in other branches with\\nsmall fixes.\\n\\n## Setup bitbake and Yocto\\n\\n:::note\\n\\nThis is the point where reading the\\n[Yocto Project Quick Build](https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html)\\ndocumentation can help to understand basic principles. In this section I\\nextracted the commands that I used to run this use case.\\n\\n:::\\n\\n### Fetching source code\\n\\nCloning all repositories for master branch:\\n\\n```bash\\ngit clone --branch master git://git.yoctoproject.org/poky\\ngit clone --branch master https://github.com/meta-erlang/meta-erlang\\n```\\n\\n### Sourcing build environment\\n\\nSource the init build environment script:\\n\\n```bash\\ncd poky\\nsource oe-init-build-env ../build\\n```\\n\\n### Adding meta-erlang layer\\n\\nAdd the needed layers:\\n\\n```bash\\nbitbake-layers add-layer ../meta-erlang\\n```\\n\\n### Configuring the build environment\\n\\nFor this use case, the quickest way is to edit and add some snippets in the\\nconfiguration file: _conf/local.conf_:\\n\\n```bash\\n# select which machine we want to build\\nMACHINE = \\"qemuriscv32\\"\\n\\n# systemd only\\nINIT_MANAGER = \\"systemd\\"\\n\\n# install erlang-red when creating an image\\nIMAGE_INSTALL:append = \\" erlang-red\\"\\n\\n# additional QEMU configuration for slirp mode, export 8080 tcp port\\nQB_SLIRP_OPT = \\"-netdev user,id=net0,hostfwd=tcp::8080-:8080,hostfwd=tcp::2222-:22\\"\\n```\\n\\n### Build erlang-red recipe\\n\\nRight, the environment is configured. Have sourced the `oe-init-build-env`, we\\ncan build erlang-red recipe:\\n\\n```bash\\nbitbake erlang-red\\n```\\n\\nThis bitbake command will build erlang-red and all its building dependencies.\\n\\nBut to get something useful, we need to also build an image.\\n\\n## A basic image with erlang-red enabled\\n\\nNext, we need to build the final image:\\n\\n```bash\\nbitbake core-image-full-cmdline\\n```\\n\\nBecause we have added erlang-red to `IMAGE_INSTALL`, the build image process\\nwill install erlang-red.\\n\\nWith image ready, it is time to run it.\\n\\n## Running erlang-red with QEMU emulator\\n\\n```bash\\nrunqemu core-image-full-cmdline serialstdio nographic\\n\\n....\\n\\nPoky (Yocto Project Reference Distro) 5.2.99+snapshot-bd4625cd4db0f02162092d85aeab3023914f768a qemuriscv32 ttyS0\\n\\nqemuriscv32 login: root\\n\\nWARNING: Poky is a reference Yocto Project distribution that should be used for\\ntesting and development purposes only. It is recommended that you create your\\nown distribution for production use.\\n\\nroot@qemuriscv32:~#\\n```\\n\\nI used the arguments `serialstdio`, to enable a serial console input attached to\\nstdio; and `nographic` to avoid starting QEMU GUI frontend.\\n\\nIn a new terminal, let\'s open a ssh session and start erlang-red using systemctl\\ncommand:\\n\\n```bash\\nssh root@192.168.7.2\\n\\nLast login: Fri Aug  1 18:50:29 2025 from 172.17.0.1\\n\\nWARNING: Poky is a reference Yocto Project distribution that should be used for\\ntesting and development purposes only. It is recommended that you create your\\nown distribution for production use.\\n\\nroot@qemuriscv32:~# systemctl status erlang-red\\n\u25cf erlang-red.service - Breadboard Programming for Erlang inspired by Node-RED\\n     Loaded: loaded (/usr/lib/systemd/system/erlang-red.service; enabled; preset: enabled)\\n     Active: active (running) since Fri 2025-08-01 18:49:45 UTC; 55s ago\\n```\\n\\nGreat, erlang-red is up and running.\\n\\nIn the host, open a browser at http://192.168.7.2:8080/erlang-red to see the\\nerlang-red web interface.\\n\\nWell, now it is the right time to learn about flow based programming and start\\nplaying with erlang-red.\\n\\n## Erlang-Red runtime analysis\\n\\nThe Erlang-Red performance is relative as there is no much to say when emulating\\nusing QEMU without KVM to improve performance. Some rough analises below:\\n\\n### What about the disk footprint ?\\n\\nThe total erlang-red footprint is about 35Mb of disk space. It includes the ERTS\\n(Erlang Runtime System) and all Erlang/Elixir dependencies. All files installed\\non `/usr/lib/erlang-red` folder. The erlang-red package also provides systemV\\nand systemd start/stop scripts.\\n\\n### And about memory footprint ?\\n\\nIn this use case I used systemd because I want to get the memory footprint that\\nsystemd was reporting:\\n\\n```bash\\nroot@qemuriscv32:~# systemctl status erlang-red\\n\u25cf erlang-red.service - Breadboard Programming for Erlang inspired by Node-RED\\n     Loaded: loaded (/usr/lib/systemd/system/erlang-red.service; enabled; preset: enabled)\\n     Active: active (running) since Fri 2025-08-01 18:49:45 UTC; 55s ago\\n Invocation: 704b9bef5b384451932e15cadb7291fa\\n   Main PID: 322 (beam.smp)\\n      Tasks: 27 (limit: 4915)\\n     Memory: 69.7M (peak: 75.4M)\\n        CPU: 9.751s\\n     CGroup: /system.slice/erlang-red.service\\n             \u251c\u2500322 /usr/lib/erlang-red/bin/erlang_red -Bd -C multi_time_warp -- -root /usr/lib/erlang-red -bindir /usr/lib/erlang-red/erts-16.0.1/bin -progname usr/lib/erlang-red/bin/erlang_red -- -home /var/lib/erlang>\\n             \u251c\u2500380 /usr/lib/erlang-red/erts-16.0.1/bin/epmd -daemon\\n             \u251c\u2500435 erl_child_setup 1024\\n             \u2514\u2500458 /usr/lib/erlang-red/lib/erlexec-2.2.0/priv/x86_64-pc-linux-gnu/exec-port\\n\\nAug 01 18:49:45 qemuriscv32 systemd[1]: Started Breadboard Programming for Erlang inspired by Node-RED.\\nAug 01 18:49:47 qemuriscv32 erlang_red[322]: Exec: /usr/lib/erlang-red/erts-16.0.1/bin/erlexec -noinput +Bd -boot /usr/lib/erlang-red/releases/0.2.2/start -mode embedded -boot_var SYSTEM_LIB_DIR /usr/lib/erlang-red/lib>\\nAug 01 18:49:47 qemuriscv32 erlang_red[322]: Root: /usr/lib/erlang-red\\nAug 01 18:49:47 qemuriscv32 erlang_red[322]: /usr/lib/erlang-red\\nAug 01 18:49:50 qemuriscv32 erlang_red[322]: warning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (which can>\\nlines 1-19/19 (END)\\n\\n```\\n\\nSo, 69.7M is the memory consumption.\\n\\nAs Erlang-Red is in it\'s early development stages, I believe that are open space\\nfor code optimization for reducing memory usage and also for tuning ERTS for the\\nErlang-Red use case.\\n\\n## What has next ?\\n\\nAs a next project, I wish to install erlang-red into a Raspberry Pi platform and\\ncontrol some external hardware. This is a pretty common scenario and let\'s see\\nhow feasible it is with Erlang-Red."},{"id":"/2025/05/11/index","metadata":{"permalink":"/blog/2025/05/11/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-05-11/index.md","source":"@site/blog/2025-05-11/index.md","title":"autotools as build tool for Erlang/OTP projects","description":"The","date":"2025-05-11T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"autotools","permalink":"/blog/tags/autotools"}],"readingTime":5.175,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"autotools as build tool for Erlang/OTP projects","authors":["joaohf"],"tags":["meta-erlang","autotools"]},"unlisted":false,"prevItem":{"title":"Erlang-Red, recipe introduction","permalink":"/blog/2025/07/27/index"},"nextItem":{"title":"New Erlang releases 25.3.2.20, 26.2.5.11, 27.3.3","permalink":"/blog/2025/04/19/index"}},"content":"The\\n[hello-erlang-autoconf](https://github.com/meta-erlang/hello-world/tree/master/hello-erlang-autoconf)\\nrepository is an example about how to use autotools as build tool for Erlang/OTP\\nprojects. The original code came from https://github.com/sirbeancounter/hello. I\\njust adapted it and fixed small issues for Yocto integration.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe result was the creating of a recipe called\\n[hello-erlang-autoconf](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-examples/hello-erlang-autoconf/hello-erlang-autoconf_0.1.0.bb)\\nas an example about how to integrate autotools with erlang build. This recipe is\\nvery interesting because it inherit the class `autotools` which is a standard\\nclass from openembedded-core.\\n\\nautotools provides support for building Erlang projects:\\n[Erlang-Libraries](https://www.gnu.org/software/autoconf/manual/autoconf-2.72/html_node/Erlang-Libraries.html)\\nand I\'ve found a talk about:\\n[Using GNU Autoconf to Configure Erlang Programs](https://erlang.org/euc/06/proceedings/1430Lenglet.ppt).\\nIt looks like using autotools is something that could save time as build tool.\\n\\nI think the final result for the recipe\\n[hello-erlang-autoconf](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-examples/hello-erlang-autoconf/hello-erlang-autoconf_0.1.0.bb)\\nwas very short and easy to customize. Moreover, as autotools is pretty standard\\nfor configuring and building software package it brings solid foundations too.\\n\\nI\'m not saying that autotools is easy to learn or it is the best tool. But\\nsomething to consider.\\n\\nAfter building the recipe `bitbake hello-erlang-autoconf` and with buildhistory\\nenabled it is possible to inspect the size of each dependency.\\n\\n:::note\\n\\nEnabled in `local.conf`:\\n\\n```\\nUSER_CLASSES ?= \\"buildhistory buildstats\\"\\nBUILDHISTORY_COMMIT = \\"1\\"\\n```\\n\\n:::\\n\\nStarting with _hello-erlang-autoconf_ package it says:\\n\\n```bash\\n$ cat buildhistory/packages/riscv32imafdc-poky-linux/hello-erlang-autoconf/hello-erlang-autoconf/latest\\nPV = 0.1.0+git\\nPR = r0\\nPKGV = 0.1.0+git0+6c7f37489e\\nRPROVIDES =\\nRDEPENDS = erlang-epmd erlang-erts erlang-kernel erlang-stdlib\\nRRECOMMENDS =\\nPKGSIZE = 12705\\nFILES = /usr/lib/erlang/lib/hello-*/ebin /etc/hello.d /etc/hello.d/hello.boot /etc/init.d/hello.otp.system /usr/bin/hello.start /usr/bin/hello.stop\\nFILELIST = /etc/hello.d/hello.boot /etc/hello.d/hello.config /etc/init.d/hello.otp.system /usr/bin/hello.start /usr/bin/hello.stop /usr/lib/erlang/lib/hello-6c7f374/ebin/hello.app /usr/lib/erlang/lib/hello-6c7f374/ebin/hello.beam /usr/lib/erlang/lib/hello-6c7f374/ebin/hello_app.beam /usr/lib/erlang/lib/hello-6c7f374/ebin/hello_sup.beam\\n```\\n\\nLooking into `RDEPENDS` it is clear what are necessary to be installed in order\\nto run hello-erlang-autoconf application:\\n\\n```mermaid\\nclassDiagram\\n\\n    hello-erlang-autoconf ..> erlang-epmd : Dependency\\n    hello-erlang-autoconf ..> erlang-erts : Dependency\\n    hello-erlang-autoconf ..> erlang-kernel : Dependency\\n    hello-erlang-autoconf ..> erlang-stdlib : Dependency\\n```\\n\\nA close look into all installed files by hellor-erlang-autoconf:\\n\\n```bash\\n$ cat buildhistory/packages/riscv32imafdc-poky-linux/hello-erlang-autoconf/hello-erlang-autoconf/files-in-package.txt\\ndrwxr-xr-x root       root             4096 ./etc\\ndrwxr-xr-x root       root             4096 ./etc/hello.d\\n-rw-r--r-- root       root             7550 ./etc/hello.d/hello.boot\\n-rwxr-xr-x root       root               63 ./etc/hello.d/hello.config\\ndrwxr-xr-x root       root             4096 ./etc/init.d\\n-rwxr-xr-x root       root             1525 ./etc/init.d/hello.otp.system\\ndrwxr-xr-x root       root             4096 ./usr\\ndrwxr-xr-x root       root             4096 ./usr/bin\\n-rwxr-xr-x root       root              370 ./usr/bin/hello.start\\n-rwxr-xr-x root       root              506 ./usr/bin/hello.stop\\ndrwxr-xr-x root       root             4096 ./usr/lib\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/lib\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/lib/hello-6c7f374\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/lib/hello-6c7f374/ebin\\n-rw-r--r-- root       root              231 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello.app\\n-rw-r--r-- root       root              636 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello_app.beam\\n-rw-r--r-- root       root             1024 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello.beam\\n-rw-r--r-- root       root              800 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello_sup.beam\\n```\\n\\nA few files. Just .beam objects and start scripts. An interesting fact, the\\nfollowing files:\\n\\n```bash\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/lib/hello-6c7f374\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/lib/hello-6c7f374/ebin\\n-rw-r--r-- root       root              231 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello.app\\n-rw-r--r-- root       root              636 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello_app.beam\\n-rw-r--r-- root       root             1024 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello.beam\\n-rw-r--r-- root       root              800 ./usr/lib/erlang/lib/hello-6c7f374/ebin/hello_sup.beam\\n```\\n\\nGet installed inside _/usr/lib/erlang/lib/_, this is where the standard\\nErlang/OTP is installed by erlang recipe from meta-erlang layer.\\n\\nMore details about all erlang-\\\\* dependencies:\\n\\n```bash\\n$ cat buildhistory/packages/riscv32imafdc-poky-linux/erlang/erlang-epmd/latest\\nPV = 28.0.1\\nPR = r0\\nRPROVIDES =\\nRDEPENDS = base-files base-passwd glibc (>= 2.41+git0+6e489c17f8) libsystemd (>= 257.6) shadow\\nRRECOMMENDS =\\nPKGSIZE = 47150\\nFILES = /usr/lib/erlang/erts-*/bin/epmd /usr/lib/erlang/bin/epmd /usr/bin/epmd /usr/lib/systemd/system/epmd.service /usr/lib/systemd/system/epmd.socket /etc/init.d /usr/lib/systemd/system-preset/98-erlang-epmd.preset /usr/lib/systemd/system/epmd.service /usr/lib/systemd/system/epmd.socket\\nFILELIST = /usr/bin/epmd /usr/lib/erlang/bin/epmd /usr/lib/erlang/erts-16.0.1/bin/epmd /usr/lib/systemd/system-preset/98-erlang-epmd.preset /usr/lib/systemd/system/epmd.service /usr/lib/systemd/system/epmd.socket\\n```\\n\\n```bash\\n$ cat buildhistory/packages/riscv32imafdc-poky-linux/erlang/erlang-erts/latest\\nPV = 28.0.1\\nPR = r0\\nRPROVIDES =\\nRDEPENDS = glibc (>= 2.41+git0+6e489c17f8) ncurses-libtinfo (>= 6.5) zlib (>= 1.3.1)\\nRRECOMMENDS =\\nPKGSIZE = 4690380\\nFILES = /usr/bin /usr/lib/erlang/releases /usr/lib/erlang/bin /usr/lib/erlang/erts-*/bin /usr/lib/erlang/lib/erts-*/ebin\\nFILELIST = /usr/bin/erl /usr/bin/escript /usr/bin/run_erl /usr/bin/to_erl /usr/lib/erlang/bin/erl /usr/lib/erlang/bin/erl_call /usr/lib/erlang/bin/escript /usr/lib/erlang/bin/no_dot_erlang.boot /usr/lib/erlang/bin/run_erl /usr/lib/erlang/bin/start /usr/lib/erlang/bin/start.boot /usr/lib/erlang/bin/start.script /usr/lib/erlang/bin/start_clean.boot /usr/lib/erlang/bin/start_erl /usr/lib/erlang/bin/start_sasl.boot /usr/lib/erlang/bin/to_erl /usr/lib/erlang/erts-16.0.1/bin/beam.smp /usr/lib/erlang/erts-16.0.1/bin/dyn_erl /usr/lib/erlang/erts-16.0.1/bin/erl /usr/lib/erlang/erts-16.0.1/bin/erl.src /usr/lib/erlang/erts-16.0.1/bin/erl_call /usr/lib/erlang/erts-16.0.1/bin/erl_child_setup /usr/lib/erlang/erts-16.0.1/bin/erlexec /usr/lib/erlang/erts-16.0.1/bin/escript /usr/lib/erlang/erts-16.0.1/bin/heart /usr/lib/erlang/erts-16.0.1/bin/inet_gethost /usr/lib/erlang/erts-16.0.1/bin/run_erl /usr/lib/erlang/erts-16.0.1/bin/start /usr/lib/erlang/erts-16.0.1/bin/start.src /usr/lib/erlang/erts-16.0.1/bin/start_erl.src /usr/lib/erlang/erts-16.0.1/bin/to_erl /usr/lib/erlang/releases/28/OTP_VERSION /usr/lib/erlang/releases/28/installed_application_versions /usr/lib/erlang/releases/28/no_dot_erlang.boot /usr/lib/erlang/releases/28/no_dot_erlang.rel /usr/lib/erlang/releases/28/no_dot_erlang.script /usr/lib/erlang/releases/28/start.boot /usr/lib/erlang/releases/28/start.script /usr/lib/erlang/releases/28/start_all_example.rel /usr/lib/erlang/releases/28/start_clean.boot /usr/lib/erlang/releases/28/start_clean.rel /usr/lib/erlang/releases/28/start_clean.script /usr/lib/erlang/releases/28/start_sasl.boot /usr/lib/erlang/releases/28/start_sasl.rel /usr/lib/erlang/releases/28/start_sasl.script /usr/lib/erlang/releases/RELEASES /usr/lib/erlang/releases/RELEASES.src /usr/lib/erlang/releases/start_erl.data\\n```\\n\\n```bash\\n$ cat buildhistory/packages/riscv32imafdc-poky-linux/erlang/erlang-kernel/latest\\nPV = 28.0.1\\nPR = r0\\nRPROVIDES =\\nRDEPENDS =\\nRRECOMMENDS =\\nPKGSIZE = 2931802\\nFILES = /usr/lib/erlang/lib/kernel-*\\nFILELIST = /usr/lib/erlang/lib/kernel-10.3.1/ebin/application.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/application_controller.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/application_master.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/application_starter.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/auth.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/code.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/code_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/disk_log.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/disk_log_1.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/disk_log_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/disk_log_sup.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/dist_ac.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/dist_util.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_boot_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_compile_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_ddll.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_debugger.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_distribution.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_epmd.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_erts_errors.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_kernel_errors.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_reply.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erl_signal_handler.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erpc.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/error_handler.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/error_logger.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/erts_debug.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/file.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/file_io_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/file_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/gen_sctp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/gen_tcp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/gen_tcp_socket.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/gen_udp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/gen_udp_socket.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/global.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/global_group.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/global_search.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/group.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/group_history.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/heart.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet6_sctp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet6_tcp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet6_tcp_dist.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet6_udp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_config.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_db.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_dns.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_dns_tsig.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_epmd_dist.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_epmd_socket.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_gethost_native.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_hosts.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_parse.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_res.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_sctp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_tcp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_tcp_dist.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/inet_udp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/kernel.app /usr/lib/erlang/lib/kernel-10.3.1/ebin/kernel.appup /usr/lib/erlang/lib/kernel-10.3.1/ebin/kernel.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/kernel_config.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/kernel_refc.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/local_tcp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/local_udp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_backend.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_config.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_disk_log_h.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_filters.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_formatter.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_h_common.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_handler.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_handler_watcher.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_olp.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_proxy.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_server.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_simple_h.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_std_h.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/logger_sup.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/net.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/net_adm.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/net_kernel.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/os.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/pg.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/pg2.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/prim_tty.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/prim_tty_sighandler.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/ram_file.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/raw_file_io.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/raw_file_io_compressed.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/raw_file_io_deflate.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/raw_file_io_delayed.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/raw_file_io_inflate.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/raw_file_io_list.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/rpc.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/seq_trace.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/socket.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/standard_error.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/trace.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/user_drv.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/user_sup.beam /usr/lib/erlang/lib/kernel-10.3.1/ebin/wrap_log_reader.beam\\n```\\n\\n```bash\\n$ cat buildhistory/packages/riscv32imafdc-poky-linux/erlang/erlang-stdlib/latest\\nPV = 28.0.1\\nPR = r0\\nRPROVIDES =\\nRDEPENDS =\\nRRECOMMENDS =\\nPKGSIZE = 6571412\\nFILES = /usr/lib/erlang/lib/stdlib-*\\nFILELIST = /usr/lib/erlang/lib/stdlib-7.0.1/ebin/argparse.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/array.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/base64.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/beam_lib.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/binary.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/c.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/calendar.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/dets.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/dets_server.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/dets_sup.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/dets_utils.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/dets_v9.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/dict.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/digraph.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/digraph_utils.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/edlin.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/edlin_context.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/edlin_expand.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/edlin_key.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/edlin_type_suggestion.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/epp.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_abstract_code.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_anno.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_bits.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_compile.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_error.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_eval.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_expand_records.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_features.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_internal.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_lint.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_parse.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_posix_msg.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_pp.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_scan.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_stdlib_errors.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/erl_tar.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/error_logger_file_h.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/error_logger_tty_h.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/escript.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/ets.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/eval_bits.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/file_sorter.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/filelib.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/filename.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gb_sets.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gb_trees.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gen.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gen_event.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gen_fsm.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gen_server.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/gen_statem.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/io.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/io_lib.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/io_lib_format.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/io_lib_fread.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/io_lib_pretty.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/json.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/lists.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/log_mf_h.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/maps.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/math.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/ms_transform.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/orddict.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/ordsets.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/otp_internal.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/peer.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/pool.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/proc_lib.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/proplists.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/qlc.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/qlc_pt.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/queue.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/rand.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/random.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/re.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/sets.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/shell.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/shell_default.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/shell_docs.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/shell_docs_markdown.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/shell_docs_test.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/slave.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/sofs.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/stdlib.app /usr/lib/erlang/lib/stdlib-7.0.1/ebin/stdlib.appup /usr/lib/erlang/lib/stdlib-7.0.1/ebin/string.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/supervisor.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/supervisor_bridge.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/sys.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/timer.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/unicode.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/unicode_util.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/uri_string.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/win32reg.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/zip.beam /usr/lib/erlang/lib/stdlib-7.0.1/ebin/zstd.beam\\n```\\n\\nBased on PKGSIZE for each package, we have the following graph showing which\\npackage consumes more space:\\n\\n```mermaid\\npie title Size by package\\n    \\"hello-erlang-autoconf\\" : 12705\\n    \\"erlang-epmd\\" :     47150\\n    \\"erlang-kernel\\" : 2931802\\n    \\"erlang-erts\\" :   4690380\\n    \\"erlang-stdlib\\" : 6571412\\n```\\n\\n| Package                | Size     |\\n| ---------------------- | -------- |\\n| hellow-erlang-autoconf | 12705    |\\n| erlang-epmd            | 47150    |\\n| erlang-kernel          | 2931802  |\\n| erlang-erts            | 4690380  |\\n| erlang-stdlib          | 6571412  |\\n| Total                  | 14253449 |\\n\\nSo, almost 15Mb is necessary for a simple erlang application. Nowadays it is\\nalmost nothing. But that raise some questions:\\n\\n1. Is that possible to reduce the size of ERTS ?\\n   - Maybe using some configure and build flags for better code optimization\\n   - Or even necessary detect which places in Erlang/OTP source code worth\\n     optimizations\\n1. Double check if debug symbols are present in each .beam file\\n1. erlang-stdlib is consuming most of the space. However, it has everything\\n   needed for building applications. It\'s a fact.\\n   - Maybe there are open room for spliting erlang-stdlib in small libraries ?"},{"id":"/2025/04/19/index","metadata":{"permalink":"/blog/2025/04/19/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-04-19/index.md","source":"@site/blog/2025-04-19/index.md","title":"New Erlang releases 25.3.2.20, 26.2.5.11, 27.3.3","description":"Due CVE-2025-32433, more","date":"2025-04-19T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.265,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 25.3.2.20, 26.2.5.11, 27.3.3","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"autotools as build tool for Erlang/OTP projects","permalink":"/blog/2025/05/11/index"},"nextItem":{"title":"fwup for A/B image upgrades on raspberrypi machines with NervesCloud, part I","permalink":"/blog/2025/03/21/index"}},"content":"Due [CVE-2025-32433](https://nvd.nist.gov/vuln/detail/CVE-2025-32433), more\\ndetails at\\n[Unauthenticated Remote Code Execution in Erlang/OTP SSH](https://github.com/erlang/otp/security/advisories/GHSA-37cp-fgq5-7wc2),\\n\\nwe have updated the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version           |\\n| ------------------ | ---------------------------- |\\n| master             | 25.3.2.20, 26.2.5.11, 27.3.3 |\\n| scarthgap          | 25.3.2.20, 26.2.5.11, 27.3.3 |\\n| kirkstone          | 25.3.2.20, 26.2.5.11, 27.3.3 |"},{"id":"/2025/03/21/index","metadata":{"permalink":"/blog/2025/03/21/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-03-21/index.md","source":"@site/blog/2025-03-21/index.md","title":"fwup for A/B image upgrades on raspberrypi machines with NervesCloud, part I","description":"This blog post introduces nerves-hub-link running on raspberrypi machines in","date":"2025-03-21T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"fwup","permalink":"/blog/tags/fwup"},{"inline":true,"label":"rpi","permalink":"/blog/tags/rpi"}],"readingTime":3.525,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"fwup for A/B image upgrades on raspberrypi machines with NervesCloud, part I","authors":["joaohf"],"tags":["meta-erlang","fwup","rpi"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 25.3.2.20, 26.2.5.11, 27.3.3","permalink":"/blog/2025/04/19/index"},"nextItem":{"title":"fwup for A/B image upgrades on QEMU machines with NervesCloud, part III","permalink":"/blog/2025/01/26/index"}},"content":"This blog post introduces nerves-hub-link running on raspberrypi machines in\\norder to upgrade firmware via [NervesCloud](https://nervescloud.com/).\\n\\n\x3c!-- truncate --\x3e\\n\\nOn previous [blog posts about fwup](/blog/tags/fwup/), we have explored and\\ntested using QEMU based machines. Now it\'s time to change the target and use a\\nreal machine.\\n\\nNowadays, raspberrypi is an accessible development platform for prototyping and\\nwhy not for real use cases too.\\n\\nOn Yocto side, there is a stable layer called\\n[meta-raspberrypi](https://github.com/agherzan/meta-raspberrypi) which\\nimplements many of raspberrypi boards.\\n\\nThe end goal is to update the target board using NervesCloud, the\\n[same way that was done using QEMU based machines](/blog/2025/01/26/index/).\\n\\nThe focus of this post is about how to prepare a working Yocto setup for\\nraspberry context. I\'ll not show a demonstration this time, reserving it for the\\nnext blog posts ;)\\n\\n### YP/OE Setup\\n\\nI\'ll try to simplify the YP/OE setup to just tree small steps:\\n\\n:::note\\n\\nThis is the same steps taken for the previous blog post called\\n[fwup for A/B image upgrades on QEMU machines with NervesCloud, part III](/blog/2025/01/26/index/).\\nBut now, with one additional layer called\\n[meta-raspberrypi](https://github.com/agherzan/meta-raspberrypi).\\n\\nAlso, removing the meta-qemu-bsp.\\n\\n:::\\n\\n1. Cloning all repositories for master release:\\n\\n   ```bash\\n   git clone --branch master git://git.yoctoproject.org/poky\\n   git clone --branch master https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch master https://github.com/fwup-home/meta-fwup\\n   git clone --branch master https://github.com/joaohf/meta-fwup-examples\\n   git clone --branch master https://github.com/meta-erlang/meta-erlang\\n   git clone --branch master https://github.com/meta-erlang/meta-axon\\n   git clone --branch master https://github.com/joaohf/meta-nerves-hub\\n   git clone --branch master https://github.com/agherzan/meta-raspberrypi\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-fwup\\n   bitbake-layers add-layer ../meta-fwup-examples\\n   bitbake-layers add-layer ../meta-nerves-hub\\n   bitbake-layers add-layer ../meta-raspberrypi\\n   bitbake-layers add-layer ../meta-axon\\n   bitbake-layers add-layer ../meta-erlang\\n   ```\\n\\n### Configuring the build environment\\n\\nFor this use case, the quickest way is edit and add the _conf/local.conf_\\nconfiguration file.\\n\\nWe start enabling some\\n[multiconfig configurations](https://docs.yoctoproject.org/5.0.7/dev-manual/building.html#building-images-for-multiple-targets-using-multiple-configurations):\\n\\n```bash\\nBBMULTICONFIG ?= \\"\\\\\\n    raspberrypi0-wifi-nerves-hub-link \\\\\\n    raspberrypi4-64-nerves-hub-link \\\\\\n    raspberrypi5-nerves-hub-link \\\\\\n   \\"\\n```\\n\\nThe layer meta-axon provides some samples for\\n[raspberry configurations with nerves-hub enabled](https://github.com/meta-erlang/meta-axon/tree/master/conf/multiconfig).\\n\\nmulticonfig is useful because it simplify bitbake configurations when we have\\nmany target boards. On my test setup I\'m building for raspberrypi 0, 4 and 5.\\n\\n### Building images\\n\\nNext, we need to build images:\\n\\n```bash\\nbitbake multiconfig:raspberrypi4-64-nerves-hub-link:core-image-base\\n\\nbitbake multiconfig:raspberrypi5-nerves-hub-link:core-image-base\\n\\nbitbake multiconfig:raspberrypi0-wifi-nerves-hub-link:core-image-base\\n```\\n\\n:::note\\n\\ncore-image-base is being used here. It\'s suitable for raspberrypi.\\n\\n:::\\n\\nAfter the above commands, the result are the following files:\\n\\n```\\ntmp-raspberrypi0-wifi-glibc-nerves-hub-link/deploy/images/raspberrypi0-wifi/core-image-base-raspberrypi0-wifi.rootfs.fwup\\ntmp-raspberrypi4-64-glibc-nerves-hub-link/deploy/images/raspberrypi4-64/core-image-base-raspberrypi4-64.rootfs.fwup\\ntmp-raspberrypi5-glibc-nerves-hub-link/deploy/images/raspberrypi5/core-image-base-raspberrypi5.rootfs.fwup\\n```\\n\\nAnd are ready to flash into a bootable device.\\n\\n### Flashing image\\n\\nBefore running fwup commands:\\n\\n```\\nbitbake fwup-native -caddto_recipe_sysroot\\n```\\n\\nFor each fwup image, and using `fwup` for flashing (one sdcard for each image):\\n\\nrpi0:\\n\\n```\\noe-run-native fwup-native \\\\\\n  fwup -a -d /dev/sdc \\\\\\n  -t complete \\\\\\n  -i tmp-raspberrypi0-wifi-glibc-nerves-hub-link/deploy/images/raspberrypi0-wifi/core-image-base-raspberrypi0-wifi.rootfs.fwup\\n```\\n\\nrpi4:\\n\\n```\\noe-run-native fwup-native \\\\\\n  fwup -a -d /dev/sdc \\\\\\n  -t complete \\\\\\n  -i tmp-raspberrypi4-64-glibc-nerves-hub-link/deploy/images/raspberrypi4-64/core-image-base-raspberrypi4-64.rootfs.fwup\\n```\\n\\nrpi5:\\n\\n```\\noe-run-native fwup-native \\\\\\n  fwup -a -d /dev/sdc \\\\\\n  -t complete \\\\\\n  -i tmp-raspberrypi5-glibc-nerves-hub-link/deploy/images/raspberrypi5/core-image-base-raspberrypi5.rootfs.fwup\\n```\\n\\n### And booting\\n\\nJust put the sdcard into raspiberrypi and boot. It should work as expected.\\n\\n:::note\\n\\nI promised, for the next blog post I\'ll share a full demonstration\\n\\n:::\\n\\n## Some important details not discussed before\\n\\n### meta-nerves-hub\\n\\nThe [meta-nerves-hub](https://github.com/joaohf/meta-nerves-hub) layer has a\\nrecipe for\\n[nerves-hub-link_2.5.2.bb](https://github.com/joaohf/meta-nerves-hub/tree/master/recipes-extended/nerves-hub-link_2.5.2.bb).\\nThis recipe installs a standalone nerves-hub-link. I\'ve tested the version 2.5.2\\nand it works for my initial goals.\\n\\nHowever, the later nerves-hub-link versions are not prepared to run as\\nstandalone application anymore. It needs to be part of a BEAM application in\\norder to be properly configured.\\n\\nI\'ve tested recent versions and ended up with nerves-hub-link fighting with\\nlinux network stack; for instance trying to configure it where it should not or\\nusing others ways to detect configurations.\\n\\n:::note\\n\\nIt\'s up to you when design Yocto based linux distributions select what network\\nmanager best fits to your needs. Yocto gives to you many options as well a\\ndefault one.\\n\\n:::\\n\\nSo, the next organic step will be to implement a BEAM application that uses\\nnerves-hub-link. That would be a kind of nerves-hub-link-agent. I just want to\\nstart it and play nice with linux network configuration stack.\\n\\n## Conclusions\\n\\nSo, this blog post was more to make a milestone for this trip. And we are\\ngetting closer to get Yocto based linux distro full integrated with NervesCloud\\nwithout thinking too much."},{"id":"/2025/01/26/index","metadata":{"permalink":"/blog/2025/01/26/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2025-01-26/index.md","source":"@site/blog/2025-01-26/index.md","title":"fwup for A/B image upgrades on QEMU machines with NervesCloud, part III","description":"This blog post shows how to use NervesCloud in order","date":"2025-01-26T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"fwup","permalink":"/blog/tags/fwup"},{"inline":true,"label":"qemu","permalink":"/blog/tags/qemu"}],"readingTime":9.975,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"fwup for A/B image upgrades on QEMU machines with NervesCloud, part III","authors":["joaohf"],"tags":["meta-erlang","fwup","qemu"]},"unlisted":false,"prevItem":{"title":"fwup for A/B image upgrades on raspberrypi machines with NervesCloud, part I","permalink":"/blog/2025/03/21/index"},"nextItem":{"title":"fwup for A/B image upgrades on QEMU machines with fwup, part II","permalink":"/blog/2024/12/20/index"}},"content":"This blog post shows how to use [NervesCloud](https://nervescloud.com/) in order\\nto upgrade and manage linux images based on Yocto Project.\\n\\n\x3c!-- truncate --\x3e\\n\\nWe will run this demonstration with QEMU ARM based machine prepared as a result\\nof previous blog post called\\n[fwup for A/B image upgrades on QEMU machines with fwup, part II](/blog/2024/12/20/index/).\\n\\n## What is NervesCloud\\n\\n[NervesCloud](https://nervescloud.com/) is an instance of\\n[NervesHub](https://github.com/nerves-hub) based on cloud. It could be\\nconsidered NervesCloud as a SaaS for NervesHub. In that way, instead you having\\nto install and manage your own instance of NervesHub for\\n[Nerves devices](https://nerves-project.org/) management, NervesCloud takes care\\nof all the infrastructure and provides to you the benefits without worry with\\ndetails.\\n\\nIn this demonstration, we will use NervesCloud with a development account called\\n_Experiments_. As NervesCloud is a multi-tenant system, anyone can have an\\naccount for real or development purposes.\\n\\n:::note\\n\\nIt\'s not part of this demonstration how to setup a NervesCloud account. However,\\nI would like to say thank you to NervesCloud team to take care of these details.\\n\\n:::\\n\\n### Preparing a key pair for firmware signing\\n\\nNervesCloud works with signed firmware images files. It\'s mandatory to signed\\nthese images before uploading into NervesCloud.\\n\\n:::note\\n\\nI expected that you have a working Elixir environment for the following steps.\\n\\n:::\\n\\nClone [nerves_hub_cli](https://github.com/nerves-hub/nerves_hub_cli) project:\\n\\n```bash\\ngit clone https://github.com/nerves-hub/nerves_hub_cli\\ncd nerves_hub_cli\\n```\\n\\nLet\'s start configuring two environment variable that nerver_hub_cli tool will\\nuse:\\n\\n```bash\\nexport NERVES_HUB_ORG=Experiments\\nexport NERVES_HUB_URI=https://devices.nervescloud.com\\n```\\n\\nNext, we need to create a key pair for signed fw files later. For that, we use\\nthe subcommand `nerves_hub.key create`:\\n\\n```bash\\nmix  nerves_hub.key create QemuMachines1\\nNervesHub server: devices.nervescloud.com:443\\nNervesHub organization: Experiments\\nCreating a firmware signing key pair named \'QemuMachines1\'.\\n\\nThe private key is stored locally and must be protected by a password.\\nIf you are sharing the firmware signing private key with others,\\nplease choose an appropriate password.\\n\\nSigning key password for \'QemuMachines1\':\\n\\nFirmware public key written to \'/home/joaohf/.nerves-hub/keys/Experiments/QemuMachines1.pub\'.\\nPassword-protected firmware private key written to \'/home/joaohf/.nerves-hub/keys/Experiments/QemuMachines1.priv\'.\\n\\nRegistering the firmware signing public key \'QemuMachines1\' with NervesHub.\\n\\n22:35:09.524 [info] POST https://devices.nervescloud.com/api/orgs/Experiments/keys -> 201 (578.459 ms)\\n\\n22:35:09.528 [debug]\\n>>> REQUEST >>>\\n(no query)\\nAuthorization: token nhu_xyz\\n\\n%{name: \\"QemuMachines1\\", key: \\"xyz\\"}\\n\\n<<< RESPONSE <<<\\ndate: Sun, 09 Feb 2025 22:35:08 GMT\\ncontent-length: 86\\nvary: accept-encoding\\ncontent-type: application/json; charset=utf-8\\ncache-control: max-age=0, private, must-revalidate\\nstrict-transport-security: max-age=31536000\\nx-request-id: GCKrFDWwXjoGnjQAHQLx\\nserver: Fly/1ab217aa (2025-02-07)\\nvia: 1.1 fly.io\\nfly-request-id: 01JKPDMBHQP83WW1971PCXC0FZ-gig\\n\\n%{\\"data\\" => %{\\"key\\" => \\"xyz\\", \\"name\\" => \\"QemuMachines1\\"}}\\n\\nSuccess. Key information:\\n  name:       QemuMachines1\\n  public key: xyz\\n```\\n\\nThe main outcome here is that the command `nerves_hub.key create` has created a\\nvalide key pair called QemuMachines1. We also need to export this key pair to\\nsomething that Yocto can read later. For that, we use the command\\n`nerves_hub.key export`:\\n\\n```bash\\nmix nerves_hub.key export QemuMachines1\\nNervesHub server: devices.nervescloud.com:443\\nNervesHub organization: Experiments\\nLocal signing key password for \'QemuMachines1\':\\nFwup keys exported to: /home/joaohf/.nerves-hub/nerves_hub-fwup-keys-Experiments-QemuMachines1.tar.gz\\n```\\n\\nThat is great, the key pair QemuMachines1 is ready. We just need one small step\\nin order to extract two files from the tar.gz file:\\n\\n```bash\\nmkdir /tmp/exported_keys\\ntar zxf ~/.nerves-hub/nerves_hub-fwup-keys-Experiments-QemuMachines1.tar.gz -C /tmp/exported_keys\\n```\\n\\nAnd finally, we have the keys as expected:\\n\\n```bash\\nls -l /tmp/exported_keys\\ntotal 8\\n-rw-r--r-- 1 joaohf joaohf 88 fev  9 19:36 QemuMachines1.priv\\n-rw-r--r-- 1 joaohf joaohf 44 fev  9 19:36 QemuMachines1.pub\\n```\\n\\nKeep QemuMachines1.priv and QemuMachines1.pub files around. We will need to\\nconfigure Yocto in order to make fwup signed firmwares automatically.\\n\\n## Upgrade/Downgrade demonstration\\n\\nAs always, I like to describe all steps. In case someone wants to try it. My\\ntarget here is to play with NervesCloud for upgrade -> downgrade -> upgrade\\ncycle.\\n\\n### YP/OE Setup\\n\\nI\'ll try to simplify the YP/OE setup to just tree small steps:\\n\\n:::note\\n\\nThis is the same steps taken for the previous blog post called\\n[fwup for A/B image upgrades on QEMU machines with fwup, part II](/blog/2024/12/20/index).\\nBut now, with one additional layer called\\n[meta-nerves_hub](https://github.com/joaohf/meta-nerves-hub).\\n\\n:::\\n\\n1. Cloning all repositories for master release:\\n\\n   ```bash\\n   git clone --branch master git://git.yoctoproject.org/poky\\n   git clone --branch master https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch master https://github.com/fwup-home/meta-fwup\\n   git clone --branch master https://github.com/joaohf/meta-fwup-examples\\n   git clone --branch master https://github.com/meta-erlang/meta-qemu-bsp\\n   git clone --branch master https://github.com/meta-erlang/meta-erlang\\n   git clone --branch master https://github.com/meta-erlang/meta-axon\\n   git clone --branch master https://github.com/joaohf/meta-nerves-hub\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-fwup\\n   bitbake-layers add-layer ../meta-qemu-bsp\\n   bitbake-layers add-layer ../meta-fwup-examples\\n   bitbake-layers add-layer ../meta-nerves-hub\\n   bitbake-layers add-layer ../meta-axon\\n   bitbake-layers add-layer ../meta-erlang\\n   ```\\n\\n### Configuring the build environment\\n\\nFor this use case, the quickest way is edit and add the _conf/local.conf_\\nconfiguration file.\\n\\nWe start defining the MACHINE and DISTRO:\\n\\n```bash\\nMACHINE = \\"qemuarm64-uboot\\"\\nDISTRO = \\"poky\\"\\n```\\n\\nThe machine _qemuarm64-uboot_ is provided by\\n[meta-qemu-bsp](https://github.com/meta-erlang/meta-qemu-bsp) layer. That\\nmachine uses u-boot as bootloader.\\n\\nAs YP/OE supports many types of image outputs, we want to be specific here and\\npick only the _fwup_ type.\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# enable support for making fwup images\\nIMAGE_CLASSES += \\"image_types_fwup\\"\\nIMAGE_FSTYPES = \\"fwup fwup.qcow2\\"\\nEOF\\n```\\n\\n### Configure NervesCloud product name\\n\\nEdit the file _conf/local.conf_ and overwrite the variable `FWUP_META_PRODUCT`\\nwith the contents of NervesHub Cloud product. In my case the product name is\\n_YoctoFwup_:\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# NervesHub product name\\nFWUP_META_PRODUCT = \\"YoctoFwup\\"\\nEOF\\n```\\n\\n### Configure private and public keys for fwup tool\\n\\nThe bbclass image*types_fwup.bbclass takes care of signing fwup images when the\\nvariables `FWUP_PRIVATE_KEY_FILE` and `FWUP_PUBLIC_KEY_FILE` are available. For\\nthis demonstration, we need to make signed .fw (firmware update files) images.\\nLet\'s add these two variables to \\\\_conf/local.conf* too:\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\nFWUP_PRIVATE_KEY_FILE = \\"/tmp/exported_keys/QemuMachines1.priv\\"\\nFWUP_PUBLIC_KEY_FILE = \\"/tmp/exported_keys/QemuMachines1.pub\\"\\nEOF\\n```\\n\\nThat is all for this step.\\n\\n### Build fwup firmware\\n\\nIn this experiment we will build two images. And, for each build, the variable\\n`FWUP_META_VERSION` will be changed.\\n\\nLet\'s start creating an image that represents the version 1.0.1. Edit the file\\n_conf/local.conf_ and add the following:\\n\\n```bash\\n# 1st build\\nFWUP_META_VERSION = \\"1.0.1\\"\\n```\\n\\nNext, we need to build a new image:\\n\\n```bash\\nbitbake multiconfig:qemuarm64-uboot-nerves-hub-link:core-image-full-cmdline\\n```\\n\\nAfter this build, let\'s copy the signed fwup firmware image (\\\\*signed.fw) to a\\ntemporary folder. For better organization, rename it adding the version \\"1.0.1\\":\\n\\n```bash\\ncp tmp-qemuarm64-uboot-glibc-nerves-hub-link/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs-20250126203524.fw \\\\\\n  /tmp/core-image-full-cmdline-qemuarm64-uboot.rootfs-20250126203524-1.0.1.signed.fw\\n```\\n\\nOk. We got the version 1.0.1. Now, let\'s prepare the version 1.2.0.\\n\\nStill in build folder, edit the file _conf/local.conf_ and change the variable\\n`FWUP_META_VERSION`:\\n\\n```bash\\n# 2nd build\\nFWUP_META_VERSION = \\"1.2.0\\"\\n```\\n\\nBuild the new image:\\n\\n```bash\\nbitbake multiconfig:qemuarm64-uboot-nerves-hub-link:core-image-full-cmdline\\n```\\n\\nAnd when finished, copy the fwup firmware (\\\\*signed.fw) to a temporary folder.\\nAdd to the filename the version \\"1.2.0\\":\\n\\n```bash\\ncp tmp-qemuarm64-uboot-glibc-nerves-hub-link/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs-20250126211722.fw \\\\\\n  /tmp/core-image-full-cmdline-qemuarm64-uboot.rootfs-20250126211722.1.2.0.signed.fw\\n```\\n\\nThe final result is like that:\\n\\n```bash\\nls -l /tmp\\n-rw-rw-r-- 1 229596347 jan 26 18:02 core-image-full-cmdline-qemuarm64-uboot.rootfs-20250126203524-1.0.1.signed.fw\\n-rw-rw-r-- 1 229596346 jan 26 18:23 core-image-full-cmdline-qemuarm64-uboot.rootfs-20250126211722.1.2.0.signed.fw\\n```\\n\\nThere are two signed fwup firmware images ready to be uploaded into Nerves\\nCloud.\\n\\n### fwup firmware upload\\n\\nThe procedures to upload the fwup image is very simple. Inside the NervesCloud\\nweb interface, go to \'Firmware\' menu and use the button \'Upload Firmware\' to\\nstart uploading a new firmware file.\\n\\nWe\'ll need to upload both images (1.0.1 and 1.2.0) for the next exercises. The\\nfinal Firmware list pages should be something like that:\\n\\n![alt Firmware listing](nhc_firmware_listing.png \'Firmwares uploaded\')\\n\\n### Playing with upgrades\\n\\nNow, it\'s time to observe and play with some upgrades and downgrades.\\n\\nFirst, let\'s start runqemu with our last image build:\\n\\n```bash\\nrunqemu  nographic serialstdio slirp \\\\\\nmulticonfig:qemuarm64-uboot-nerves-hub-link:core-image-full-cmdline \\\\\\nwic.qcow2 qemuparams=\\"-m 1024\\"\\n```\\n\\n:::note\\n\\nIn my case, the parameter `-m 1024` was necessary because my development images\\nwere a bit oversized.\\n\\n:::\\n\\nInside QEMU instance, start nerves_cloud_link application:\\n\\n```bash\\n/usr/lib/nerves-hub-link/bin/nerves_hub_link start_iex\\n```\\n\\nIn NervesCloud web interface, check with the device has listed there:\\n\\n![alt Device up](nhc_device_10_connected.png \'Device up with 1.2.0 version\')\\n\\nThe \'Firmware\' column should be pointing to \'1.2.0\' version (because this\\nversion was the latest build).\\n\\nFor upgrade and downgrade using NervesCloud, there are some options like\\ncreating a Deployment or send an update command to a specific device. In this\\nexperiment, let\'s send update command.\\n\\nWe want to test the following scenarios:\\n\\n- downgrade 1.2.0 -> 1.0.1\\n\\n  Select the device that we want to work, in my case the device is \'10\'. And on\\n  device administration page, select the firmware version that we want to send.\\n  In this case it will be the version 1.0.1. And click on \\"Send update\\" button.\\n\\n  ![alt Sending firmware](nhc-send-update-to-1.0.1.png \'Sensing firmware 1.0.1\')\\n\\n  While NervesCloud is sending the new firmware to device, on QEMU console we\\n  can check that nerves_hub_link is working as expected:\\n\\n  ```bash\\n  22:01:38.452 [info] [NervesHubLink] Resuming download attempt number 0 https://files.nervescloud.com/firmware/38/a6fd8354-ecc6-50c9-e337-5c72d8c105d5.fw?X-Amz-Algorithm=AWS4-HMAC-SHA256\\n  22:01:38.469 [info] [NervesHubLink] Downloading firmware: https://files.nervescloud.com/firmware/38/a6fd8354-ecc6-50c9-e337-5c72d8c105d5.fw?X-Amz-Algorithm=AWS4-HMAC-SHA256\\n  22:01:38.472 [notice]     :alarm_handler: {:set, {NervesHubLink.UpdateInProgress, []}}\\n  22:01:38.482 [debug] [NervesHubLink] FWUP PROG: 0%\\n  22:01:39.627 [warning] [NervesHubLink] FWUP WARN: Upgrading partition B\\n  22:01:40.114 [debug] [NervesHubLink] FWUP PROG: 1%\\n  22:01:40.551 [debug] [NervesHubLink] FWUP PROG: 2%\\n  22:01:40.552 [debug] [NervesHubLink] FWUP PROG: 3%\\n  ....\\n  ....\\n  ....\\n  22:02:09.478 [debug] [NervesHubLink] FWUP PROG: 100%\\n  22:02:09.481 [info] [NervesHubLink] FWUP SUCCESS: 0\\n  22:02:09.482 [info] [NervesHubLink] FWUP Finished\\n  22:02:09.483 [notice]     :alarm_handler: {:clear, NervesHubLink.UpdateInProgress}\\n  22:02:09.484 [info] Elixir.Nerves.Runtime.Power : device told to reboot\\n  22:02:09.488 [error] Heart: Erlang heart isn\'t running. Check vm.args.\\n  22:02:09.731 [warning] [NervesTime] Stopping RTC NervesTime.FileTime: :shutdown\\n  ```\\n\\n  The device will update and reboot. When QEMU instance is back, start\\n  nerves_hub_link again and check the expected version in NervesCloud web\\n  interface:\\n\\n  :::note\\n\\n  The manual start is OK for this experiment. Just execute nerves_hub_link again\\n  on QEMU console:\\n\\n  ```bash\\n  /usr/lib/nerves-hub-link/bin/nerves_hub_link start_iex\\n  ```\\n\\n  :::\\n\\n  ![alt Device updated](nhc_device_updated_to_101.png \'Device updated to 1.0.1 version\')\\n\\n  Very good, the downgrade has been completed.\\n\\n- upgrade 1.0.1 -> 1.2.0\\n\\n  Now, it\'s time to perform an upgrade from 1.0.1 to 1.2.0 version. Following\\n  the same steps above, but selecting the version 1.2.0 this time, the device\\n  will be updated to 1.2.0 version:\\n\\n  ![alt Device updated](nhc_update_device_10_to_120.png \'Update to 1.2.0 version\')\\n\\n  When QEMU is back, we can check which version NervesCloud will show:\\n\\n  ![alt Device updated](nhc_device_updated_to_120.png \'Device updated to 1.2.0 version\')\\n\\nWe can play with this dancing many times. Proving that upgrade/downgrade works\\nas expected.\\n\\n## Some low level details: introducing meta-nerves-hub\\n\\n### meta-nerves-hub\\n\\n[meta-nerves-hub](https://github.com/joaohf/meta-nerves-hub) layer is a new\\nlayer introduced to keep common application and configurations for\\n[NervesHub](https://github.com/nerves-hub) and\\n[Nerves Project](https://github.com/nerves-project) working with Yocto Project.\\nThe purpose is to bring essential and base components for anyone that wants to\\nuse YP/Openembedded in your products.\\n\\nmeta-nerves-hub has a recipe called\\n[nerves-hub-link_2.5.2.bb](https://github.com/joaohf/meta-nerves-hub/tree/master/recipes-extended/nerves-hub-link_2.5.2.bb)\\nwhich builds nerves-hub-link application. I had to apply two patches for\\nnerves-hub-link source code in order to make it work well when building inside\\nYocto environment:\\n\\n- The first one is\\n  [0001-Use-MIX_TARGET_INCLUDE_ERTS-for-include-ERTS-release.patch](https://github.com/joaohf/meta-nerves-hub/blob/master/recipes-extended/nerves-hub-link/nerves-hub-link/0001-Use-MIX_TARGET_INCLUDE_ERTS-for-include-ERTS-release.patch)\\n\\n- And the second one was about using KVBackend from UbootEnv instead memory:\\n  [0001-Use-UbootEnv-as-kv_backend.patch](https://github.com/joaohf/meta-nerves-hub/blob/master/recipes-extended/nerves-hub-link/nerves-hub-link/0001-Use-UbootEnv-as-kv_backend.patch)\\n\\n### extending nerves-hub-link recipe\\n\\nThe nerves-hub-link recipe is not intend for use as standalone. It\'s purpose is\\nfor development and demonstration. When running nerves-hub-link it\'s necessary\\nto configure it with the correct\\n[shared secret credentials](https://github.com/nerves-hub/nerves_hub_link?tab=readme-ov-file#connecting-your-device-to-nerveshub).\\n\\nTo get quick results, I\'ve extended\\n[nerves-hub-link from meta-axon layer](https://github.com/meta-erlang/meta-axon/tree/master/dynamic-layers/meta-nerves-hub/recipes-extended/nerves-hub-link/nerves-hub-link_2.5.2.bbappend)\\nwith the correct shared secret credentials used by my development instance on\\nNervesCloud.\\n\\nFor a real use of nerves-hub-link, the correct way would be creating a new\\nElixir application that has nerves-hub-link as dependency and make all the\\nconfiguration needed.\\n\\n:::note\\n\\nThe NervesCloud team are working on a pre-build agent model, which will simplify\\nsetup and configuration.\\n\\n:::\\n\\n## Conclusions\\n\\nI am having so much fun playing with fwup and NervesCloud that I will keep\\nimproving this environment. Just to recap the adventures so far:\\n\\n- [fwup for A/B image upgrades, part I](/blog/2024/09/24/index/)\\n- [fwup for A/B image upgrades on QEMU machines with fwup, part II](/blog/2024/12/20/index/)\\n\\nIt is all about enabling features and managing what is feasible or not. Of\\ncourse, implementing the missing parts. When building products with Yocto\\nProject, it is a bit like playing a\\n[open-world video game](https://en.wikipedia.org/wiki/Open_world). You have to\\nhave a target in mind.\\n\\nMy plan is to continue adding more fwup configurations into meta-fwup-examples\\nlayer in order to support more BSP layers and well know boards like raspberrypi.\\nAlso, trying to use some other processor architectures like: riscv, ppc, mips\\nall running on QEMU and Yocto Project. I will stay in this loop until get\\nsomething stable."},{"id":"/2024/12/20/index","metadata":{"permalink":"/blog/2024/12/20/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-12-20/index.md","source":"@site/blog/2024-12-20/index.md","title":"fwup for A/B image upgrades on QEMU machines with fwup, part II","description":"This blog post describes all parts involved in order to use QEMU machines with","date":"2024-12-20T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"fwup","permalink":"/blog/tags/fwup"},{"inline":true,"label":"qemu","permalink":"/blog/tags/qemu"}],"readingTime":11.15,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"fwup for A/B image upgrades on QEMU machines with fwup, part II","authors":["joaohf"],"tags":["meta-erlang","fwup","qemu"]},"unlisted":false,"prevItem":{"title":"fwup for A/B image upgrades on QEMU machines with NervesCloud, part III","permalink":"/blog/2025/01/26/index"},"nextItem":{"title":"Introducing Gleam to meta-erlang layer","permalink":"/blog/2024/11/03/index"}},"content":"This blog post describes all parts involved in order to use QEMU machines with\\nYocto images for testing and developing A/B image upgrades. Moreover, this blog\\npost could be considered an extension for the\\n[fwup for A/B image upgrades, part I](/blog/2024/09/24/index) blog post.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe [fwup](https://github.com/fwup-home/fwup) tool and\\n[meta-fwup](https://github.com/fwup-home/meta-fwup) have been introduced in the\\nprevious blog post and serve as a base knowledge for this post.\\n\\n## Objectives and Tools\\n\\nWhen I was writing and testing the post\\n[fwup for A/B image upgrades, part I](/blog/2024/09/24/index), it was very\\ntedious have to wait the test cycle which basically was:\\n\\n1. Make one change\\n2. Build a new image\\n3. Burn the image into sdcard\\n4. Plug the sdcard on the target real board\\n5. Power on\\n6. Test\\n7. Power off\\n8. Get the results\\n9. Go to step #1\\n\\nI\'ve spent too much time waiting for feedback. Since then, I\'ve been thinking\\nhow it would be possible to speed up my test cycle.\\n\\nMaybe buying more target boards or reduce the final image footprint or buy a\\nfaster build machine. None of them would help much the situation.\\n\\nThen, I remember that one of the greatest feature from Yocto Project is the\\nintegration with [QEMU](https://www.qemu.org/) emulator. Yocto brings some\\nready-to-use\\n[qemu machines](https://git.yoctoproject.org/poky/tree/README.qemu.md) that one\\ncould use in order to run an image made with Yocto Project and spending no\\nmoney.\\n\\nHowever, some pieces were missing:\\n\\n- The qemu default machines are not prepared for using u-boot as boot loader\\n- u-boot does not know how to load environment variables from virtio block\\n  devices\\n- lack of qemu device-tree files (.dtb) when booting qemu machines\\n\\nIt was clear that without some patches my idea of short test cycle would not be\\nfeasible.\\n\\nSo, this blog post continues the story about\\n[fwup tool](https://github.com/fwup-home/fwup) in Yocto world. There are two\\nimportant sections:\\n\\n- One showing a practical use case with all steps necessary to test the A/B\\n  upgrades with fwup on qemu u-boot.\\n- A second one describing the patches and layers that I\'ve created for booting\\n  qemu machines with u-boot and Yocto images.\\n\\n## Use case: A/B upgrades with QEMU u-boot machines\\n\\n### YP/OE setup\\n\\nI\'ll try to simplify the YP/OE setup to just tree small steps:\\n\\n:::note\\n\\nThe YP documentation is very good. I strong recommend its reading. For this\\nsection the release version used is\\n[master](https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html).\\n\\nOne important point is to double check the\\n[Required Packages for the Build Host](https://docs.yoctoproject.org/ref-manual/system-requirements.html#required-packages-for-the-build-host.)\\n\\n:::\\n\\n1. Cloning all repositories for master release:\\n\\n   ```bash\\n   git clone --branch master git://git.yoctoproject.org/poky\\n   git clone --branch master https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch master https://github.com/fwup-home/meta-fwup\\n   git clone --branch master https://github.com/meta-erlang/meta-qemu-bsp\\n   git clone --branch master https://github.com/joaohf/meta-fwup-examples\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-fwup\\n   bitbake-layers add-layer ../meta-qemu-bsp\\n   bitbake-layers add-layer ../meta-fwup-examples\\n   ```\\n\\n### Configuring the build environment\\n\\nFor this use case, the quickest way is edit and add the _conf/local.conf_\\nconfiguration file.\\n\\nWe start defining the MACHINE and DISTRO:\\n\\n```bash\\nMACHINE = \\"qemuarm64-uboot\\"\\nDISTRO = \\"poky\\"\\n```\\n\\nThe machine _qemuarm64-uboot_ is provided by\\n[meta-qemu-bsp](https://github.com/meta-erlang/meta-qemu-bsp) layer. That\\nmachine uses u-boot as bootloader.\\n\\nAs YP/OE supports many types of image outputs, we want to be specific here and\\npick only the _fwup_ type.\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# enable support for making fwup images\\nIMAGE_CLASSES += \\"image_types_fwup\\"\\nIMAGE_FSTYPES = \\"fwup fwup.qcow2\\"\\nEOF\\n```\\n\\n:::note\\n\\nThe fwup type is provided by the bbclass\\n[image_types_fwup.bbclass](https://github.com/fwup-home/meta-fwup/blob/master/classes/image_types_fwup.bbclass).\\nIt relies on wic image generator and uses their build artifacts for bootloader\\nand rootfs.\\n\\n:::\\n\\n### Building an image\\n\\nNow that the configuration is over. Let\'s start a build:\\n\\n```bash\\nbitbake core-image-full-cmdline\\n```\\n\\n:::note\\n\\nFor this example, and demonstration purposes, we\'ll use the image called\\n[core-image-full-cmdline](https://git.yoctoproject.org/poky/tree/meta/recipes-core/images/core-image-full-cmdline.bb).\\n\\n:::\\n\\nOnce the build has finished, let\'s inspect the build outputs:\\n\\n```bash\\n$ cd tmp/deploy/images/qemuarm64-uboot\\n\\n$ ls -lh core-image-full-cmdline*.fw\\n-rw-r--r-- 2 joaohf joaohf 71M dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fw\\nlrwxrwxrwx 2 joaohf joaohf  64 dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs.fw -> core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fw\\n\\n$ ls -lh core-image-full-cmdline*fwup*\\n-rw-r--r-- 2 joaohf joaohf 1,1G dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup\\n-rw-r--r-- 2 joaohf joaohf 199M dez 27 17:36 core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup.qcow2\\nlrwxrwxrwx 2 joaohf joaohf   66 dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs.fwup -> core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup\\nlrwxrwxrwx 2 joaohf joaohf   72 dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs.fwup.qcow2 -> core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup.qcow2\\n```\\n\\nThe folder _tmp/deploy/images/qemuarm64-uboot_ has many files generated from the\\nbuild tasks. We are interested on some files only:\\n\\n- The first one with file extension .fw, is the firmware image made by fwup.\\n  We\'ll use this file for A/B upgrades.\\n- And the second file is the [qcow2](https://en.wikipedia.org/wiki/Qcow) Yocto\\n  image suitable for using it with QEMU when running the command `runqemu`.\\n\\n### Running QEMU images with runqemu script\\n\\nThe [runqemu script](https://git.yoctoproject.org/poky/tree/scripts/runqemu) is\\nthe official way for running QEMU with the image previously created. The scripts\\naccepts many QEMU parameters.\\n\\n:::info\\n\\nFor more details about using QEMU with Yocto, check out the official\\ndocumentation:\\n[Using the Quick EMUlator (QEMU)](https://docs.yoctoproject.org/dev-manual/qemu.html)\\n:::\\n\\nFor this tutorial the follow command will be used:\\n\\n```\\nrunqemu core-image-full-cmdline nographic serialstdio wic.qcow2\\n```\\n\\nIt starts QEMU without graphic support and with serial console attached to\\nstdio. The _wic.qcow2_ says to runqemu that we want to boot using the\\n_core-image-full-cmdline-qemuarm64-uboot.rootfs.fwup.qcow2_ image.\\n\\nAfter running the runqemu command, we got:\\n\\n```\\n$ runqemu core-image-full-cmdline nographic serialstdio slirp wic.qcow2\\nrunqemu - INFO - Running bitbake -e  core-image-full-cmdline...\\nrunqemu - INFO - Continuing with the following parameters:\\nMACHINE: [qemuarm64-uboot]\\nFSTYPE: [wic.qcow2]\\nROOTFS: [/data-work/yocto/work/fwup/build/tmp/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs.wic.qcow2]\\nCONFFILE: [/data-work/yocto/work/fwup/build/tmp/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs.qemuboot.conf]\\n\\nrunqemu - INFO - Setting up tap interface under sudo\\nrunqemu - INFO - Network configuration: ip=192.168.7.2::192.168.7.1:255.255.255.0::eth0:off:8.8.8.8 net.ifnames=0\\nrunqemu - INFO - Running /data-work/yocto/work/fwup/build/tmp/work/x86_64-linux/qemu-helper-native/1.0/recipe-sysroot-native/usr/bin/qemu-system-aarch64 -device virtio-net-pci,netdev=net0,mac=52:54:00:1\\n2:34:02 -netdev tap,id=net0,ifname=tap0,script=no,downscript=no -object rng-random,filename=/dev/urandom,id=rng0 -device virtio-rng-pci,rng=rng0 -drive id=disk0,file=/data-work/yocto/work/fwup/build/tmp\\n/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs.wic.qcow2,if=none,format=qcow2 -device virtio-blk-device,drive=disk0 -device qemu-xhci -device usb-tablet -device usb-kbd  -\\nmachine virt -cpu cortex-a57 -smp 4 -m 256 -serial mon:stdio -serial null -nographic -device virtio-gpu-pci -bios /data-work/yocto/work/fwup/build/tmp/deploy/images/qemuarm64-uboot/u-boot.bin\\n\\nrunqemu - INFO - Host uptime: 26648.54\\n\\n\\n\\nU-Boot 2024.10-dirty (Oct 07 2024 - 14:54:35 +0000)\\n\\nDRAM:  256 MiB\\nCore:  52 devices, 14 uclasses, devicetree: board\\nFlash: 64 MiB\\nLoading Environment from VIRTIO_BLK... OK\\nIn:    serial,usbkbd\\nOut:   serial,vidconsole\\nErr:   serial,vidconsole\\nBus xhci_pci: Register 8001040 NbrPorts 8\\nStarting the controller\\nUSB XHCI 1.00\\nscanning bus xhci_pci for devices... 3 USB Device(s) found\\nNet:   eth0: virtio-net#32\\n\\nHit any key to stop autoboot:  0\\nSaving Environment to VIRTIO_BLK... OK\\nboard_name=[qemu-arm] ...\\n21881344 bytes read in 8 ms (2.5 GiB/s)\\nloading qemu.dtb\\n1048576 bytes read in 0 ms\\ndebug: [console=ttyAMA0 root=/dev/vda2] ...\\ndebug: [bootz 0x40200000 - 0x49000000] ...\\n## Flattened Device Tree blob at 49000000\\n   Booting using the fdt blob at 0x49000000\\nWorking FDT set to 49000000\\n   Loading Device Tree to 000000004d491000, end 000000004d593fff ... OK\\nWorking FDT set to 4d491000\\n\\nStarting kernel ...\\n\\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd070]\\n[    0.000000] Linux version 6.12.3-yocto-standard (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 14.2.0, GNU ld (GNU Binutils) 2.43.1.20241111) #1 SMP PREEMPT Thu Dec 12 17:25:00 UTC 2024\\n\\nPoky (Yocto Project Reference Distro) 5.1 qemuarm64-uboot ttyAMA0\\n\\nqemuarm64-uboot login:\\n```\\n\\nThat log above shows some very interesting points:\\n\\n- QEMU was configure with _-bios_ parameter:\\n  ```\\n  -bios /build/tmp/deploy/images/qemuarm64-uboot/u-boot.bin\\n  ```\\n  Which means u-boot will be used as bootloader for linux kernel.\\n- we can check that u-boot support for virtio block device is working as\\n  expected:\\n  ```\\n  ...\\n  Loading Environment from VIRTIO_BLK... OK\\n  ...\\n  Saving Environment to VIRTIO_BLK... OK\\n  ```\\n\\n:::note\\n\\nWhen logged on qemu instance, it\'s necessary to run the command:\\n`ifconfig eth0 192.168.7.2 netmask 255.255.255.0` to setup a IP address to eth0\\ninterface.\\n\\n:::\\n\\n### Inspecting A partition\\n\\n- partition layout:\\n\\n  ```\\n  root@qemuarm64-uboot:~# sfdisk -l /dev/vda\\n  Disk /dev/vda: 1.02 GiB, 1096941568 bytes, 2142464 sectors\\n  Units: sectors of 1 * 512 = 512 bytes\\n  Sector size (logical/physical): 512 bytes / 512 bytes\\n  I/O size (minimum/optimal): 512 bytes / 512 bytes\\n  Disklabel type: dos\\n  Disk identifier: 0x00000000\\n\\n  Device     Boot   Start     End Sectors   Size Id Type\\n  /dev/vda1  *       8192   93035   84844  41.4M  c W95 FAT32 (LBA)\\n  /dev/vda2         93036 1117585 1024550 500.3M 83 Linux\\n  /dev/vda3       1117586 2142135 1024550 500.3M 83 Linux\\n  /dev/vda4       2142136 3190711 1048576   512M 83 Linux\\n  ```\\n\\n- uname\\n  ```\\n  root@qemuarm64-uboot:~# uname -a\\n  Linux qemuarm64-uboot 6.12.3-yocto-standard #1 SMP PREEMPT Thu Dec 12 17:25:00 UTC 2024 aarch64 GNU/Linux\\n  ```\\n- uboot variables:\\n  ```\\n  root@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\\n  nerves_fw_active=a\\n  nerves_fw_validated=1\\n  nerves_fw_booted=1\\n  ```\\n\\n### Moving to B partition\\n\\nAlright, partition A looks fine. Now, we want to run an upgrade using the fwup\\nfirmware image.\\n\\nFrom the build machine:\\n\\n```bash\\n$ cd build/tmp/deploy/images/qemuarm64-uboot\\n$ cat core-image-full-cmdline-qemuarm64-uboot.rootfs.fw | ssh root@192.168.7.2 \'fwup -v -a -U -d /dev/vda -t upgrade.b\'\\nfwup: require-uboot-variable(uboot-env, nerves_fw_active) -> met\\nfwup: require-uboot-variable(uboot-env, nerves_fw_validated) -> met\\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_platform) -> met\\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_architecture) -> met\\nfwup: Upgrading partition B\\n100% [====================================] 73.74 MB in / 570.79 MB out\\nSuccess!\\nElapsed time: 9.758 s\\n```\\n\\nThe important argument is the `-t upgrade.b` telling to fwup which partition\\nwill be upgraded.\\n\\nLet\'s also inspect u-boot environment variables. Because the task upgrade.b\\nshould changed something there:\\n\\n```bash\\nroot@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\\nnerves_fw_active=b\\nnerves_fw_validated=0\\nnerves_fw_booted=0\\n```\\n\\nIndeed, the _nerves_fw_active_ variable has changed.\\n\\nInside qemu, reboot the system using the `reboot` command in order to change the\\npartition.\\n\\nOnce the system come back, let\'s inspect the u-boot environment variables to\\ncheck if those variables are pointing to the B partition now.\\n\\n```bash\\nroot@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\\nnerves_fw_active=b\\nnerves_fw_validated=1\\nnerves_fw_booted=1\\n```\\n\\nAnd they are ok. Not only still pointing to B partition as well validated and\\nbooted.\\n\\nThe lsblk output also proves that vda3 is mounted as root partition:\\n\\n```bash\\nroot@qemuarm64-uboot:~# lsblk\\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\\nvda    253:0    0     1G  0 disk\\n|-vda1 253:1    0  41.4M  0 part /boot\\n|-vda2 253:2    0 500.5M  0 part\\n|-vda3 253:3    0 500.5M  0 part /\\n`-vda4 253:4    0   238K  0 part\\n```\\n\\n### Moving from B to A partition\\n\\nOk, looks like partition B is up and running too.\\n\\nNow, it\'s time to run a second upgrade and moving back to A partition.\\n\\n```bash\\n$ cd build/tmp/deploy/images/qemuarm64-uboot\\n$ cat core-image-full-cmdline-qemuarm64-uboot.rootfs.fw | ssh root@192.168.7.2 \'fwup -v -a -U -d /dev/vda -t upgrade.a\'\\nfwup: require-uboot-variable(uboot-env, nerves_fw_active) -> met\\nfwup: require-uboot-variable(uboot-env, nerves_fw_validated) -> met\\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_platform) -> met\\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_architecture) -> met\\nfwup: Upgrading partition A\\n100% [====================================] 73.74 MB in / 570.79 MB out\\nSuccess!\\nElapsed time: 8.515 s\\n```\\n\\nAgain, checking u-boot variables:\\n\\n```bash\\nroot@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\\nnerves_fw_active=a\\nnerves_fw_validated=0\\nnerves_fw_booted=0\\n```\\n\\nAnd rebooting the system using `reboot` command in order to change the partition\\nto A. After the reboot, let\'s check what is the state of u-boot variables:\\n\\n```bash\\nroot@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\\nnerves_fw_active=a\\nnerves_fw_validated=1\\nnerves_fw_booted=1\\n```\\n\\nThe lsblk output should point vda2 mounted as root partition:\\n\\n```bash\\nroot@qemuarm64-uboot:~# lsblk\\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\\nvda    253:0    0     1G  0 disk\\n|-vda1 253:1    0  41.4M  0 part /boot\\n|-vda2 253:2    0 500.5M  0 part /\\n|-vda3 253:3    0 500.5M  0 part\\n`-vda4 253:4    0   238K  0 part\\n```\\n\\nIt worked as expected. The system is using a rootfs from partition A.\\n\\n## Low level details\\n\\n:::note\\n\\nA bit more Yocto vocabulary.\\n\\n:::\\n\\n### meta-qemu-bsp layer\\n\\nThe [meta-qemu-bsp layer](https://github.com/meta-erlang/meta-qemu-bsp) is a BSP\\n(board support package) type layer. The target is to bring some machines\\nextended from default Yocto QEMU machines.\\n\\nBy default, Yocto brings the following QEMU machines:\\n\\n- ARM (qemuarm + qemuarm64)\\n- x86 (qemux86 + qemux86-64)\\n- PowerPC (qemuppc only)\\n- MIPS (qemumips + qemumips64)\\n\\nThese machines don\'t work with u-boot for instance. In order to enable u-boot,\\nsome configuration are necessary. Thus, the following machine proveded by\\nmeta-qemu-bsp layer were created:\\n\\n- [qemuarm-uboot](https://github.com/meta-erlang/meta-qemu-bsp/blob/master/conf/machine/qemuarm-uboot.conf)\\n- [qemuarm64-uboot](https://github.com/meta-erlang/meta-qemu-bsp/blob/master/conf/machine/qemuarm64-uboot.conf)\\n\\nA WIC file is also provided:\\n[qemuarm-uboot-directdisk.wks](https://github.com/meta-erlang/meta-qemu-bsp/blob/master/wic/qemuarm-uboot-directdisk.wks)\\nand it is used when creating wic images.\\n\\nThe meta-qemu-bsp layer was design to use with any other Yocto layer. It\'s not\\nspecific for fwup use cases.\\n\\n### Patching u-boot\\n\\nThe u-boot bootloader was not prepared to load environment variables from virtio\\nblock device. So, a patch called\\n[Load and save environment from virtio block device](https://github.com/meta-erlang/meta-qemu-bsp/blob/master/recipes-bsp/u-boot/files/0001-Load-and-save-environment-from-virtio-block-device.patch)\\nwas developed.\\n\\nIt allows u-boot to load environment variables from virtio block device reading\\ndata from a specific offset and size. As u-boot already provides support for\\n[virtio](https://docs.u-boot.org/en/stable/develop/driver-model/virtio.html),\\nthe bits needed to load variables from virtio was easy to implement.\\n\\nSo far, this patch was not submited to u-boot upstream project.\\n\\n### fwup examples layer\\n\\nA new layer called\\n[meta-fwup-examples](https://github.com/joaohf/meta-fwup-examples) was developed\\nto hold fwup examples for Yocto images.\\n\\nThe process of enabling Yocto images to use fwup is not so smooth and it depends\\non details like:\\n\\n- partition layout\\n- boot load paramenters\\n- boot load environment scripts\\n- fwup tasks\\n- custom logics\\n\\nThen, each of these details is a combination that works for a specific target\\nboard. Having a dedicated layer with working fwup examples helps for\\ndemonstration and new implementations.\\n\\nThe meta-fwup-examples is also a repository of .fwup description files:\\n\\n- [qemuarm-uboot.fwup](https://github.com/joaohf/meta-fwup-examples/blob/master/fwup/qemuarm-uboot.fwup)\\n- [qemuarm64-uboot.fwup](https://github.com/joaohf/meta-fwup-examples/blob/master/fwup/qemuarm64-uboot.fwup)\\n\\nIt\'s important to mention that I\'m reusing and adapting .fwup files from\\n[Nerves Project](https://github.com/orgs/nerves-project).\\n\\nThe .fwup used for raspberrypi in\\n[fwup for A/B image upgrades, part I](/blog/2024/09/24/index) will be moved to\\nthe layer meta-fwup-examples soon.\\n\\n## Conclusions\\n\\nYes, QEMU machines with u-boot enabled is feasible. And it will help me to\\nreduce time when testing/developing.\\n\\nWhile the [fwup for A/B image upgrades, part I](/blog/2024/09/24/index) blog\\npost discussed fwup and meta-fwup details, this post explored how QEMU could be\\nused instead a real hardware for testing.\\n\\nNow it\'s possible to move fowarding and try some\\n[nerves_hub_link](https://github.com/nerves-hub/nerves_hub_link) high level\\nintegration for A/B upgrades using [nerves-hub](https://www.nerves-hub.org/).\\n\\nBut that will be a topic for further blog posts."},{"id":"/2024/11/03/index","metadata":{"permalink":"/blog/2024/11/03/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-11-03/index.md","source":"@site/blog/2024-11-03/index.md","title":"Introducing Gleam to meta-erlang layer","description":"Gleam is a new language that runs on Erlang VM. As one the","date":"2024-11-03T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"}],"readingTime":4.28,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Introducing Gleam to meta-erlang layer","authors":["joaohf"],"tags":["meta-erlang"]},"unlisted":false,"prevItem":{"title":"fwup for A/B image upgrades on QEMU machines with fwup, part II","permalink":"/blog/2024/12/20/index"},"nextItem":{"title":"Running Erlang/OTP test suite on target with ptest","permalink":"/blog/2024/10/12/index"}},"content":"[Gleam](https://gleam.run) is a new language that runs on Erlang VM. As one the\\naims of meta-erlang layer is to offer support to BEAM ecosystem in YP/OE\\necosystem\\n[gleam support has been added](https://github.com/meta-erlang/meta-erlang/pull/340)\\nto meta-erlang.\\n\\nI\'m not a gleam programming. Actually, I recently discovered gleam (and its\\npurposes). And I\'m still learning it. After watching the talk\\n[Keynote: Gleam\'s Journey on the BEAM - Hayleigh Thompson & Louis Pilfold](https://www.youtube.com/watch?v=6I0IbJtUC3U)\\nat Code BEAM Europe 2024, I give a try and add it to meta-erlang layer.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn this post I\'ll describe a simple experiment using the gleam example code\\ncalled [example-echo-server](https://github.com/gleam-lang/example-echo-server)\\nas it is simple and easy to understand.\\n\\nAt the end of this post we will be ready to create more recipes for programs\\nwritten in glean that runs on Yocto based images.\\n\\nAlso, as gleam is the third language supported by meta-erlang the\\n[beamtools](https://github.com/meta-erlang/meta-erlang/releases) will be updated\\nto also provide a gleam toolchain.\\n\\n## gleam is written in rust\\n\\n[Gleam](https://github.com/gleam-lang/gleam) language is written in rust\\nprogramming language. It could be a challenge to get it working on Yocto.\\nHowever, the support for building rust programs by Yocto has been added many\\nreleases ago (check it out here\\n[Yocto rust support](https://git.yoctoproject.org/poky/tree/meta/recipes-devtools/rust)).\\nThat means all the pieces and rust toolchain support to build gleam inside Yocto\\nwere already there.\\n\\nThe\\n[gleam.bb recipe](https://github.com/meta-erlang/meta-erlang/tree/master/recipes-devtools/gleam/gleam_1.5.1.bb)\\nis responsible for compiling gleam as native program (that is, a program that\\nruns on the build machine). The final gleam package will not be installed in the\\ntarget because gleam compiles to .beam modules (erlang modules). At the end a\\nsoftware written in gleam will be just BEAM modules that runs on Erlang VM.\\n\\nThere is also a new bitbake class called\\n[gleam.bbclass](https://github.com/meta-erlang/meta-erlang/tree/master/classes/gleam.bbclass).\\nIt is a class that every gleam recipe will use in order to fetch dependencies,\\ncompile and packing.\\n\\n## Running gleam on Yocto based images\\n\\nAlright, the following is a step by step listing a fresh build session and run\\nthe hello-gleam-echo-server using QEMU.\\n\\n1. Cloning all repositories for master:\\n\\n   ```bash\\n   git clone --branch master git://git.yoctoproject.org/poky\\n   git clone --branch master https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch master https://github.com/meta-erlang/meta-erlang\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-erlang\\n   ```\\n\\n1. Open the configuration file _build/local.conf_ and change the \'MACHINE\'\\n   variable to \'qemux86-64\'\\n\\n1. Add what we want to install, hello-gleam-echo-server:\\n\\n   ```\\n   tee -a <<EOF conf/local.conf\\n   IMAGE_INSTALL:append = \\" hello-gleam-echo-server curl\\"\\n   EOF\\n   ```\\n\\n   Let\'s install curl too. Because we want to check if echo-server is working as\\n   expected.\\n\\n1. Build a minimal image for testing purposes:\\n\\n   ```bash\\n   bitbake core-image-minimal\\n   ```\\n\\n   Depending your build machine it could take some time. It\'s ok. Remember that\\n   YP/OE builds everything from source code.\\n\\n1. Let\'s test running the QEMU:\\n\\n   ```bash\\n   runqemu core-image-minimal serialstdio nographic slirp\\n   ```\\n\\n1. You should see the login prompt after running the runqemu command:\\n\\n   ```\\n   Poky (Yocto Project Reference Distro) 5.1 qemux86-64 ttyS0\\n\\n   qemux86-64 login:\\n   ```\\n\\n   The login name is root\\n\\n1. The command `systemctl status hello-gleam-echo-server` shows that echo-server\\n   is disabled and not running\\n\\n   ```\\n   root@qemux86-64:~# systemctl status hello-gleam-echo-server\\n   * hello-gleam-echo-server.service - gleam echo server example\\n     Loaded: loaded (/usr/lib/systemd/system/hello-gleam-echo-server.service; disabled; preset: disabled)\\n     Active: inactive (dead)\\n   ```\\n\\n   Let\'s start it with `systemctl start hello-gleam-echo-server`\\n\\n   ```\\n   root@qemux86-64:~# systemctl start hello-gleam-echo-server\\n   ```\\n\\n   And check again with `systemctl status`\\n\\n   ```\\n   root@qemux86-64:~# systemctl status hello-gleam-echo-server\\n   * hello-gleam-echo-server.service - gleam echo server example\\n     Loaded: loaded (/usr/lib/systemd/system/hello-gleam-echo-server.service; disabled; preset: disabled)\\n     Active: active (running) since Mon 2024-11-04 00:26:37 UTC; 1s ago\\n     Invocation: 721b391508544a27bdacd484d3f35be3\\n     Main PID: 239 (entrypoint.sh)\\n      Tasks: 26 (limit: 255)\\n     Memory: 51.1M (peak: 51.5M)\\n        CPU: 3.043s\\n     CGroup: /system.slice/hello-gleam-echo-server.service\\n             |-239 /bin/sh /usr/lib/hello-gleam-echo-server/entrypoint.sh run\\n             |-241 /usr/lib/erlang/erts-15.1.2/bin/beam.smp -- -root /usr/lib/erlang -bindir /usr/lib/erlang/erts-15.1.2/bin -progname erl -- -- -pa /usr/lib/hello-gleam-echo-server/elli/ebin /usr/lib/hello-gleam-echo-server/gleam_e...\\n             `-247 erl_child_setup 1024\\n\\n   Nov 04 00:26:37 qemux86-64 systemd[1]: Started gleam echo server example.\\n   ```\\n\\n   That looks really good. We can see that systemd is happy and tracking the\\n   beam.smp process.\\n\\n1. Calling curl to check if echo-server is working. We want to reach the\\n   function hello from\\n   [web.gleam](https://github.com/gleam-lang/example-echo-server/blob/main/src/reply/web.gleam#L32)\\n   source code:\\n\\n   ```bash\\n   root@qemux86-64:~# curl -X POST -d \'Hello, Gleam!\' http://localhost:3000/echo\\n   Hello, Gleam!\\n   ```\\n\\nThat\'s amazing and it\'s working as expected.\\n\\n## hello-gleam-echo-server explained\\n\\nA bit more about bitbake, recipes and how gleam recipes works.\\n\\nThe snippet below shows the recipe\\n[hello-gleam-echo-server](https://github.com/meta-erlang/meta-erlang/tree/master/recipes-examples/hello-gleam-echo-server/hello-gleam-echo-server_0.1.0.bb).\\nThanks to gleam.bbclass the recipe is short and declarative.\\n\\n```\\nSUMMARY = \\"An example Gleam web application \\"\\nSECTION = \\"examples\\"\\nLICENSE = \\"Apache-2.0\\"\\nLIC_FILES_CHKSUM = \\"file://LICENCE;md5=bd052113ed5b73a32ff7cf9f42c3265c\\"\\n\\nS = \\"${WORKDIR}/git\\"\\n\\nSRCREV = \\"94f29a84dc82ed4e7878d4027fd27acacdb8be84\\"\\nPV = \\"0.1.0+git${SRCPV}\\"\\nSRC_URI = \\"git://github.com/gleam-lang/example-echo-server;branch=main;protocol=https \\\\\\n           file://hello-gleam-echo-server.service\\"\\n\\ninherit gleam systemd\\n\\ndo_install:append() {\\n    if ${@bb.utils.contains(\'DISTRO_FEATURES\',\'systemd\',\'true\',\'false\',d)}; then\\n        install -d ${D}${systemd_unitdir}/system\\n        install -m 0644 ${UNPACKDIR}/hello-gleam-echo-server.service ${D}${systemd_unitdir}/system\\n    fi\\n}\\n\\nSYSTEMD_SERVICE:${PN} = \\"hello-gleam-echo-server.service\\"\\n\\nSYSTEMD_AUTO_ENABLE = \\"disable\\"\\n```\\n\\nThis recipe instructs bitbake to fetch the example-echo-server source code,\\nbuild it and install some systemd scripts in order to start the\\nexample-echo-server on target machine.\\n\\nThe systemd script is very simple:\\n\\n```\\n[Unit]\\nDescription=gleam echo server example\\n\\n[Service]\\nWorkingDirectory=/usr/lib/hello-gleam-echo-server\\nExecStart=/usr/lib/hello-gleam-echo-server/entrypoint.sh run\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nIt just \\"runs\\" the entrypoint.sh script. The entrypoint.sh was created by gleam\\ntooling. The recipe takes care of installing the echo-server artifacts at\\n_/usr/lib/hello-gleam-echo-server_.\\n\\nFor more details, I recommend checking out the bitbake class\\n[gleam.bbclass](https://github.com/meta-erlang/meta-erlang/tree/master/classes/gleam.bbclass)."},{"id":"/2024/10/12/index","metadata":{"permalink":"/blog/2024/10/12/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-10-12/index.md","source":"@site/blog/2024-10-12/index.md","title":"Running Erlang/OTP test suite on target with ptest","description":"ptest (package test) means packaging and installing runtime tests that are","date":"2024-10-12T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"}],"readingTime":5.85,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Running Erlang/OTP test suite on target with ptest","authors":["joaohf"],"tags":["meta-erlang"]},"unlisted":false,"prevItem":{"title":"Introducing Gleam to meta-erlang layer","permalink":"/blog/2024/11/03/index"},"nextItem":{"title":"Anatomy of erlang and elixir packages for YP/OE","permalink":"/blog/2024/10/06/index"}},"content":"ptest (package test) means packaging and installing runtime tests that are\\nincluded in many upstream packages. At the end of the day it runs Erlang/OTP\\ncross compiled test suite on the target hardware. The aim is to detect a range\\nof problems when running test suites on different combinations of architecture\\nprocessors and libc.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe Erlang/OTP howto about\\n[TESTING.md](https://github.com/erlang/otp/blob/master/HOWTO/TESTING.md)\\nexplains most of the details when running tests. While the Yocto\'s documentation\\nabout\\n[Testing Packages With ptest](https://docs.yoctoproject.org/dev-manual/packages.html#testing-packages-with-ptest)\\nexplains the ptest configuration.\\n\\nSo, this post is about how to run those tests using ptest approach on Yocto\\nbuilds.\\n\\n## How does ptest work ?\\n\\nRecipes with ptest enabled includes a shell script called _run-ptest_ with the\\nsteps necessary to start the test suite provided by the target software (e.g.:\\nErlang/OTP).\\n\\nThe run-ptest script is responsible for starting the test suite and\\nconsolidating the test results into a single format. The format is the\\n[automake simple test](https://www.gnu.org/software/automake/manual/automake.html#Simple-Tests)\\nformat:\\n\\n```\\nresult: testName\\n```\\n\\nWhere: _result_ is one of PASS, FAIL or SKIP and _testName_ can be anything.\\n\\nThe erlang recipe from meta-erlang layer supports ptest. And, when activated,\\nthe package erlang-ptest is installed into the final image. It has the erlang\\ntest suite cross compiled and ready to be executed.\\n\\nWhen ptest for erlang recipe gets executed, it finishes the erlang test suite\\nconfiguration and starts to run each test configured in run-ptest script.\\n\\nThe Erlang/OTP requires several hours to finish. Because of that, ptest for\\nerlang just executes a small set of all tests available (currently only\\n_emulator_ and _kernel_ tests are enabled).\\n\\n:::note\\n\\nTo get a better idea about how to run Erlang/OTP test suites the documentation\\n[TESTING.md](https://github.com/erlang/otp/blob/master/HOWTO/TESTING.md),\\nspecially the session Running the tests.\\n\\n:::\\n\\nThe erlang-ptest package installs the test suite and also the run-ptest script\\nat _/usr/lib/erlang/ptest_ folder.\\n\\nOne point very important is that Erlang/OTP test suites need some tools\\ninstalled into the target image in order to execute some tests. For example, to\\nrun emulator and kernel tests the target OS needs tmux and openssh packages.\\nHowever the erlang recipe takes care of these details.\\n\\nEach test suite might require additional packages. As there is no documentation\\ndescribing all the requirements the best strategy is to inspect the test suite\\nfor each Erlang/OTP application\\n([lib/\\\\*/test](https://github.com/erlang/otp/tree/master/lib) and\\n[erts/test](https://github.com/erlang/otp/tree/master/erts/test) folders).\\n\\n## Running Erlang/OTP ptest\\n\\nYocto provides some configuration when enabling ptest. As it is only relevant\\nfor testing purposes.\\n\\nA specific image feature exists that enables ptest. So, in the local.conf\\nconfiguration file:\\n\\n```\\n# ptest image\\nEXTRA_IMAGE_FEATURES += \\"ptest-pkgs\\"\\n```\\n\\nThis is all that is necessary to do in order to enable ptest build.\\n\\nAs we want to install erlang in the final image, we also need to add it to the\\nfinal image. On build/local.conf configuration file:\\n\\n```\\n# installing erlang and elixir\\nIMAGE_INSTALL:append:pn-core-image-minimal = \\" erlang erlang-modules-dev elixir elixir-modules-dev links\\"\\n```\\n\\n:::note\\n\\nThe _links_ package here is necessary to open HTML common test reports from\\nconsole.\\n\\n:::\\n\\nIt\'s ready to build the core-image-minimal image:\\n\\n```\\nbitbake core-image-minimal\\n```\\n\\nAnd, for testing purposes, run the generated image using qemu emulator:\\n\\n```\\nrunqemu slirp kvm nographic serialstdio core-image-minimal\\n```\\n\\nLogging into the running system and execute ptest for erlang:\\n\\n```\\nPoky (Yocto Project Reference Distro) 5.1 qemux86-64 ttyS0\\n\\nqemux86-64 login: root\\n\\nWARNING: Poky is a reference Yocto Project distribution that should be used for\\ntesting and development purposes only. It is recommended that you create your\\nown distribution for production use.\\n\\nroot@qemux86-64:~# ptest-run erlang\\n```\\n\\nThe script /usr/lib/erlang/ptest/run-ptest starts execute controlled by the\\napplication called [ptest runner](https://git.yoctoproject.org/ptest-runner2/).\\nAfter several hours we get the following results:\\n\\n```\\nSTART: ptest-runner\\n2024-10-14T17:15\\nBEGIN: /usr/lib/erlang/ptest\\n\\nFAIL: emulator\\n... lots of console messages ...\\nFAIL: kernel\\n... lots of console messages ...\\n\\n=== common test Summary ===\\nTesting tests.emulator_test: TEST COMPLETE, 2112 ok, 4 failed, 82 skipped of 2198 test cases\\nTesting tests.kernel_test: TEST COMPLETE, 1338 ok, 20 failed, 293 skipped of 1651 test cases\\n=== Test Summary ===\\nTOTAL: 2\\nPASSED: 0\\nFAILED: 2\\nDURATION: 5822\\nEND: /usr/lib/erlang/ptest\\n2024-10-14T01:39\\nSTOP: ptest-runner\\nTOTAL: 1 FAIL: 0\\n```\\n\\nWell, we got 4 fails for emulator tests and 20 fails for kernel tests. Not bad,\\nbut I don\'t know if it is also good.\\n\\nFor further inspection, it\'s possible to also check output messages for each\\ntest. The run-ptest script writes a specific log console for each test executed:\\n\\n```\\nroot@qemux86-64:~# ls /usr/lib/erlang/ptest/ -l\\ntotal 14680\\n-rw-r--r--  1 root root   236964 Oct 14 00:40 erlang_ptest_emulator_20241014-000215.log\\n-rw-r--r--  1 root root 14770546 Oct 14 01:39 erlang_ptest_kernel_20241014-004016.log\\n-rwxr-xr-x  1 root root      807 Oct 14 00:01 run-ptest\\ndrwxr-xr-x 39 root root     4096 Apr  5  2011 tests\\n\\n```\\n\\nAs usual when running common tests (remember Erlang/OTP test suites are just\\ncommon tests), the HTML reports were written at\\n_/usr/lib/erlang/ptest/tests/test_server/index.html_. Opening it with links\\ncommand to check the results:\\n\\n```\\nlinks /usr/lib/erlang/ptest/tests/test_server/index.html\\n```\\n\\nptest produces a lot of data to inspect.\\n\\n## Running Elixir ptest\\n\\nThe steps for running elixir ptest are almost the same for erlang. We just call\\nptest-run with the argument elixir:\\n\\n```\\nroot@qemux86-64:~# ptest-run elixir\\n```\\n\\nThe above command runs elixir ptest and reports some results:\\n\\n```\\nSTART: ptest-runner\\n2024-10-18T02:27\\nBEGIN: /usr/lib/elixir/ptest\\nPASS: erlang\\nFAIL: stdlib\\nPASS: ex_unit\\nFAIL: logger\\nPASS: eex\\nFAIL: mix\\nFAIL: iex\\n=== Test Summary ===\\nTOTAL: 7\\nPASSED: 3\\nFAILED: 4\\nDURATION: 148\\nEND: /usr/lib/elixir/ptest\\n2024-10-18T02:30\\nSTOP: ptest-runner\\nTOTAL: 1 FAIL: 0\\n```\\n\\nFor further inspection, it\'s possible to also check output messages for each\\ntest. The run-ptest script writes a specific log console for each test executed:\\n\\n```\\nroot@qemux86-64:~# ls /usr/lib/elixir/ptest/ -l\\ntotal 64\\ndrwxr-xr-x 6 root root  4096 Apr  5  2011 elixir\\n-rw-r--r-- 1 root root   840 Oct 18 02:28 elixir_ptest_eex_20241018-022812.log\\n-rw-r--r-- 1 root root   323 Oct 18 02:27 elixir_ptest_erlang_20241018-022744.log\\n-rw-r--r-- 1 root root  1156 Oct 18 02:28 elixir_ptest_ex_unit_20241018-022806.log\\n-rw-r--r-- 1 root root  4230 Oct 18 02:30 elixir_ptest_iex_20241018-023005.log\\n-rw-r--r-- 1 root root  2648 Oct 18 02:28 elixir_ptest_logger_20241018-022810.log\\n-rw-r--r-- 1 root root 11243 Oct 18 02:30 elixir_ptest_mix_20241018-022814.log\\n-rw-r--r-- 1 root root 16895 Oct 18 02:28 elixir_ptest_stdlib_20241018-022745.log\\n-rwxr-xr-x 1 root root   950 Oct 18 02:27 run-ptest\\n```\\n\\nAgain, ptest produces a lot of data to inspect.\\n\\n## Why running ptest for Erlang/OTP on Yocto builds is important ?\\n\\nNow that we know what is ptest. Given the following question:\\n\\n> How do we know that a cross compiled Erlang/OTP build really works on the\\n> target hardware ?\\n\\nThe answer could be: testing it using tests provided by Erlang/OTP source code.\\n\\nSo, ptest is great for detecting problems.\\n\\nAs ptest has the ability of running Erlang/OTP test suites on the final image\\nand reporting the results, we can get a baseline when comparing tests executed\\non different combinations of processor architectures and C standard libraries\\n(libc) or any other aspect like different linux kernel versions. It\'s possible\\nto detect regressions or find weak spots not covered by tests in a specific\\nplatform.\\n\\nAlso, the mechanism of executing those tests is simple. The user does not need\\nto be an Erlang expert to check that something is not ok on some platform."},{"id":"/2024/10/06/index","metadata":{"permalink":"/blog/2024/10/06/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-10-06/index.md","source":"@site/blog/2024-10-06/index.md","title":"Anatomy of erlang and elixir packages for YP/OE","description":"Usually, when designing a linux distribution using YP/OE we want a slim image","date":"2024-10-06T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"x32","permalink":"/blog/tags/x-32"}],"readingTime":7.845,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Anatomy of erlang and elixir packages for YP/OE","authors":["joaohf"],"tags":["meta-erlang","x32"]},"unlisted":false,"prevItem":{"title":"Running Erlang/OTP test suite on target with ptest","permalink":"/blog/2024/10/12/index"},"nextItem":{"title":"fwup for A/B image upgrades, part I","permalink":"/blog/2024/09/24/index"}},"content":"Usually, when designing a linux distribution using YP/OE we want a slim image\\nwith only what we need to run a specific application (or applications). In this\\npost we\'ll discuss a bit about erlang and elixir packages that meta-erlang layer\\nprovides.\\n\\nIt\'s important to know how the packages are divided into smaller ones in order\\nto offer a better composition when creating linux distributions with YP/OE.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Environment setup\\n\\n1. Cloning all repositories for master branch:\\n\\n   ```bash\\n   git clone --branch master git://git.yoctoproject.org/poky\\n   git clone --branch master https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch master https://github.com/meta-erlang/meta-erlang\\n   git clone --branch master https://github.com/meta-erlang/meta-axon\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-erlang\\n   bitbake-layers add-layer ../meta-axon\\n   ```\\n\\n1. Configure the `conf/local.conf` and enable multiconfig builds:\\n\\n   ```bash\\n   tee -a <<EOF\\n   # debug-tweaks\\n   EXTRA_IMAGE_FEATURES ?= \\"debug-tweaks\\"\\n   USER_CLASSES ?= \\"buildhistory buildstats\\"\\n   BUILDHISTORY_COMMIT = \\"1\\"\\n   PACKAGE_CLASSES = \\"package_ipk\\"\\n   PATCHRESOLVE = \\"noop\\"\\n   INHERIT += \\"rm_work\\"\\n   RM_WORK_EXCLUDE = \\"erlang erlang-native nativesdk-erlang\\"\\n\\n   # diskmon\\n   BB_DISKMON_DIRS = \\"\\\\\\n       STOPTASKS,${TMPDIR},1G,100K \\\\\\n       STOPTASKS,${DL_DIR},1G,100K \\\\\\n       STOPTASKS,${SSTATE_DIR},1G,100K \\\\\\n       STOPTASKS,/tmp,100M,100K \\\\\\n       HALT,${TMPDIR},100M,1K \\\\\\n       HALT,${DL_DIR},100M,1K \\\\\\n       HALT,${SSTATE_DIR},100M,1K \\\\\\n       HALT,/tmp,10M,1K\\"\\n\\n   # general config\\n   SDKMACHINE = \\"x86_64\\"\\n\\n   # local\\n   CONNECTIVITY_CHECK_URIS = \\"https://www.google.com/\\"\\n\\n   # master\\n\\n   # qemu configuration\\n   PACKAGECONFIG:append:pn-qemu-system-native = \\" sdl\\"\\n   PACKAGECONFIG:append:pn-qemu-system-native = \\" gtk+\\"\\n\\n   # systemd only\\n   INIT_MANAGER = \\"systemd\\"\\n\\n   MACHINE ??= \\"qemuarm\\"\\n   DISTRO ??= \\"poky\\"\\n   BBMULTICONFIG ?= \\"qemux86-64-erlang-elixir qemuarm64-erlang-elixir qemuarm-erlang-elixir qemux86-erlang-elixir qemux86-64-x32-erlang-elixir\\"\\n\\n   # To disable QA checks for https://github.com/meta-erlang/meta-erlang/issues/328\\n   ERROR_QA:remove = \\"buildpaths\\"\\n\\n   EOF\\n   ```\\n\\n## multiconfig build\\n\\nYP/OE provides a smart way to build the same image (or different images) for\\nmultiple targets. It is called multiconfig build and it is fully described at\\n[Building Images for Multiple Targets Using Multiple Configurations](https://docs.yoctoproject.org/dev-manual/building.html?highlight=multiconfig#building-images-for-multiple-targets-using-multiple-configurations).\\n\\nFour our context, don\'t forget to checkout the section\\n[Environment setup](#environment-setup), we need to compare the erlang and\\nelixir packages using different processor architectures (_MACHINES_ in YP/OE\\nlanguage).\\n\\nWe can build five targets using the command below:\\n\\n```bash\\nbitbake -c build \\\\\\n    multiconfig:qemux86-64-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemux86-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemuarm-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemuarm64-erlang-elixir:core-image-minimal \\\\\\n    multiconfig:qemux86-64-x32-erlang-elixir:core-image-minimal\\n\\n```\\n\\nThe multiconfig build was configured to create a specific TMPDIR for each\\nprocessor architecture. Then, the final results at build folder will be one\\nfolder for each architecture:\\n\\n```bash\\ntmp-qemuarm64-glibc-erlang-elixir\\ntmp-qemuarm-glibc-erlang-elixir\\ntmp-qemux86-64-glibc-erlang-elixir\\ntmp-qemux86-64-glibc-x32-erlang-elixir\\ntmp-qemux86-glibc-erlang-elixir\\n```\\n\\nThat way, it\'s easy to navigate into the final output files.\\n\\n## Introspection with buildhistory\\n\\nThe buildhistory is a YP/OE feature that writes some meta data into a git\\nrepository for further inspection. Then, it\'s possible check and interact with\\nfiles using standard linux tools like find and grep to collect insights. Using\\nbuildhistory is a shortcut because we can inspect how files would be installed\\ninto the final image, without having to burn the image and boot it on a real (or\\nvirtual) target.\\n\\n\x3c!-- prettier-ignore-start --\x3e\\n:::note\\nCheck out the\\n[Enabling and Disabling Build History](https://docs.yoctoproject.org/5.0.3/dev-manual/build-quality.html?highlight=buildhistory#enabling-and-disabling-build-history)\\ninstructions for how to enable buildhistory.\\n:::\\n\x3c!-- prettier-ignore-end --\x3e\\n\\nIn this post we are interested in check the size of erlang and elixir packages.\\n\\nAfter a success build and from the YP/OE build folder, it\'s possible to explore\\nthe buildhistory git repository:\\n\\n```bash\\ncd buildhistory/packages/cortexa57-poky-linux/erlang\\nfind -name latest -print0 | xargs -0 grep PKGSIZE | sort\\n...\\n\\ncd -\\ncd buildhistory/packages/cortexa57-poky-linux/elixir\\nfind -name latest -print0 | xargs -0 grep PKGSIZE | sort\\n...\\n```\\n\\n`PKGSIZE` gives to us the size in bytes of the final packages generated by\\nerlang and elixir recipes.\\n\\n## YP/OE packaging for erlang and elixir recipes\\n\\nThe nature of Erlang/OTP is to isolate erlang modules into applications. The\\nErlang/OTP source code embraces this philosophy and it is natural to transform\\neach application into an installed package (IPK, DEB, RPM). For that,\\nmeta-erlang uses a simple script that creates a recipe manifest (see\\n[erlang recipe manifest](https://github.com/meta-erlang/meta-erlang/blob/cb94887c108b63c6cba290cb019468f246df5ea4/scripts/contrib/erlang/generate-manifest#L76)\\nfor details).\\n\\nAn erlang recipe manifest, for example\\n[erlang-27.1-manifest.inc](https://github.com/meta-erlang/meta-erlang/blob/cb94887c108b63c6cba290cb019468f246df5ea4/recipes-devtools/erlang/erlang-27.1-manifest.inc),\\ndeclares each Erlang/OTP application. For each application there are five\\npackages:\\n\\n- `application_name-doc`: documentation, man pages and examples\\n- `application_name-dbg`: debug symbols, if any\\n- `application_name-dev`: development C headers, shared libraries (\\\\*.so)\\n- `application_name-staticdev`: static libraries (\\\\*.a)\\n- `application_name`: BEAM modules and files from `priv` folder\\n\\nWhere `application_name` is the name of the application like: kernel, stdlib,\\nsasl, ...\\n\\nThis separation is necessary because YP/OE splits the package of any recipe into\\ndoc, dbg, dev and staticdev. Then, the user have more control about what will be\\ninstalled into the final image.\\n\\nThe elixir recipe follows the same way, but simpler (check out the\\n[elixir.inc](https://github.com/meta-erlang/meta-erlang/blob/cb94887c108b63c6cba290cb019468f246df5ea4/recipes-devtools/elixir/elixir.inc)\\ninclude file).\\n\\n### Special metapackages\\n\\nAs there are many packages for erlang and elixir, sometimes we need to setup a\\ndevelopment environment will all erlang and elixir packages installed. Or a\\nminimum set of packages. There are a couple of metapackages created for that\\npurpose:\\n\\n- erlang-modules: install _all_ Erlang/OTP applications\\n- erlang-modules-dev: install _all_ Erlang/OTP applications development packages\\n- elixir-modules: install _all_ elixir applications\\n- elixir-modules-dev: install _all_ elixir applications development packages\\n- erlang: install the minimal Erlang/OTP applications\\n- elixir: install the minimal elixir applications\\n\\n### Where the files get installed ?\\n\\nThe best way to awnser this is to take a look into buildhistory data.\\n\\nAt the build folder there is a folder called buildhistory. That folder is split\\nby images and packages. And for each architecture, there is a specific folder.\\nSo, let\'s check the first 20 lines from file: files-in-packages.txt for\\nerlang-erts package:\\n\\n```bash\\nhead -n 20 buildhistory/packages/core2-32-poky-linux/erlang/erlang-erts/files-in-package.txt\\ndrwxr-xr-x root       root             4096 ./usr\\ndrwxr-xr-x root       root             4096 ./usr/bin\\nlrwxrwxrwx root       root               22 ./usr/bin/epmd -> ../lib/erlang/bin/epmd\\nlrwxrwxrwx root       root               21 ./usr/bin/erl -> ../lib/erlang/bin/erl\\nlrwxrwxrwx root       root               25 ./usr/bin/escript -> ../lib/erlang/bin/escript\\nlrwxrwxrwx root       root               25 ./usr/bin/run_erl -> ../lib/erlang/bin/run_erl\\nlrwxrwxrwx root       root               24 ./usr/bin/to_erl -> ../lib/erlang/bin/to_erl\\ndrwxr-xr-x root       root             4096 ./usr/lib\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang\\ndrwxr-xr-x root       root             4096 ./usr/lib/erlang/bin\\nlrwxrwxrwx root       root               21 ./usr/lib/erlang/bin/epmd -> ../erts-15.1/bin/epmd\\n-rwxr-xr-x root       root             1474 ./usr/lib/erlang/bin/erl\\n-rwxr-xr-x root       root           140752 ./usr/lib/erlang/bin/erl_call\\n-rwxr-xr-x root       root            38456 ./usr/lib/erlang/bin/escript\\n-rw-r--r-- root       root             6860 ./usr/lib/erlang/bin/no_dot_erlang.boot\\n-rwxr-xr-x root       root            25996 ./usr/lib/erlang/bin/run_erl\\n-rwxr-xr-x root       root             1745 ./usr/lib/erlang/bin/start\\n-rw-r--r-- root       root             6885 ./usr/lib/erlang/bin/start.boot\\n-rw-r--r-- root       root             6885 ./usr/lib/erlang/bin/start_clean.boot\\n-rwxr-xr-x root       root             1244 ./usr/lib/erlang/bin/start_erl\\n```\\n\\n## erlang package sizes\\n\\nWhen installing the metapackage called `erlang` the following packages will be\\nautomatically installed:\\n\\n- erlang-erts\\n- erlang-kernel\\n- erlang-stdlib\\n- erlang-sasl\\n\\nThese packages are the basic ones needed in order to run Erlang programs.\\n\\n\x3c!-- prettier-ignore-start --\x3e\\n:::note\\nActually, your application is in charge of making a proper Erlang/OTP\\nrelease. Installing the package `erlang` is an option if you need it installed\\ninto standard locations. Otherwise, your application should produce a valide\\nrelease with a builtin ERTS inside.\\n:::\\n\x3c!-- prettier-ignore-end --\x3e\\n\\nThe following charts are listed below to get a view about the size of those\\nbasic erlang packages.\\n\\nThe difference between each build, besides the processor architecture, is the\\nsize in bytes of the package erlang-erts. That makes sense because that package\\nis the ERTS (which is architecture dependent, like word size). On other hand,\\nthe packages kernel, stdlib, sasl have the same size across all builds.\\n\\n### qemux86\\n\\n```bash\\nbitbake -c build multiconfig:qemux86-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"core2-32-poky-linux (qemux86)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [5585259, 3421584, 7062547, 439445]\\n```\\n\\n### qemux86-64\\n\\n```bash\\nbitbake -c build multiconfig:qemux86-64-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"core2-64-poky-linux (qemux86-64)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [9472359, 3421584, 7062547, 439445]\\n```\\n\\n### qemux86-64 with x32 psABI\\n\\n```bash\\nbitbake -c build multiconfig:x86_64_x32-poky-linux-gnux32:core-image-minimal\\n```\\n\\n\x3c!-- prettier-ignore-start --\x3e\\n:::note\\nEnabling x32 psABI should be considered if your application needs to\\nhandle 64-bit features, but you can\'t afford wasting space with addressing. See\\nthe blog post [Exploring x32 psABI for Erlang/OTP](/blog/2023/09/02/index).\\n\\nThe package size difference in bytes between x32 build and a normal x86-64\\nis 4615556.\\n:::\\n\x3c!-- prettier-ignore-end --\x3e\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"x86_64_x32-poky-linux-gnux32 (qemux86-64 x32 psABI)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [4856803, 3421584, 7062547, 439445]\\n```\\n\\n### qemuarm64\\n\\n```bash\\nbitbake -c build multiconfig:qemuarm64-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"cortexa57-poky-linux (qemuarm64)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [6400695, 3421584, 7062547, 439445]\\n```\\n\\n### qemuarm\\n\\n```bash\\nbitbake -c build multiconfig:qemuarm-erlang-elixir:core-image-minimal\\n```\\n\\n```mermaid\\n---\\nconfig:\\n    xyChart:\\n        width: 900\\n        height: 600\\n    themeVariables:\\n        xyChart:\\n            titleColor: \\"#ff0000\\"\\n---\\nxychart-beta\\n    title \\"cortexa15t2hf-neon-poky-linux-gnueabi (qemuarm)\\"\\n    x-axis \\"package name\\" [erts, kernel, stdlib, sasl]\\n    y-axis \\"package size in bytes\\"\\n    bar [3653615, 3421584, 7062547, 439445]\\n```\\n\\n## elixir package sizes\\n\\nWhen installing the metapackage called `elixir` the following packages will be\\nautomatically installed:\\n\\n- erlang (see [erlang package size for details](#erlang-package-sizes))\\n- erlang-compiler\\n\\nThat is because elixir package needs erlang (erts, kernel, stdlib and sasl)\\ninstalled. And, the erlang compiler is also a requirement.\\n\\n\x3c!-- prettier-ignore-start --\x3e\\n:::note\\nAgain, your application should manage a release for best results.\\nInstalling the package `elixir` only makes sense for testing purposes.\\n:::\\n\x3c!-- prettier-ignore-end --\x3e\\n\\nThe following table summarizes the packages sizes per processor architecture.\\n\\n| Processor architecture                | Package size in bytes |\\n| ------------------------------------- | --------------------- |\\n| core2-32-poky-linux (qemux86)         | 5760108               |\\n| core2-64-poky-linux (qemux86-64)      | 5760368               |\\n| qemux86-64-x32-erlang-elixir          | 5763392               |\\n| cortexa57-poky-linux (qemuarm64)      | 5760476               |\\n| cortexa15t2hf-neon-poky-linux-gnueabi | 5764076               |\\n\\nThere are slight size differences. It should not as there is no architecture\\ndependency on elixir beam files."},{"id":"/2024/09/24/index","metadata":{"permalink":"/blog/2024/09/24/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-09-24/index.md","source":"@site/blog/2024-09-24/index.md","title":"fwup for A/B image upgrades, part I","description":"This blog post is a tutorial about how to make A/B software updates with fwup","date":"2024-09-24T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"fwup","permalink":"/blog/tags/fwup"}],"readingTime":9.015,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"fwup for A/B image upgrades, part I","authors":["joaohf"],"tags":["meta-erlang","fwup"]},"unlisted":false,"prevItem":{"title":"Anatomy of erlang and elixir packages for YP/OE","permalink":"/blog/2024/10/06/index"},"nextItem":{"title":"New Erlang releases 27.0","permalink":"/blog/2024/05/31/index"}},"content":"This blog post is a tutorial about how to make A/B software updates with fwup\\ntool and Yocto Project.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Objectives and Tools\\n\\nA short sentence as requirement for this tutorial is:\\n\\n> I wish to make an image using Yocto Project and be able to run software\\n> updates using A/B approach.\\n\\nThere are many references on the Internet for A/B software updates. It\'s a\\nwell-known approach with many different implementations. In short it\'s strategy\\nto minimize downtime when changing the firmware of embedded devices. While the\\nnew software gets written to the unused slot and the current slot is still\\nrunning. When everything are ready to swap, the system gets restarted. Booting\\nusing the unused slot (now it becomes the current slot).\\n\\nSo, in this blog post we are going to play with A/B software updates using fwup\\ntool.\\n\\n## What is fwup ?\\n\\nThe best [fwup](https://github.com/fwup-home/fwup) definition is from its\\nofficial project home:\\n\\n> fwup is a configurable image-based software update utility for embedded\\n> Linux-based systems. It primarily supports software upgrade strategies that\\n> update entire root filesystem images at once. This includes strategies like\\n> swapping back and forth between A and B partitions, recovery partitions, and\\n> various trial update/failback scenarios. All software update information is\\n> combined into a ZIP archive that may optionally be cryptographically signed.\\n> fwup has minimal dependencies and runtime requirements. Scripts are\\n> intentionally limited to make failure scenarios easier to reason about.\\n> Distribution of software update archives is not a feature. Users can call out\\n> to fwup to run upgrades from external media, stream them from the network, or\\n> script them using a tool like Ansible if so desired.\\n\\nIn practice, fwup is simple and easy to use.\\n\\n## YP/OE setup\\n\\nI\'ll try to simplify the YP/OE setup to just tree small steps:\\n\\n:::note\\n\\nThe YP documentation is very good. I strong recommend its reading. For this\\nsection the release version used is\\n[scarthgap](https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html).\\n\\nOne important point is to double check the\\n[Required Packages for the Build Host](https://docs.yoctoproject.org/ref-manual/system-requirements.html#required-packages-for-the-build-host.)\\n\\n:::\\n\\n1. Cloning all repositories for scarthgap release:\\n\\n   ```bash\\n   git clone --branch scarthgap git://git.yoctoproject.org/poky\\n   git clone --branch scarthgap https://github.com/openembedded/meta-openembedded.git\\n   git clone --branch scarthgap https://github.com/fwup-home/meta-fwup\\n   git clone --branch scarthgap https://github.com/meta-erlang/meta-erlang\\n   git clone --branch scarthgap https://github.com/meta-erlang/meta-axon\\n   git clone --branch scarthgap https://github.com/agherzan/meta-raspberrypi\\n   ```\\n\\n1. Source the init build environment script:\\n\\n   ```bash\\n   cd poky\\n   source oe-init-build-env ../build\\n   ```\\n\\n1. Add the needed layers:\\n\\n   ```bash\\n   bitbake-layers add-layer ../meta-openembedded/meta-oe\\n   bitbake-layers add-layer ../meta-erlang\\n   bitbake-layers add-layer ../meta-axon\\n   bitbake-layers add-layer ../meta-fwup\\n   bitbake-layers add-layer ../meta-raspberrypi\\n   ```\\n\\nWhy five layers are needed ? Because the YP/OE approach is to isolate components\\ninto layer in order to maximize the software reusability.\\n\\n## Configuring the build environment\\n\\nFor this tutorial, the quickest way is edit and add the _conf/local.conf_\\nconfiguration file.\\n\\nWe start defining the MACHINE and DISTRO:\\n\\n```bash\\nMACHINE = \\"raspberrypi0-wifi\\"\\nDISTRO = \\"poky\\"\\n```\\n\\nThe layer\\n[meta-raspberry](https://meta-raspberrypi.readthedocs.io/en/latest/readme.html)\\nprovides the machine _raspberrypi0-wifi_ which is what I\'m using for this\\ndemonstration as my current development board is a raspberry pi 0.\\n\\nNext, we need to enable some raspberry features like UART and USB host support\\n(it\'s important to get some network connectivity):\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# https://meta-raspberrypi.readthedocs.io/en/latest/extra-build-config.html#enable-uart\\nENABLE_UART = \\"1\\"\\n\\n# https://meta-raspberrypi.readthedocs.io/en/latest/extra-build-config.html#enable-usb-host-support\\nENABLE_DWC2_PERIPHERAL = \\"1\\"\\n\\n# add some package to allow networking\\nIMAGE_INSTALL:append = \\" raspi2go kernel-module-libcomposite kernel-module-g-ether kernel-module-dwc2\\"\\nEOF\\n```\\n\\nAs YP/OE supports many types of image outputs, we want to be specific here and\\npick only the _fwup_ type.\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# enable support for making fwup images\\nIMAGE_CLASSES += \\"image_types_fwup\\"\\nIMAGE_FSTYPES = \\"fwup\\"\\nEOF\\n```\\n\\nThe fwup type is provided by the bbclass\\n[image_types_fwup.bbclass](https://github.com/fwup-home/meta-fwup/blob/master/classes/image_types_fwup.bbclass).\\nIt relies on wic image generator and uses their build artifacts for bootloader\\nand rootfs.\\n\\nOk, now we also want to include Erlang/OTP and Elixir. As meta-erlang provides\\nmany versions, I recommend to stick with a specific one. In our case the latest\\n1.17.x and 27.0.x are good:\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# select specific elixir and erlang versions\\nPREFERRED_VERSION_elixir = \\"1.17%\\"\\nPREFERRED_VERSION_elixir-native = \\"1.17%\\"\\nPREFERRED_VERSION_nativesdk-elixir = \\"1.17%\\"\\nPREFERRED_VERSION_erlang = \\"27.0%\\"\\nPREFERRED_VERSION_erlang-native = \\"27.0%\\"\\nPREFERRED_VERSION_nativesdk-erlang = \\"27.0%\\"\\nEOF\\n```\\n\\nFinally, add erlang and elixir to the image:\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# add erlang and elixir into image\\nIMAGE_INSTALL:append = \\" erlang elixir\\"\\nEOF\\n```\\n\\nNow that the configuration is over. Let\'s start a build:\\n\\n```bash\\nbitbake core-image-full-cmdline\\n```\\n\\n:::note\\n\\nIt might take some time for the first build. As YP/OE will build everything from\\nscratch. The next builds should be faster.\\n\\n:::\\n\\nOnce the build has finished, let\'s inspect the build outputs:\\n\\n```bash\\ncd tmp/deploy/images/raspberrypi0-wifi\\nls -l core-image-full-cmdline*\\n-rw-r--r-- 2 builder builder 68465478 Sep 24 21:19 core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw\\nlrwxrwxrwx 2 builder builder       66 Sep 24 21:19 core-image-full-cmdline-raspberrypi0-wifi.rootfs.fw -> core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw\\n```\\n\\nThe folder _tmp/deploy/images/raspberrypi0-wifi_ has many files generated from\\nthe build tasks. We are interested only the final .fw file. In this case we the\\nfile _core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw_ is\\nwhat we need.\\n\\n## Deploying .fw images\\n\\nBefore deploying, let\'s understand a bit the image partition layout created by\\nYP/OE and fwup tool:\\n\\n```\\n# +----------------------------+\\n# | MBR                        |\\n# +----------------------------+\\n# | Firmware configuration data|\\n# | (formatted as uboot env)   |\\n# +----------------------------+\\n# | p0*: Boot A (FAT32)        |\\n# | zImage, bootcode.bin,      |\\n# | config.txt, etc.           |\\n# +----------------------------+\\n# | p0*: Boot B (FAT32)        |\\n# +----------------------------+\\n# | p1*: Rootfs A (ext4)       |\\n# +----------------------------+\\n# | p1*: Rootfs B (ext4)       |\\n# +----------------------------+\\n# | p2: Application (ext4)     |\\n# +----------------------------+\\n```\\n\\nThere is a total of three partitions. Where partition p0 and p1 have been\\ndivided by half each one. It\'s not clear to get this idea. So, I recommend you\\nto take a look into fwup configuration file used by this tutorial,\\n[core-image-full-cmdline.raspberrypi0-wifi.fwup](https://github.com/meta-erlang/meta-axon/blob/master/fwup/core-image-full-cmdline.raspberrypi0-wifi.fwup).\\nThat file has been adapted from the original\\n[nerves_system_rpi0 fwup configuration](https://github.com/nerves-project/nerves_system_rpi0/blob/main/fwup.conf).\\n\\n### burn a complete image\\n\\nMy target sdcard has 16GB there is enough space for the core-image-full-cmdline\\nimage. To start using it we need write a _complete_ image to the sdcard. By\\ncomplete image also means the the partition A will be used when the board gets\\nbooted.\\n\\n```bash\\n$ sudo fwup -a -d /dev/sda -t complete -i core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw\\n100% [====================================] 68.46 MB in / 382.20 MB out\\nSuccess!\\nElapsed time: 55.932 s\\n```\\n\\nWhen I inserted the sdcard into my workstation, my host Linux recognized it as\\n_/dev/sda_ device, using sudo when calling fwup took almost 56 seconds to write\\n382 MB to the sdcard.\\n\\nThat is all we need to get the sdcard and boot it into raspberry board.\\n\\n:::note\\n\\nThe next output is just the partition layout for a real board booted from the\\nsdcard.\\n\\n:::\\n\\nAnd in fact, it works as expected:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# sfdisk -l /dev/mmcblk0\\nDisk /dev/mmcblk0: 14.84 GiB, 15931539456 bytes, 31116288 sectors\\nUnits: sectors of 1 * 512 = 512 bytes\\nSector size (logical/physical): 512 bytes / 512 bytes\\nI/O size (minimum/optimal): 512 bytes / 512 bytes\\nDisklabel type: dos\\nDisk identifier: 0x00000000\\n\\nDevice         Boot   Start      End  Sectors  Size Id Type\\n/dev/mmcblk0p1 *         63   266302   266240  130M  c W95 FAT32 (LBA)\\n/dev/mmcblk0p2       532543  1011774   479232  234M 83 Linux\\n/dev/mmcblk0p3      1491007 31116287 29625281 14.1G 83 Linux\\n```\\n\\nChecking erl and iex versions:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# erl\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nEshell V15.0.1 (press Ctrl+G to abort, type help(). for help)\\n1>\\nUser switch command (type h for help)\\n --\x3e q\\n\\nroot@raspberrypi0-wifi:~# iex\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nwarning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (whiche\\nInteractive Elixir (1.17.1) - press Ctrl+C to exit (type h() ENTER for help)\\niex(1)>\\n```\\n\\n### move to B partition\\n\\nStill using the image\\ncore-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw, I want to\\ntest the B upgrade path. For that, the easiest way is to call fwup (which has\\nbeen installed into the image) passing some usual flags for this\\n[kind of operation](https://github.com/fwup-home/fwup?tab=readme-ov-file#whats-something-cool-that-you-can-do-with-fwup):\\n\\n:::note\\n\\nThe instructions for setting board\'s network stack using USB is not part of the\\nscope of this tutorial.\\n\\n:::\\n\\n```bash\\n$ cat core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240924200317.fw | ssh root@192.168.7.7 \'fwup -v -a -U -d /dev/mmcblk0 -t upgrade.b\'\\nfwup: require-partition-offset(1, 532543) -> met\\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_platform) -> met\\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_architecture) -> met\\nfwup: Upgrading partition B\\n100% [====================================] 68.46 MB in / 381.82 MB out\\nSuccess!\\nElapsed time: 1 min 30 s\\n```\\n\\nThe important argument is the `-t upgrade.b` telling to fwup which partition\\nwill be upgraded.\\n\\n:::note\\n\\nIn my setup I called `reboot` to get raspberry rebooted.\\n\\n:::\\n\\nChecking erl and iex versions:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# erl\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nEshell V15.0.1 (press Ctrl+G to abort, type help(). for help)\\n1>\\nUser switch command (type h for help)\\n --\x3e q\\n\\nroot@raspberrypi0-wifi:~# iex\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nwarning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (whiche\\nInteractive Elixir (1.17.1) - press Ctrl+C to exit (type h() ENTER for help)\\niex(1)>\\n```\\n\\nThe versions are still 1.17.x and 27.0.x, as expected.\\n\\n### move from B to A partition\\n\\nFor testing purposes, let\'s change the Elixir preferred version from 1.17.x to\\n1.16.x. For that, edit the local.conf file and change the\\n`PREFERRED_VERSION_elixir*` variables:\\n\\n```bash\\ntee -a <<EOF conf/local.conf\\n# select specific elixir and erlang versions\\nPREFERRED_VERSION_elixir = \\"1.16%\\"\\nPREFERRED_VERSION_elixir-native = \\"1.16%\\"\\nPREFERRED_VERSION_nativesdk-elixir = \\"1.16%\\"\\nEOF\\n```\\n\\nRunning the build again:\\n\\n```bash\\nbitbake core-image-full-cmdline\\n```\\n\\nThe result will be a new core-image-full-cmdline-raspberrypi0-wifi.rootfs-\\\\*.fw\\nfilename which is ready to be used:\\n\\n```bash\\n$ cat core-image-full-cmdline-raspberrypi0-wifi.rootfs-20240920190231.fw | ssh root@192.168.7.7 \'fwup -v -a -U -d /dev/mmcblk0 -t upgrade.a\'\\nfwup: require-partition-offset(1, 1011775) -> met\\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_platform) -> met\\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_architecture) -> met\\nfwup: Upgrading partition A\\n100% [====================================] 68.46 MB in / 381.82 MB out\\nSuccess!\\nElapsed time: 1 min 30 s\\n```\\n\\nRebooting the board and checking the iex version, we get:\\n\\n```bash\\nroot@raspberrypi0-wifi:~# erl\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nEshell V15.0.1 (press Ctrl+G to abort, type help(). for help)\\n1>\\nUser switch command (type h for help)\\n --\x3e q\\nroot@raspberrypi0-wifi:~# iex\\nwarning: the VM is running with native name encoding of latin1 which may cause Elixir to malfunction as it expects utf8. Please ensure your locale is set to UTF-8 (whiche\\nErlang/OTP 27 [erts-15.0.1] [source] [32-bit] [smp:1:1] [ds:1:1:10] [async-threads:1]\\n\\nInteractive Elixir (1.16.3) - press Ctrl+C to exit (type h() ENTER for help)\\n```\\n\\nThat works! Erlang/OTP 27 and Elixir 1.16.3.\\n\\n## Conclusions\\n\\nThe [fwup](https://github.com/fwup-home/fwup) tool has shown as a feasibly\\napproach for image A/B software upgrades. It is integrated into YP/OE ecosystem\\nthrough [meta-fwup](https://github.com/fwup-home/meta-fwup) layer and ready to\\ntry.\\n\\nfwup is also used by Nerves Project together with others Elixir components in\\norder to provide a full\\n[OTA updates](https://en.wikipedia.org/wiki/Over-the-air_update)."},{"id":"/2024/05/31/index","metadata":{"permalink":"/blog/2024/05/31/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-05-31/index.md","source":"@site/blog/2024-05-31/index.md","title":"New Erlang releases 27.0","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2024-05-31T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.52,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 27.0","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"fwup for A/B image upgrades, part I","permalink":"/blog/2024/09/24/index"},"nextItem":{"title":"livebook server","permalink":"/blog/2024/04/28/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version      |\\n| ------------------ | ----------------------- |\\n| scarthgap          | 25.3.2.12, 26.2.5, 27.0 |\\n| master             | 25.3.2.12, 26.2.5, 27.0 |\\n\\nAnd the following Elixir releases:\\n\\n| meta-erlang branch | Elixir version                 |\\n| ------------------ | ------------------------------ |\\n| scarthgap          | 1.13.4, 1.14.4, 1.15.7, 1.16.3 |\\n| master             | 1.13.4, 1.14.4, 1.15.7, 1.16.3 |\\n\\nI was planing to also add Erlang/OTP 27.0 to LTS kirkstone release. However it\\nis not feasible as Erlang/OTP 27 uses autoconf 2.72 and kirkstone uses 2.71.\\nThus, there is an incompatible related to build system."},{"id":"/2024/04/28/index","metadata":{"permalink":"/blog/2024/04/28/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-04-28/index.md","source":"@site/blog/2024-04-28/index.md","title":"livebook server","description":"Intro","date":"2024-04-28T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"livebook","permalink":"/blog/tags/livebook"}],"readingTime":1.295,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"livebook server","authors":["joaohf"],"tags":["meta-erlang","livebook"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 27.0","permalink":"/blog/2024/05/31/index"},"nextItem":{"title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","permalink":"/blog/2024/04/21/index"}},"content":"## Intro\\n\\nFrom [livebook.dev](https://livebook.dev) website:\\n\\n> Automate code & data workflows with interactive notebooks.\\n\\nLivebook is getting famous for modern notebooks. It helps a lot for several\\ntasks and to solve issues where documentation and code have to walk together.\\n\\n\x3c!-- truncate --\x3e\\n\\nLive book has been added to the standard beamtools SDK. That is very handy\\nbecause one can start livebook quickly and it will work with all SDK tools. That\\nmeans, we don\'t need to install anything else. It\'s all integrated.\\n\\nIf one more tool is needed, it\'s just a matter of including it into SDK and it\\nwill be ready to use.\\n\\nThe following section is a step by step in order to install livebook in any\\nmodern Linux server.\\n\\n### livebook as a Linux systemd service\\n\\nAll commands as sudo:\\n\\n```\\nwget -O /tmp/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh https://github.com/meta-erlang/meta-erlang/releases/download/beamtools-0.9.1/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh\\n\\nchmod +x /tmp/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh\\n\\nadduser --group livebook livebook\\nmkdir /home/livebook/sdk\\n\\n/tmp/x86_64-beamtools-nativesdk-standalone-5.0.2-erlang-27.0-elixir-1.17.1.sh -y -d /home/livebook/sdk/5.0.2\\n\\nchown -R livebook:livebook /home/livebook/sdk/5.0.2\\n```\\n\\nCreate a file at /etc/livebook/livebook.conf with permission livebook:livebook\\nand the following configuration:\\n\\n```\\nLIVEBOOK_DEFAULT_RUNTIME=standalone\\nLIVEBOOK_IP=0.0.0.0\\nLIVEBOOK_PORT=8080\\nLIVEBOOK_PASSWORD=livebook-instance\\nLIVEBOOK_HOME=/home/livebook\\n```\\n\\nCreate a systemd service file at /lib/systemd/system/livebook.service with the\\nfollowing:\\n\\n```\\n[Unit]\\nDescription=Livebook\\n\\n[Service]\\nType=simple\\nUser=livebook\\nGroup=livebook\\nEnvironment=SHELL=/bin/sh\\nEnvironment=HOME=/home/livebook\\nEnvironmentFile=/etc/livebook/livebook.conf\\nWorkingDirectory=/home/livebook\\nExecStart=/home/livebook/livebook.sh start\\nExecStop=/home/livebook/livebook.sh stop\\nRestart=on-failure\\n\\n[Install]\\nWantedBy=multi-user.target\\n```\\n\\nCreate a file /home/livebook/livebook.sh, change permission to\\nlivebook:livebook.\\n\\nWith the following contents:\\n\\n```\\n#!/bin/bash\\n\\n# Load SDK environment\\nsource /home/livebook/sdk/5.0.2/environment-setup-x86_64-pokysdk-linux\\n\\n# Start/Stop livebook\\nlivebook $@\\n```\\n\\nIn order to start and stop livebook, it\'s all about systemctl commands:\\n\\n- start: `systemctl start livebook`\\n- stop: `systemctl stop livebook`\\n- check status: `systemctl status livebook`"},{"id":"/2024/04/21/index","metadata":{"permalink":"/blog/2024/04/21/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-04-21/index.md","source":"@site/blog/2024-04-21/index.md","title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2024-04-21T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.175,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"livebook server","permalink":"/blog/2024/04/28/index"},"nextItem":{"title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","permalink":"/blog/2024/03/17/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version           |\\n| ------------------ | ---------------------------- |\\n| kirkstone          | 24.3.4.17, 25.3.2.12, 26.2.5 |\\n| master             | 25.3.2.12, 26.2.5, 27.0-rc3  |"},{"id":"/2024/03/17/index","metadata":{"permalink":"/blog/2024/03/17/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-03-17/index.md","source":"@site/blog/2024-03-17/index.md","title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2024-03-17T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.195,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.17, 25.3.2.12, 26.2.5, 27.0-rc3","permalink":"/blog/2024/04/21/index"},"nextItem":{"title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","permalink":"/blog/2023/12/25/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version           |\\n| ------------------ | ---------------------------- |\\n| dunfell            | 24.3.4.16                    |\\n| kirkstone          | 24.3.4.16, 25.3.2.10, 26.2.3 |\\n| master             | 25.3.2.10, 26.2.3            |"},{"id":"/2023/12/25/index","metadata":{"permalink":"/blog/2023/12/25/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-12-25/index.md","source":"@site/blog/2023-12-25/index.md","title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-12-25T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.375,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.16, 25.3.2.10, 26.2.3","permalink":"/blog/2024/03/17/index"},"nextItem":{"title":"meta-erlang meets atomvm","permalink":"/blog/2023/11/02/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version          |\\n| ------------------ | --------------------------- |\\n| dunfell            | 24.3.4.15                   |\\n| kirkstone          | 24.3.4.15, 25.3.2.8, 26.2.1 |\\n| master             | 25.3.2.8, 26.2.1            |\\n\\nIn additional to those new versions, now it\'s possible to read Erlang/OTP\\ndocumentation in Erlang shell. The docs .chunk files get generated during build\\ntime and one could easily install it by adding the package _erlang-modules-dev_."},{"id":"/2023/11/02/index","metadata":{"permalink":"/blog/2023/11/02/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-11-02/index.md","source":"@site/blog/2023-11-02/index.md","title":"meta-erlang meets atomvm","description":"Intro","date":"2023-11-02T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"atomvm","permalink":"/blog/tags/atomvm"}],"readingTime":3.99,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang meets atomvm","authors":["joaohf"],"tags":["meta-erlang","atomvm"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.15, 25.3.2.8, 26.2.1","permalink":"/blog/2023/12/25/index"},"nextItem":{"title":"Exploring x32 psABI for Erlang/OTP","permalink":"/blog/2023/09/02/index"}},"content":"## Intro\\n\\nFrom [atomvm.net](https://www.atomvm.net/) website, atomvm is:\\n\\n> AtomVM is a lightweight implementation of the the Bogdan Erlang Abstract\\n> Machine (aka, the BEAM), a virtual machine that can execute byte-code\\n> instructions compiled from Erlang or Elixir source code. AtomVM supports a\\n> limited but functional subset of the BEAM opcodes, and also includes a small\\n> subset of the Erlang/OTP standard libraries, all optimized to run on tiny\\n> micro-controllers. With AtomVM, you can write your IoT applications in a\\n> functional programming language, using a modern actor-based concurrency model,\\n> making them vastly easier to write and understand!\\n\\nOne of the atomvm goals is the possibility to run BEAM code on really small\\nsystems like MCUs.\\n\\n\x3c!-- truncate --\x3e\\n\\nFor a while, I was wondering what could be the benefits of integrating atomvm\\ninto meta-erlang recipes. It didn\'t look to make any sense for me. Then, I\\nstarted playing with that just to see if I was able to run an atomvm program in\\nQemu emulation.\\n\\nSuddenly, I ended up with all pieces to run atomvm programs integrated with\\nmeta-erlang. So this post is about how it is possible to use atomvm in Linux\\nimages based on YP/OE.\\n\\n### atomvm recipe\\n\\nThe\\n[atomvm.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-devtools/atomvm/atomvm_0.6.0-alpha1.bb)\\nrecipe is very simple because the atomvm project is based on CMake and YP has\\nsupport to it.\\n\\nHowever, I had to make a specific recipe to isolate the tool packbeam. The\\npackbeam tool lives inside atomvm source code I\'ve created a recipe called\\n[packbeam.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-devtools/atomvm/packbeam_0.6.0-alpha1.bb)\\nwhich compiles packbeam as native (that is runs on build host machine). That was\\nnecessary because the atomvm recipe crosscompile the atomvm and packbeam is used\\nby CMake to pack all .beam files to create .avm files.\\n\\nTo make atomvm recipe works, I applied a patch\\n([0001-Remove-PackBEAM-dependency-rules.patch](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-devtools/atomvm/files/0001-Remove-PackBEAM-dependency-rules.patch))\\nto disable the packbeam dependency internally. That allows me to use my packbeam\\ntool from sysroot-native instead.\\n\\n:::note\\n\\nThe mentioned patch works for my needs but is not target for sending a PR to\\natomvm project.\\n\\n:::\\n\\n### atomvm examples\\n\\nThere is the [atomvm_examples](https://github.com/atomvm/atomvm_examples)\\nproject that provides great source of ideas and examples. I wish to create some\\nrecipes to build and pack each example. So I started with the\\n[system_info](https://github.com/atomvm/atomvm_examples/tree/master/erlang/system_info).\\n\\nThe following code is the\\n[atomvm-examples-system-info_0.1.0.bb](https://github.com/meta-erlang/meta-erlang/blob/master/recipes-examples/atomvm-examples/atomvm-examples-system-info_0.1.0.bb)\\nrecipe. And should be enough for any Erlang project build which uses\\n[atomvm_rebar3_plugin](https://github.com/atomvm/atomvm_rebar3_plugin).\\n\\n```\\nSUMMARY = \\"Collects and displays various information about AtomVM and the environment in which it is running.\\"\\nSECTION = \\"examples\\"\\nLICENSE = \\"Apache-2.0\\"\\nLIC_FILES_CHKSUM = \\"file://LICENSE;md5=745e8b23501916820b8a509f8e3ba3d4\\"\\n\\nATOMVM_EXAMPLE = \\"erlang/system_info\\"\\n\\nS = \\"${WORKDIR}/system_info\\"\\n\\nSRCREV = \\"8e54aaf475a74b59a20f914e575202b1810a7954\\"\\nPV = \\"0.1.0+git${SRCPV}\\"\\nSRC_URI = \\"git://github.com/atomvm/atomvm_examples;branch=master;subpath=${ATOMVM_EXAMPLE};protocol=https\\"\\n\\ninherit atomvm\\n```\\n\\nThe `inherit atomvm` inherits the\\n[atomvm.bbclass](https://github.com/meta-erlang/meta-erlang/blob/master/classes/atomvm.bbclass)\\nwhich implements rebar3 commands to compile and create avm files.\\n\\n### Build and run session\\n\\nTo build the atomvm-examples-system-info recipe, we call bitbake like that:\\n\\n```\\nbitbake atomvm-examples-system-info\\n```\\n\\nNow, we want to run system_info application inside Qemu. The first step is to\\ninstall the atomvm-examples-system-info in the final image.\\n\\nIn _conf/local.conf_ file add the recipe name to the IMAGE_INSTALL variable:\\n\\n```\\nIMAGE_INSTALL:append:pn-core-image-minimal = \\" atomvm-examples-system-info\\"\\n```\\n\\nWhen building the core-image-minimal image and running it with Qemu:\\n\\n```\\nrunqemu core-image-minimal slirp nographic serialstdio\\n```\\n\\nInside the Qemu, let\'s run our first atomvm program:\\n\\n```\\nroot@qemux86-64:~# uname -a\\nLinux qemux86-64 6.5.7-yocto-standard #1 SMP PREEMPT_DYNAMIC Thu Oct 19 14:51:09 UTC 2023 x86_64 GNU/Linux\\nroot@qemux86-64:~# atomvm /usr/share/atomvm-examples-system-info/system_info.avm\\nUnsupported line_ref tag: 0\\nSystemInfo:\\n===========\\natom_count: 162\\nport_count: 0\\nprocess_count: 1\\nsystem_architecture: <<\\"Linux--x86_64\\">>\\nword_size: 8\\n\\nPlatformInfo:\\n=============\\n\\nProcessInfo:\\n============\\nPid: <0.1.0>\\nheap_size: 51\\nmemory: 848\\nmessage_queue_len: 0\\nstack_size: 9\\n\\nReturn value: ok\\n```\\n\\nThat works as expected.\\n\\n### Integration outcomes and questions\\n\\nThe recipes created so far covers running atomvm for generic unix (Linux in my\\ncase). Well, if you can afford running Erlang/Elixir on Linux, then there is no\\nselling point to use atomvm. That is true if we look at the current state of\\natomvm project for generic unix platform.\\n\\nMaybe in the future we can see extensions to generic unix allowing it to talk\\nwith i2c, gpio, spi on Linux for example, then atomvm and meta-erlang starts to\\ncover a lot of possibilities. Projects like\\n[Eclipse Mraa](https://github.com/eclipse/mraa) could be integrated with atomvm\\nproviding all the low level access for low speed IO.\\n\\nThere is another idea for meta-erlang and atomvm which is the heterogeneous\\nsystem with a combination of:\\n\\n- Linux based images running on the \\"application processing unit\\" (CPU)\\n- and \\"real-time processing unit\\" (MCU) running an atomvm program.\\n\\nmeta-erlang could build atomvm images for MCU as well for CPU. The seeds for\\nthis integration was described in this talk\\n[One Build to Rule Them All: Building FreeRTOS & Linux Using Yocto - Alejandro Hernandez](https://www.youtube.com/watch?v=mFgiIXv7b5U)\\n(the pdf is\\n[here](https://elinux.org/images/9/9f/ELC_Europe_2019_Presentation_AlejandroHernandez_FreeRTOS_ToUpload.pdf)).\\nIn that talk Alejandro shows how YP/OE projects can build MCU target images.\\nUsing the same principles also works for meta-erlang."},{"id":"/2023/09/02/index","metadata":{"permalink":"/blog/2023/09/02/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-09-02/index.md","source":"@site/blog/2023-09-02/index.md","title":"Exploring x32 psABI for Erlang/OTP","description":"Intro","date":"2023-09-02T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"x32","permalink":"/blog/tags/x-32"}],"readingTime":3.88,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"Exploring x32 psABI for Erlang/OTP","authors":["joaohf"],"tags":["meta-erlang","x32"]},"unlisted":false,"prevItem":{"title":"meta-erlang meets atomvm","permalink":"/blog/2023/11/02/index"},"nextItem":{"title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","permalink":"/blog/2023/07/01/index"}},"content":"## Intro\\n\\nAccording to [Wikipedia X32 ABI](https://en.wikipedia.org/wiki/X32_ABI) page:\\n\\n> The x32 ABI is an application binary interface (ABI) and one of the interfaces\\n> of the Linux kernel. The x32 ABI provides 32-bit integers, long and pointers\\n> (ILP32) on Intel and AMD 64-bit hardware. The ABI allows programs to take\\n> advantage of the benefits of x86-64 instruction set (larger number of CPU\\n> registers, better floating-point performance, faster position-independent\\n> code, shared libraries, function parameters passed via registers, faster\\n> syscall instruction) while using 32-bit pointers and thus avoiding the\\n> overhead of 64-bit pointers.\\n\\nSo, I\'m wondering if it would be possible to enable x32 support in Erlang/OTP\\nbuild. That way, I could make a Yocto image for x32 that runs on x86-64\\nmachines.\\n\\n\x3c!-- truncate --\x3e\\n\\nHere is some references about the subject:\\n\\n- [Yocto, Using x32 psABI](https://docs.yoctoproject.org/dev-manual/x32-psabi.html)\\n- [x32-abi](https://sites.google.com/site/x32abi/home?authuser=0)\\n- [X32 \u2013 A Native 32bit ABI For X86-64](http://linuxplumbersconf.org/2011/ocw//system/presentations/531/original/x32-LPC-2011-0906.pptx)\\n- [Debian x32 port](https://wiki.debian.org/X32Port)\\n- [System V Application Binary Interface AMD64 Architecture Processor Supplement (With LP64 and ILP32 Programming Models](https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf)\\n\\nIn fact, x32 seems to be around since 2011/2012 and has been integrated in many\\nplatforms. Like Ubuntu, Debian, Gentoo.\\n\\n## Building Erlang/OTP using x32 toolchain\\n\\n:::note\\n\\nA toolchain with x32 support is necessary. However, it\'s not easy to find one.\\nInstead projects like [crosstool-NG](https://crosstool-ng.github.io/) and\\n[Yocto Project](https://www.yoctoproject.org/) have tools to make a toolchain\\nwith x32 support enabled.\\n\\n:::\\n\\nIn order to follow this experiment, you can download a specific toolchain with\\nx32 enabled here:\\n[poky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh](https://github.com/meta-erlang/meta-erlang.github.io/releases/tag/x32-toolchain).\\n\\nIt will be necessary to install it in a temporary folder like the steps below:\\n\\n```\\nchmod +x poky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh\\npoky-glibc-x86_64-core-image-minimal-x86_64_x32-qemux86-64-toolchain-4.2.sh -y -d /tmp/poky/4.2\\n```\\n\\nFollowing the Erlang/OTP\\n[INSTALL-CROSS.md](https://github.com/erlang/otp/blob/master/HOWTO/INSTALL-CROSS.md)\\ndocument, we first need to build a Bootstrap System:\\n\\n```\\ncd $ERL_TOP\\n./configure --enable-bootstrap-only\\nmake\\n```\\n\\nNext, we have to source the toolchain environment configurations:\\n\\n```\\n. /tmp/poky/4.2/environment-setup-x86_64_x32-poky-linux-gnux32\\n```\\n\\nAfter sourcering the environment variable, the shell gets configured with some\\nextra variables using during the build:\\n\\n```\\nx86_64-poky-linux-gnux32-gcc -mx32 \\\\\\n -fstack-protector-strong \\\\\\n -O2 -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security \\\\\\n --sysroot=/tmp/poky/4.2/sysroots/x86_64_x32-poky-linux-gnux32\\n```\\n\\nIt\'s important to not the GCC flag\\n[-mx32](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#index-mx32):\\n\\n> The -mx32 option sets int, long, and pointer types to 32 bits, and generates\\n> code for the x86-64 architecture.\\n\\nFinally, start the second part of Erlang/OTP build, which is the Cross Build:\\n\\n```\\n./configure  $CONFIGURE_FLAGS  --disable-silent-rules --disable-dependency-tracking \\\\\\n\\t--with-ssl-rpath=no --disable-static  --without-javac --without-dynamic-trace --without-observer --without-odbc\\n```\\n\\nInstalling the build output and inspecting the `erlexec` binary to see what it\\nlooks like:\\n\\n```\\nmake install DESTDIR=/tmp/e\\n\\nfile /tmp/e/usr/local/lib/erlang/erts-14.0.2/bin/erlexec\\nerlexec: ELF 32-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /libx32/ld-linux-x32.so.2, BuildID[sha1]=013e32ef8c57686a59a812ca452f09d677ff8e37, for GNU/Linux 5.15.0, with debug_info, not stripped\\n```\\n\\nWell, the build is correct. But I couldn\'t test this build in my machine.\\n\\n## Enabling Erlang for Yocto\\n\\nIn the previous section we just build Erlang/OTP using a toolchain with x32\\nsupport. Now, it\'s time to build Erlang/OTP inside the Yocto project and test\\nthe results using qemu instance.\\n\\nEnabling it for Yocto is simple, just adding the follow snippet in your\\nlocal.conf file:\\n\\n```\\nMACHINE = \\"qemux86-64\\"\\nDEFAULTTUNE = \\"x86-64-x32\\"\\nbaselib = \\"${@d.getVar(\'BASE_LIB:tune-\' + (d.getVar(\'DEFAULTTUNE\') or \'INVALID\')) or \'lib\'}\\"\\n```\\n\\nThen, building erlang:\\n\\n```\\nbitbake erlang\\n```\\n\\n:::note\\n\\nFor those that want to check all configure and compiler flags, I\'m including the\\nlinks to those logs:\\n\\n- [Configure log output](pathname:///assets/log.do_configure)\\n- [Compile log output](pathname:///assets/log.do_compile)\\n\\n:::\\n\\nThe build failed in one point related to ASM code in\\n[erts/lib_src/pthread/ethread.c](https://github.com/erlang/otp/blob/maint-26/erts/lib_src/pthread/ethread.c#L193).\\nLooks like an ASM incompatibility issue. In order to address it here is\\n[a patch](https://github.com/joaohf/otp/commit/6cd15d5888a536af97f5d8e26b2db2e379fa7eab)\\nthat just adds one more compiler check to pick up the correct ifdef branch.\\n\\nAfer that, the build runs as expected. And testing it using QEMU shows exactly\\nwhat I had in mind:\\n\\n```\\nrunqemu core-image-minimal-qemux86-64.ext4 slirp nographic serialstdio\\n```\\n\\n- check the current kernel\\n\\n```\\nroot@qemux86-64:~# uname -a\\nLinux qemux86-64 6.1.32-yocto-standard #1 SMP PREEMPT_DYNAMIC Mon Jun  5 13:43:33 UTC 2023 x86_64 GNU/Linux\\n```\\n\\n- check /proc/cpuinfo to see the \'lm\' (long mode)\\n\\n```\\nroot@qemux86-64:~# grep -o -w \'lm\' /proc/cpuinfo\\nlm\\n```\\n\\n- check Erlang shell\\n\\n```\\nErlang/OTP 26 [erts-14.0.2] [source] [32-bit] [smp:4:4] [ds:4:4:10] [async-threads:1]\\n\\nEshell V14.0.2 (press Ctrl+G to abort, type help(). for help)\\n1> application:ensure_all_started(crypto).\\n{ok,[crypto]}\\n```\\n\\nWell, looks like we are running Erlang/OTP 32-bits in a x86_64 machine. Also, it\\nwas able to correct load the crypto (with ssl libraries compiled for x32 too).\\nBy the way, there is a second\\n[patch need to proper compile the crypto application](https://github.com/joaohf/otp/commit/e63b5b703ffa0005bf6a8f4d3bcec18f786bda92).\\n\\nSome raised questions for further investigations:\\n\\n- What tests are necessary to prove that the x32 Erlang build is safe ?\\n- Are there any other code change in order to fit the x32 build ?\\n- Would [BeamAsm](https://www.erlang.org/doc/apps/erts/beamasm#faq) be available\\n  for x32 ?"},{"id":"/2023/07/01/index","metadata":{"permalink":"/blog/2023/07/01/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-07-01/index.md","source":"@site/blog/2023-07-01/index.md","title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-07-01T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.335,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"Exploring x32 psABI for Erlang/OTP","permalink":"/blog/2023/09/02/index"},"nextItem":{"title":"New meta-erlang branch mickledore","permalink":"/blog/2023/06/09/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version          |\\n| ------------------ | --------------------------- |\\n| dunfell            | 24.3.4.13                   |\\n| kirkstone          | 24.3.4.13, 25.3.2.3, 26.0.2 |\\n| mickledore         | 25.3.2.3, 26.0.2            |\\n\\nIn additional to those new versions, a new\\n[beamtools](https://meta-erlang.github.io/docs/guides/guides-beamtools/) is\\navailable\\n[here](https://github.com/meta-erlang/meta-erlang/releases/tag/beamtools-0.7.0).\\n\\nThis new version was made with\\n[Yocto mickledore](https://docs.yoctoproject.org/dev/migration-guides/migration-4.2.html)\\nrelease and brings Erlang/OTP 26.0.2 and Elixir 1.15.2."},{"id":"/2023/06/09/index","metadata":{"permalink":"/blog/2023/06/09/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-06-09/index.md","source":"@site/blog/2023-06-09/index.md","title":"New meta-erlang branch mickledore","description":"Yocto Project has released a new","date":"2023-06-09T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.365,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New meta-erlang branch mickledore","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.13, 25.3.2.3, 26.0.2","permalink":"/blog/2023/07/01/index"},"nextItem":{"title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","permalink":"/blog/2023/05/07/index"}},"content":"Yocto Project has [released](https://wiki.yoctoproject.org/wiki/Releases) a new\\n[version 4.2 (Mickledore)](https://docs.yoctoproject.org/dev/migration-guides/migration-4.2.html).\\nAs consequence meta-erlang brings a new branch mickledore updating most of the\\nrecipes. mickledore release is not a LTS release and community support will be\\navailable until November 2023.\\n\\nWe\'ve also upgraded to the latest Erlang/OTP and Elixir releases supporting the\\nfollowing new Erlang/OTP releases:\\n\\n- Erlang/OTP 26.0.1\\n- Erlang/OTP 25.3.2.2\\n- Elixir 1.14.4\\n\\nIt\'s worth mentioning the meta-erlang master has also been updated."},{"id":"/2023/05/07/index","metadata":{"permalink":"/blog/2023/05/07/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-05-07/index.md","source":"@site/blog/2023-05-07/index.md","title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-05-07T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.645,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New meta-erlang branch mickledore","permalink":"/blog/2023/06/09/index"},"nextItem":{"title":"meta-erlang on cloud II: building your own application","permalink":"/blog/2023/02/04/index"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version |\\n| ------------------ | ------------------ |\\n| dunfell            | 24.3.4.11          |\\n| kirkstone          | 24.3.4.11, 25.3.2  |\\n| langdale           | 25.3.2             |\\n\\nRemoved recipes:\\n\\n- For langdale the recipes ejabberd and emqx have been removed due the lack of\\n  supporting cross-compilation build in a stable way.\\n\\nUpdated recipes:\\n\\n- For langdale the following recipes have been updated: lux, vernemq, yaws,\\n  tsung, riak, couchdb. It is important to mention about langdale\\n  [EOL in May 2023](https://wiki.yoctoproject.org/wiki/Releases). So, this\\n  branch will not receive updates.\\n\\nIt has been decided:\\n\\n- Dropped support to Erlang/OTP 24 in langdale. Due the lack of deterministic\\n  build flags in 24. Elixir 1.12 has also been dropped (because it dependes on\\n  Erlang/OTP 24)."},{"id":"/2023/02/04/index","metadata":{"permalink":"/blog/2023/02/04/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-02-04/index.md","source":"@site/blog/2023-02-04/index.md","title":"meta-erlang on cloud II: building your own application","description":"\x3c!---","date":"2023-02-04T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":3.995,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang on cloud II: building your own application","authors":["joaohf"],"tags":["meta-erlang","cloud"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.11, 25.3.2 and recipe updates","permalink":"/blog/2023/05/07/index"},"nextItem":{"title":"meta-erlang on cloud I: EWAOL based","permalink":"/blog/2023/01/29/index"}},"content":"\x3c!---\\n\\n- The previous blog has showed how to use EWAOL and adds meta-erlang support to it\\n- Now it\'s time to create something more tiny with only the components that we need\\n- meta-xpto for cloud erlang/elixir services\\n- How to create an image\\n- Publish to AWS AMI\\n- Run a instance\\n- Conclusion\\n\\n--\x3e\\n\\n## Intro\\n\\nThe\\n[meta-erlang on cloud II, build your own application](/blog/2023/02/04/index)\\npost has shown the basic idea for how would be possible (and in fact it is\\npossible) to build a custom Linux distribution and run it on Graviton AWS\\ninstances.\\n\\n\x3c!-- truncate --\x3e\\n\\nNow, it\'s time to refactor out the previous result. Removing what are not\\nnecessary in order to create a slim meta-erlang cloud ready image.\\n\\nSo, this post is more like a tutorial to reach two main targets:\\n\\n- Explore a demo Yocto layer which shows the basic pieces to run a distro on\\n  Graviton\\n- Add [livebook](https://livebook.dev/) to that image and try it on cloud. Why\\n  not trying some GPU processing :)\\n\\n## meta-axon cloud aware\\n\\n[meta-axon](https://github.com/meta-erlang/meta-axon) is my playground layer\\nfocused on demonstrate how Erlang and Elixir applications could be integrated\\nwith Yocto ecosystem. Until now, meta-axon has been tailored to run on embedded\\ndevices (like raspberry pi). But, I\'m also added, along side with the former\\n[axon-slim](https://github.com/meta-erlang/meta-axon/conf/distro/axon.conf), a\\nnew distro called\\n[axon](https://github.com/meta-erlang/meta-axon/conf/distro/axon.conf). The axon\\ndistro is focused on cloud, for the purpose of this tutorial AWS cloud.\\n\\n:::tip\\n\\nIf you are new to the Yocto Project; remember some basic\\n[concepts here](https://docs.yoctoproject.org/overview-manual/concepts.html#yocto-project-concepts).\\n\\n:::\\n\\nI also introduced a new image called\\n[axon-image-cloud](https://github.com/meta-erlang/meta-axon/recipes-extented/image/axon-image-cloud.bb)\\nwith all the pieces needed to run it on Graviton instances. This image relies on\\nsystemd plus [cloud-init](https://cloud-init.io/) scripts.\\n\\nIt is important to mention that to run images on Graviton it is necessary to add\\ntwo layer dependencies:\\n\\n- [meta-arm](https://git.yoctoproject.org/git/meta-arm), implementing a generic\\n  ARM 64 bits machine\\n- [meta-virtualization](https://git.yoctoproject.org/git/meta-virtualization),\\n  bringing cloud-init recipe\\n\\nThe rest of the needed components are all provided by standard Yocto layers\\n(like: poky and meta-openembedded).\\n\\n## Build instructions\\n\\nWe want fast feedback and test the build results quickly. So here is the\\nprocedure that will build an distro linux image with Erlang, Elixir and\\n[livebook](https://livebook.dev/):\\n\\n:::note\\n\\nI\'m assuming a working Linux environment in order to run the below commands.\\n\\n:::\\n\\n1. Clone the meta-axon layer:\\n\\n   ```bash\\n   git clone https://github.com/meta-erlang/meta-axon.git\\n   cd meta-axon\\n   ```\\n\\n1. Install the [kas](https://kas.readthedocs.io/en/latest/) tool to setup a\\n   bitbake based project.\\n\\n   ```bash\\n   git clone https://github.com/siemens/kas\\n   cd kas\\n   pip3 install .\\n   ```\\n\\n1. Call kas tool to build everything:\\n\\n   ```bash\\n   kas build kas/machines/meta-erlang-graviton2-livebook.yaml\\n   ```\\n\\n   :::note\\n\\n   The final image has been created in the deploy folder:\\n   _tmp/deploy/images/generic-arm64_.\\n\\n   :::\\n\\n1. Run the script _create-ami.sh_ to convert and upload a image made with Yocto\\n   into AWS AMI. Use your s3 bucket and specific how much extra space you want:\\n\\n   ```bash\\n   ../scripts/create-ami.sh <add your s3 bucket here> 8\\n   ```\\n\\n:::info\\n\\nThe script _create_ami.sh_ may need a fix in order to find the correct place for\\nthe _qemu-img_ tool. Would be nice to have some sort of Yocto bbclass to\\nautomatically convert and push the AMI image to AWS. But it is not the case yet.\\n\\n:::\\n\\n## Launching EC2 instances\\n\\nAfter uploading the image, it\'s time to lunch an EC2 instance like the\\nfollowing:\\n\\n:::tip\\n\\nRemember to use a _Free Trial available_ instance type. When I wrote this post,\\nthe eligible tier was the t4g.small.\\n\\n:::\\n\\n![alt Launching a new EC2 instance](ec2_instance.jpg \'Launching a new EC2 instance\')\\n\\nAnd, finally here is it running:\\n\\n![alt Running a new EC2 instance](ec2_running.jpg \'Running a new EC2 instance\')\\n\\nAccessing the instance via ssh and login with the user _axon_ should work as\\nexpected. After all it is a normal Linux distro.\\n\\n## Results\\n\\nThe following two screenshots show the livebook instance up and running on\\nGraviton EC2 instance. It is pretty cool.\\n\\nJust showing the `top` command to check all the running process:\\n\\n![alt Livebook instance Graviton](livebook_instance.jpg \'Livebook instance on Graviton\')\\n\\nAnd here is the livebook system dashboard to inspect some usage statistics, and\\nsystem information:\\n\\n![alt Livebook dashboard on Graviton](livebook_dashboard.jpg \'Livebook dashboard on Graviton\')\\n\\nAs you can see, it is running on ARM64, with JIT enable.\\n\\n## Conclusion\\n\\nNow we are converging to create the basic building blocks for creating custom\\nLinux distribution based on Yocto Project that runs on Cloud.\\n\\nThat could be the perfect case for projects that need to take control on every\\ndetail of the software stack. From linx kernel configuration, building flags,\\nsoftware configuration flags, anything. It\'s really flexible.\\n\\nAnd for projects that relies on Erlang and Elixir, it is also amazing bringing\\nit to Cloud ecosystem.\\n\\nThe first blog part\\n[meta-erlang on cloud I: EWAOL based](/blog/2023/01/29/index) has introduced\\nwhat is possible to build. This blog post is more related to explore the\\nintroduced idea into something feasible and aligned with meta-erlang purposes."},{"id":"/2023/01/29/index","metadata":{"permalink":"/blog/2023/01/29/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-01-29/index.md","source":"@site/blog/2023-01-29/index.md","title":"meta-erlang on cloud I: EWAOL based","description":"\x3c!---","date":"2023-01-29T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"cloud","permalink":"/blog/tags/cloud"}],"readingTime":4.085,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"meta-erlang on cloud I: EWAOL based","authors":["joaohf"],"tags":["meta-erlang","cloud"]},"unlisted":false,"prevItem":{"title":"meta-erlang on cloud II: building your own application","permalink":"/blog/2023/02/04/index"},"nextItem":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","permalink":"/blog/2023/01/22/index"}},"content":"\x3c!---\\n\\n- Describe what is the idea: create meta-erlang YP based images with Erlang/OTP and Elixir\\n- Be able to generate images and push them to AWS\\n- Instantiate https://aws.amazon.com/ec2/graviton/ instances\\n- Run Erlang/OTP and Elixir based services like couchdb, riak, livebook\\n- Points some future directions and what would be possible to create\\n\\n--\x3e\\n\\n## Intro\\n\\nThe [Yocto Project](https://www.yoctoproject.org/) has been made to create\\nspecific embedded Linux distributions. And still does a great job on this field\\nmaking it possible to run softwares in a range of target architectures.\\n\\n\x3c!-- truncate --\x3e\\n\\nBut, the term _embedded Linux distribution_ should be expanded a bit more; it\'s\\nnot only about creating tiny filesystem within cross-compiled software, scripts\\nand configurations targeting platforms with small footprint, CPU and memory\\nconstraints.\\n\\nWe could do more, actually there are people using the not so newly but still new\\nARM processors that runs on cloud environment. For sure the most famous one is\\nthe\\n[Graviton EC2 instances, on AWS cloud](https://aws.amazon.com/ec2/graviton/).\\n\\nLooking into these Graviton processors and Yocto Project, what would it be\\npossible ? Maybe running Yocto images on Graviton instances could be feasible\\nenough to run some workload. And what about adding Erlang/OTP and Elixir to that\\nmix ? Or running some advanced database or broker made with Erlang ?\\n\\nThat is exactly what we will try to experiment. In this first post about running\\nmeta-erlang on cloud, we are going to look how it would be possible.\\n\\nActually there are folks whose made possible to run Yocto images on Graviton\\ninstances. Technically is pretty simple and all bits and bytes have been\\ndescribed in the blog post\\n[Building an Automotive Embedded Linux Image for Edge and Cloud Using Arm-based Graviton Instances, Yocto Project, and SOAFEE](https://aws.amazon.com/blogs/industries/building-an-automotive-embedded-linux-image-for-edge-using-arm-graviton-yocto-project-soafee/).\\nThe companion repository also worth the reading\\n[The meta-aws-ewaol repository](https://github.com/aws4embeddedlinux/meta-aws-ewaol).\\n\\nThe idea that [1] brings is part of another idea related to Software-Defined\\nVehicles through Cloud [2] which is very excited. These references also cites a\\nframework to build Edge Workloads [3] and in fact the EWAOL (Edge Workload\\nAbstraction and Orchestration Layer) was used as a base to produce the\\n[meta-aws-ewaol](https://github.com/aws4embeddedlinux/meta-aws-ewaol) layer.\\n\\n## Putting everything together, first experiment\\n\\nSo, based on all what has been described so far and as a first experience, I\'ve\\ntested meta-aws-ewaol setup and added meta-erlang into that. The aim was to run\\n`erl` and `iex` console on Graviton EC2 instances.\\n\\nI had to make a few fixes on meta-aws-ewaol and pushed the results here:\\n[meta-aws-ewaol with meta-erlang](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang).\\nThe rest of this session is a small guide that I made in order to run our first\\nexperiment.\\n\\nWith a ready Yocto environment, following the\\n[Building EWAOL](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#building-ewaol)\\nsession is enough to get the system built. It\'s just Yocto, nothing more.\\n\\n:::tip\\n\\n- You can create a free AWS account. There are Graviton instances included in\\n  the AWS free tier. It\'s more than sufficient.\\n- Bear in mind that you don\'t need to be an AWS master but you will end up\\n  spending some time learning how to create AWS services.\\n\\n:::\\n\\nThe next step is to create and setup all the AWS infrastructure needed in order\\nto push the Yocto image as AWS AMI and start the Graviton Instance. Lucky, there\\nis a Cloud Formation template which performs the initial setup. The session\\n[Pre-requisites](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#pre-requisites)\\nhelps to clarify it.\\n\\nThen, having the Yocto image and the basic AWS account in place. It\'s time to\\nuse\\n[a special script](https://github.com/joaohf/meta-aws-ewaol/blob/main-add-meta-erlang/scripts/create-ami.sh)\\nto convert Yocto image to an AMI image. Most of the job is done by awscli\\ncommands. There is nothing related to Yocto here. The session\\n[Creating AMI from image file](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#creating-ami-from-image-file)\\ntells what is necessary to do.\\n\\nFinally, the last part. After pushing the AMI image to the S3 bucket. The fun\\npart is to instantiate a Graviton instance (please refer to the session\\n[Launch the EC2 Image as usual using your newly created AMI](https://github.com/joaohf/meta-aws-ewaol/tree/main-add-meta-erlang#launch-the-ec2-image-as-usual-using-your-newly-created-ami))\\nan run the EWAOL based image and test how Erlang and Elixir looks like.\\n\\nI\'ve added two screenshots below just to have a taste of the final results:\\n\\n![alt Erlang console](meta-erlang-gravitron-erl.jpg \'Erlang console\')\\n\\n![alt Elixir console](meta-erlang-gravitron-iex.jpg \'Elixir console\')\\n\\n## Conclusion\\n\\nThis first experiment has finished and I can conclude two main bullets:\\n\\n- It is possible to build a Yocto image and run it on Graviton instances\\n- meta-aws-ewaol is a great start point. And the EWAOL framework looks solid for\\n  what it has been planned for.\\n\\nHowever, what I am looking for is to run a tiny image with just the necessary to\\ninstantiate an ARM cloud instance running Erlang/Elixir. That is what the next\\nblog post will do:\\n[meta-erlang on cloud II, build your own application](/blog/2023/02/04/index)\\n\\n## References\\n\\n- [1]:\\n  [Building an Automotive Embedded Linux Image for Edge and Cloud Using Arm-based Graviton Instances, Yocto Project, and SOAFEE](https://aws.amazon.com/blogs/industries/building-an-automotive-embedded-linux-image-for-edge-using-arm-graviton-yocto-project-soafee/)\\n- [2]:\\n  [Accelerating Software-Defined Vehicles through Cloud-To-Vehicle Edge Environmental Parity](https://armkeil.blob.core.windows.net/developer/Files/pdf/white-paper/arm-aws-edge-environmental-parity-wp.pdf)\\n- [3]:\\n  [Edge Workload Abstraction and Orchestration Layer (EWAOL) Documentation](https://ewaol.docs.arm.com/en/kirkstone-dev/index.html)"},{"id":"/2023/01/22/index","metadata":{"permalink":"/blog/2023/01/22/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2023-01-22/index.md","source":"@site/blog/2023-01-22/index.md","title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","description":"We\'ve added support for the following new Erlang/OTP releases:","date":"2023-01-22T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.685,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"meta-erlang on cloud I: EWAOL based","permalink":"/blog/2023/01/29/index"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"We\'ve added support for the following new Erlang/OTP releases:\\n\\n| meta-erlang branch | Erlang/OTP version         |\\n| ------------------ | -------------------------- |\\n| dunfell            | 24.3.4.8                   |\\n| kirkstone          | 24.3.4.8, 25.1.2.1, 25.2.1 |\\n| langdale           | 24.3.4.8, 25.1.2.1, 25.2.1 |\\n\\nFixed bugs:\\n\\n- [QA Issue buildpaths (reproducible builds) when building with langdale](https://github.com/meta-erlang/meta-erlang/issues/205),\\n  a specific patch has been integrated in order to avoid building flags into the\\n  final beam.smp binary.\\n\\nTo be decided:\\n\\n- Yocto Langdale release has enabled reproducible build checks. Erlang/OTP from\\n  25 and later implements special flags to fix reproducible issues. But\\n  Erlang/OTP 24 does not have these special flags as a consequence langdale\\n  Erlang/OTP 24 builds warns about: _packages contains reference to TMPDIR\\n  [buildpaths]_. There are two paths that we could get. One is to drop\\n  Erlang/OTP 24 support OR disable QA buildpaths checking."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2022-12-30-welcome/index.md","source":"@site/blog/2022-12-30-welcome/index.md","title":"Welcome","description":"This new website is based on Docusaurus documentation","date":"2022-12-30T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"news","permalink":"/blog/tags/news"}],"readingTime":0.33,"hasTruncateMarker":false,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["joaohf"],"tags":["meta-erlang","news"]},"unlisted":false,"prevItem":{"title":"New Erlang releases 24.3.4.8, 25.1.2.1, 25.2.1","permalink":"/blog/2023/01/22/index"}},"content":"This new website is based on [Docusaurus](https://docusaurus.io) documentation\\nframework. The previous site was using [docsify](https://docsify.js.org/#/),\\nwhich is also great. But Docusaurus address others concerns when writing\\ndocumentation for open source project.\\n\\nSo, the site has a new frontend page and a blog session where we want to add\\nlatest meta-erlang release highlights. The documentation session is pretty much\\nthe same plus some improvements on\\n[Introduction](https://meta-erlang.github.io/docs/) chapter."}]}}')}}]);