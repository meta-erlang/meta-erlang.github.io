"use strict";(self.webpackChunkmeta_erlang_github_io=self.webpackChunkmeta_erlang_github_io||[]).push([[9686],{574:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>d});var t=o(3706),i=o(4848),r=o(8453);const s={title:"fwup for A/B image upgrades on QEMU machines with fwup, part II",authors:["joaohf"],tags:["meta-erlang","fwup"]},a=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Objectives and Tools",id:"objectives-and-tools",level:2},{value:"Use case: A/B upgrades with QEMU u-boot machines",id:"use-case-ab-upgrades-with-qemu-u-boot-machines",level:2},{value:"YP/OE setup",id:"ypoe-setup",level:3},{value:"Configuring the build environment",id:"configuring-the-build-environment",level:3},{value:"Building an image",id:"building-an-image",level:3},{value:"Running QEMU images with runqemu script",id:"running-qemu-images-with-runqemu-script",level:3},{value:"Inspecting A partition",id:"inspecting-a-partition",level:3},{value:"Moving to B partition",id:"moving-to-b-partition",level:3},{value:"Moving from B to A partition",id:"moving-from-b-to-a-partition",level:3},{value:"Low level details",id:"low-level-details",level:2},{value:"meta-qemu-bsp layer",id:"meta-qemu-bsp-layer",level:3},{value:"Patching u-boot",id:"patching-u-boot",level:3},{value:"fwup examples layer",id:"fwup-examples-layer",level:3},{value:"Conclusions",id:"conclusions",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["This blog post describes all parts involved in order to use QEMU machines with\nYocto images for testing and developing A/B image upgrades. Moreover, this blog\npost could be considered an extension for the\n",(0,i.jsx)(n.a,{href:"/blog/2024/09/24/index",children:"fwup for A/B image upgrades, part I"})," blog post."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/fwup-home/fwup",children:"fwup"})," tool and\n",(0,i.jsx)(n.a,{href:"https://github.com/fwup-home/meta-fwup",children:"meta-fwup"})," have been introduced in the\nprevious blog post and serve as a base knowledge for this post."]}),"\n",(0,i.jsx)(n.h2,{id:"objectives-and-tools",children:"Objectives and Tools"}),"\n",(0,i.jsxs)(n.p,{children:["When I was writing and testing the post\n",(0,i.jsx)(n.a,{href:"/blog/2024/09/24/index",children:"fwup for A/B image upgrades, part I"}),", it was very\ntedious have to wait the test cycle which basically was:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Make one change"}),"\n",(0,i.jsx)(n.li,{children:"Build a new image"}),"\n",(0,i.jsx)(n.li,{children:"Burn the image into sdcard"}),"\n",(0,i.jsx)(n.li,{children:"Plug the sdcard on the target real board"}),"\n",(0,i.jsx)(n.li,{children:"Power on"}),"\n",(0,i.jsx)(n.li,{children:"Test"}),"\n",(0,i.jsx)(n.li,{children:"Power off"}),"\n",(0,i.jsx)(n.li,{children:"Get the results"}),"\n",(0,i.jsx)(n.li,{children:"Go to step #1"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"I've spent too much time waiting for feedback. Since then, I've been thinking\nhow it would be possible to speed up my test cycle."}),"\n",(0,i.jsx)(n.p,{children:"Maybe buying more target boards or reduce the final image footprint or buy a\nfaster build machine. None of them would help much the situation."}),"\n",(0,i.jsxs)(n.p,{children:["Then, I remember that one of the greatest feature from Yocto Project is the\nintegration with ",(0,i.jsx)(n.a,{href:"https://www.qemu.org/",children:"QEMU"})," emulator. Yocto brings some\nready-to-use\n",(0,i.jsx)(n.a,{href:"https://git.yoctoproject.org/poky/tree/README.qemu.md",children:"qemu machines"})," that one\ncould use in order to run an image made with Yocto Project and spending no\nmoney."]}),"\n",(0,i.jsx)(n.p,{children:"However, some pieces were missing:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The qemu default machines are not prepared for using u-boot as boot loader"}),"\n",(0,i.jsx)(n.li,{children:"u-boot does not know how to load environment variables from virtio block\ndevices"}),"\n",(0,i.jsx)(n.li,{children:"lack of qemu device-tree files (.dtb) when booting qemu machines"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It was clear that without some patches my idea of short test cycle would not be\nfeasible."}),"\n",(0,i.jsxs)(n.p,{children:["So, this blog post continues the story about\n",(0,i.jsx)(n.a,{href:"https://github.com/fwup-home/fwup",children:"fwup tool"})," in Yocto world. There are two\nimportant sections:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"One showing a practical use case with all steps necessary to test the A/B\nupgrades with fwup on qemu u-boot."}),"\n",(0,i.jsx)(n.li,{children:"A second one describing the patches and layers that I've created for booting\nqemu machines with u-boot and Yocto images."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"use-case-ab-upgrades-with-qemu-u-boot-machines",children:"Use case: A/B upgrades with QEMU u-boot machines"}),"\n",(0,i.jsx)(n.h3,{id:"ypoe-setup",children:"YP/OE setup"}),"\n",(0,i.jsx)(n.p,{children:"I'll try to simplify the YP/OE setup to just tree small steps:"}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["The YP documentation is very good. I strong recommend its reading. For this\nsection the release version used is\n",(0,i.jsx)(n.a,{href:"https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html",children:"master"}),"."]}),(0,i.jsxs)(n.p,{children:["One important point is to double check the\n",(0,i.jsx)(n.a,{href:"https://docs.yoctoproject.org/ref-manual/system-requirements.html#required-packages-for-the-build-host.",children:"Required Packages for the Build Host"})]})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Cloning all repositories for master release:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"git clone --branch master git://git.yoctoproject.org/poky\ngit clone --branch master https://github.com/openembedded/meta-openembedded.git\ngit clone --branch master https://github.com/fwup-home/meta-fwup\ngit clone --branch master https://github.com/meta-erlang/meta-qemu-bsp\ngit clone --branch master https://github.com/joaohf/meta-fwup-examples\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Source the init build environment script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd poky\nsource oe-init-build-env ../build\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add the needed layers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"bitbake-layers add-layer ../meta-openembedded/meta-oe\nbitbake-layers add-layer ../meta-fwup\nbitbake-layers add-layer ../meta-qemu-bsp\nbitbake-layers add-layer ../meta-fwup-examples\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"configuring-the-build-environment",children:"Configuring the build environment"}),"\n",(0,i.jsxs)(n.p,{children:["For this use case, the quickest way is edit and add the ",(0,i.jsx)(n.em,{children:"conf/local.conf"}),"\nconfiguration file."]}),"\n",(0,i.jsx)(n.p,{children:"We start defining the MACHINE and DISTRO:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'MACHINE = "qemuarm64-uboot"\nDISTRO = "poky"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The machine ",(0,i.jsx)(n.em,{children:"qemuarm64-uboot"})," is provided by\n",(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-qemu-bsp",children:"meta-qemu-bsp"})," layer. That\nmachine uses u-boot as bootloader."]}),"\n",(0,i.jsxs)(n.p,{children:["As YP/OE supports many types of image outputs, we want to be specific here and\npick only the ",(0,i.jsx)(n.em,{children:"fwup"})," type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'tee -a <<EOF conf/local.conf\n# enable support for making fwup images\nIMAGE_CLASSES += "image_types_fwup"\nIMAGE_FSTYPES = "fwup fwup.qcow2"\nEOF\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The fwup type is provided by the bbclass\n",(0,i.jsx)(n.a,{href:"https://github.com/fwup-home/meta-fwup/blob/master/classes/image_types_fwup.bbclass",children:"image_types_fwup.bbclass"}),".\nIt relies on wic image generator and uses their build artifacts for bootloader\nand rootfs."]})}),"\n",(0,i.jsx)(n.h3,{id:"building-an-image",children:"Building an image"}),"\n",(0,i.jsx)(n.p,{children:"Now that the configuration is over. Let's start a build:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"bitbake core-image-full-cmdline\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["For this example, and demonstration purposes, we'll use the image called\n",(0,i.jsx)(n.a,{href:"https://git.yoctoproject.org/poky/tree/meta/recipes-core/images/core-image-full-cmdline.bb",children:"core-image-full-cmdline"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:"Once the build has finished, let's inspect the build outputs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ cd tmp/deploy/images/qemuarm64-uboot\n\n$ ls -lh core-image-full-cmdline*.fw\n-rw-r--r-- 2 joaohf joaohf 71M dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fw\nlrwxrwxrwx 2 joaohf joaohf  64 dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs.fw -> core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fw\n\n$ ls -lh core-image-full-cmdline*fwup*\n-rw-r--r-- 2 joaohf joaohf 1,1G dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup\n-rw-r--r-- 2 joaohf joaohf 199M dez 27 17:36 core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup.qcow2\nlrwxrwxrwx 2 joaohf joaohf   66 dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs.fwup -> core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup\nlrwxrwxrwx 2 joaohf joaohf   72 dez 27 16:20 core-image-full-cmdline-qemuarm64-uboot.rootfs.fwup.qcow2 -> core-image-full-cmdline-qemuarm64-uboot.rootfs-20241227191846.fwup.qcow2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The folder ",(0,i.jsx)(n.em,{children:"tmp/deploy/images/qemuarm64-uboot"})," has many files generated from the\nbuild tasks. We are interested on some files only:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The first one with file extension .fw, is the firmware image made by fwup.\nWe'll use this file for A/B upgrades."}),"\n",(0,i.jsxs)(n.li,{children:["And the second file is the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Qcow",children:"qcow2"})," Yocto\nimage suitable for using it with QEMU when running the command ",(0,i.jsx)(n.code,{children:"runqemu"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"running-qemu-images-with-runqemu-script",children:"Running QEMU images with runqemu script"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://git.yoctoproject.org/poky/tree/scripts/runqemu",children:"runqemu script"})," is\nthe official way for running QEMU with the image previously created. The scripts\naccepts many QEMU parameters."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["For more details about using QEMU with Yocto, check out the official\ndocumentation:\n",(0,i.jsx)(n.a,{href:"https://docs.yoctoproject.org/dev-manual/qemu.html",children:"Using the Quick EMUlator (QEMU)"})]})}),"\n",(0,i.jsx)(n.p,{children:"For this tutorial the follow command will be used:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"runqemu core-image-full-cmdline nographic serialstdio wic.qcow2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It starts QEMU without graphic support and with serial console attached to\nstdio. The ",(0,i.jsx)(n.em,{children:"wic.qcow2"})," says to runqemu that we want to boot using the\n",(0,i.jsx)(n.em,{children:"core-image-full-cmdline-qemuarm64-uboot.rootfs.fwup.qcow2"})," image."]}),"\n",(0,i.jsx)(n.p,{children:"After running the runqemu command, we got:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ runqemu core-image-full-cmdline nographic serialstdio slirp wic.qcow2\nrunqemu - INFO - Running bitbake -e  core-image-full-cmdline...\nrunqemu - INFO - Continuing with the following parameters:\nMACHINE: [qemuarm64-uboot]\nFSTYPE: [wic.qcow2]\nROOTFS: [/data-work/yocto/work/fwup/build/tmp/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs.wic.qcow2]\nCONFFILE: [/data-work/yocto/work/fwup/build/tmp/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs.qemuboot.conf]\n\nrunqemu - INFO - Setting up tap interface under sudo\nrunqemu - INFO - Network configuration: ip=192.168.7.2::192.168.7.1:255.255.255.0::eth0:off:8.8.8.8 net.ifnames=0\nrunqemu - INFO - Running /data-work/yocto/work/fwup/build/tmp/work/x86_64-linux/qemu-helper-native/1.0/recipe-sysroot-native/usr/bin/qemu-system-aarch64 -device virtio-net-pci,netdev=net0,mac=52:54:00:1\n2:34:02 -netdev tap,id=net0,ifname=tap0,script=no,downscript=no -object rng-random,filename=/dev/urandom,id=rng0 -device virtio-rng-pci,rng=rng0 -drive id=disk0,file=/data-work/yocto/work/fwup/build/tmp\n/deploy/images/qemuarm64-uboot/core-image-full-cmdline-qemuarm64-uboot.rootfs.wic.qcow2,if=none,format=qcow2 -device virtio-blk-device,drive=disk0 -device qemu-xhci -device usb-tablet -device usb-kbd  -\nmachine virt -cpu cortex-a57 -smp 4 -m 256 -serial mon:stdio -serial null -nographic -device virtio-gpu-pci -bios /data-work/yocto/work/fwup/build/tmp/deploy/images/qemuarm64-uboot/u-boot.bin\n\nrunqemu - INFO - Host uptime: 26648.54\n\n\n\nU-Boot 2024.10-dirty (Oct 07 2024 - 14:54:35 +0000)\n\nDRAM:  256 MiB\nCore:  52 devices, 14 uclasses, devicetree: board\nFlash: 64 MiB\nLoading Environment from VIRTIO_BLK... OK\nIn:    serial,usbkbd\nOut:   serial,vidconsole\nErr:   serial,vidconsole\nBus xhci_pci: Register 8001040 NbrPorts 8\nStarting the controller\nUSB XHCI 1.00\nscanning bus xhci_pci for devices... 3 USB Device(s) found\nNet:   eth0: virtio-net#32\n\nHit any key to stop autoboot:  0\nSaving Environment to VIRTIO_BLK... OK\nboard_name=[qemu-arm] ...\n21881344 bytes read in 8 ms (2.5 GiB/s)\nloading qemu.dtb\n1048576 bytes read in 0 ms\ndebug: [console=ttyAMA0 root=/dev/vda2] ...\ndebug: [bootz 0x40200000 - 0x49000000] ...\n## Flattened Device Tree blob at 49000000\n   Booting using the fdt blob at 0x49000000\nWorking FDT set to 49000000\n   Loading Device Tree to 000000004d491000, end 000000004d593fff ... OK\nWorking FDT set to 4d491000\n\nStarting kernel ...\n\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd070]\n[    0.000000] Linux version 6.12.3-yocto-standard (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 14.2.0, GNU ld (GNU Binutils) 2.43.1.20241111) #1 SMP PREEMPT Thu Dec 12 17:25:00 UTC 2024\n\nPoky (Yocto Project Reference Distro) 5.1 qemuarm64-uboot ttyAMA0\n\nqemuarm64-uboot login:\n"})}),"\n",(0,i.jsx)(n.p,{children:"That log above shows some very interesting points:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["QEMU was configure with ",(0,i.jsx)(n.em,{children:"-bios"})," parameter:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-bios /build/tmp/deploy/images/qemuarm64-uboot/u-boot.bin\n"})}),"\n","Which means u-boot will be used as bootloader for linux kernel."]}),"\n",(0,i.jsxs)(n.li,{children:["we can check that u-boot support for virtio block device is working as\nexpected:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"...\nLoading Environment from VIRTIO_BLK... OK\n...\nSaving Environment to VIRTIO_BLK... OK\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["When logged on qemu instance, it's necessary to run the command:\n",(0,i.jsx)(n.code,{children:"ifconfig eth0 192.168.7.2 netmask 255.255.255.0"})," to setup a IP address to eth0\ninterface."]})}),"\n",(0,i.jsx)(n.h3,{id:"inspecting-a-partition",children:"Inspecting A partition"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"partition layout:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@qemuarm64-uboot:~# sfdisk -l /dev/vda\nDisk /dev/vda: 1.02 GiB, 1096941568 bytes, 2142464 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: dos\nDisk identifier: 0x00000000\n\nDevice     Boot   Start     End Sectors   Size Id Type\n/dev/vda1  *       8192   93035   84844  41.4M  c W95 FAT32 (LBA)\n/dev/vda2         93036 1117585 1024550 500.3M 83 Linux\n/dev/vda3       1117586 2142135 1024550 500.3M 83 Linux\n/dev/vda4       2142136 3190711 1048576   512M 83 Linux\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"uname"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@qemuarm64-uboot:~# uname -a\nLinux qemuarm64-uboot 6.12.3-yocto-standard #1 SMP PREEMPT Thu Dec 12 17:25:00 UTC 2024 aarch64 GNU/Linux\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"uboot variables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\nnerves_fw_active=a\nnerves_fw_validated=1\nnerves_fw_booted=1\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"moving-to-b-partition",children:"Moving to B partition"}),"\n",(0,i.jsx)(n.p,{children:"Alright, partition A looks fine. Now, we want to run an upgrade using the fwup\nfirmware image."}),"\n",(0,i.jsx)(n.p,{children:"From the build machine:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ cd build/tmp/deploy/images/qemuarm64-uboot\n$ cat core-image-full-cmdline-qemuarm64-uboot.rootfs.fw | ssh root@192.168.7.2 'fwup -v -a -U -d /dev/vda -t upgrade.b'\nfwup: require-uboot-variable(uboot-env, nerves_fw_active) -> met\nfwup: require-uboot-variable(uboot-env, nerves_fw_validated) -> met\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_platform) -> met\nfwup: require-uboot-variable(uboot-env, a.nerves_fw_architecture) -> met\nfwup: Upgrading partition B\n100% [====================================] 73.74 MB in / 570.79 MB out\nSuccess!\nElapsed time: 9.758 s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The important argument is the ",(0,i.jsx)(n.code,{children:"-t upgrade.b"})," telling to fwup which partition\nwill be upgraded."]}),"\n",(0,i.jsx)(n.p,{children:"Let's also inspect u-boot environment variables. Because the task upgrade.b\nshould changed something there:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"root@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\nnerves_fw_active=b\nnerves_fw_validated=0\nnerves_fw_booted=0\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Indeed, the ",(0,i.jsx)(n.em,{children:"nerves_fw_active"})," variable has changed."]}),"\n",(0,i.jsxs)(n.p,{children:["Inside qemu, reboot the system using the ",(0,i.jsx)(n.code,{children:"reboot"})," command in order to change the\npartition."]}),"\n",(0,i.jsx)(n.p,{children:"Once the system come back, let's inspect the u-boot environment variables to\ncheck if those variables are pointing to the B partition now."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"root@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\nnerves_fw_active=b\nnerves_fw_validated=1\nnerves_fw_booted=1\n"})}),"\n",(0,i.jsx)(n.p,{children:"And they are ok. Not only still pointing to B partition as well validated and\nbooted."}),"\n",(0,i.jsx)(n.p,{children:"The lsblk output also proves that vda3 is mounted as root partition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"root@qemuarm64-uboot:~# lsblk\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nvda    253:0    0     1G  0 disk\n|-vda1 253:1    0  41.4M  0 part /boot\n|-vda2 253:2    0 500.5M  0 part\n|-vda3 253:3    0 500.5M  0 part /\n`-vda4 253:4    0   238K  0 part\n"})}),"\n",(0,i.jsx)(n.h3,{id:"moving-from-b-to-a-partition",children:"Moving from B to A partition"}),"\n",(0,i.jsx)(n.p,{children:"Ok, looks like partition B is up and running too."}),"\n",(0,i.jsx)(n.p,{children:"Now, it's time to run a second upgrade and moving back to A partition."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ cd build/tmp/deploy/images/qemuarm64-uboot\n$ cat core-image-full-cmdline-qemuarm64-uboot.rootfs.fw | ssh root@192.168.7.2 'fwup -v -a -U -d /dev/vda -t upgrade.a'\nfwup: require-uboot-variable(uboot-env, nerves_fw_active) -> met\nfwup: require-uboot-variable(uboot-env, nerves_fw_validated) -> met\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_platform) -> met\nfwup: require-uboot-variable(uboot-env, b.nerves_fw_architecture) -> met\nfwup: Upgrading partition A\n100% [====================================] 73.74 MB in / 570.79 MB out\nSuccess!\nElapsed time: 8.515 s\n"})}),"\n",(0,i.jsx)(n.p,{children:"Again, checking u-boot variables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"root@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\nnerves_fw_active=a\nnerves_fw_validated=0\nnerves_fw_booted=0\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And rebooting the system using ",(0,i.jsx)(n.code,{children:"reboot"})," command in order to change the partition\nto A. After the reboot, let's check what is the state of u-boot variables:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"root@qemuarm64-uboot:~# fw_printenv nerves_fw_active nerves_fw_validated nerves_fw_booted\nnerves_fw_active=a\nnerves_fw_validated=1\nnerves_fw_booted=1\n"})}),"\n",(0,i.jsx)(n.p,{children:"The lsblk output should point vda2 mounted as root partition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"root@qemuarm64-uboot:~# lsblk\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nvda    253:0    0     1G  0 disk\n|-vda1 253:1    0  41.4M  0 part /boot\n|-vda2 253:2    0 500.5M  0 part /\n|-vda3 253:3    0 500.5M  0 part\n`-vda4 253:4    0   238K  0 part\n"})}),"\n",(0,i.jsx)(n.p,{children:"It worked as expected. The system is using a rootfs from partition A."}),"\n",(0,i.jsx)(n.h2,{id:"low-level-details",children:"Low level details"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"A bit more Yocto vocabulary."})}),"\n",(0,i.jsx)(n.h3,{id:"meta-qemu-bsp-layer",children:"meta-qemu-bsp layer"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-qemu-bsp",children:"meta-qemu-bsp layer"})," is a BSP\n(board support package) type layer. The target is to bring some machines\nextended from default Yocto QEMU machines."]}),"\n",(0,i.jsx)(n.p,{children:"By default, Yocto brings the following QEMU machines:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ARM (qemuarm + qemuarm64)"}),"\n",(0,i.jsx)(n.li,{children:"x86 (qemux86 + qemux86-64)"}),"\n",(0,i.jsx)(n.li,{children:"PowerPC (qemuppc only)"}),"\n",(0,i.jsx)(n.li,{children:"MIPS (qemumips + qemumips64)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These machines don't work with u-boot for instance. In order to enable u-boot,\nsome configuration are necessary. Thus, the following machine proveded by\nmeta-qemu-bsp layer were created:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-qemu-bsp/blob/master/conf/machine/qemuarm-uboot.conf",children:"qemuarm-uboot"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-qemu-bsp/blob/master/conf/machine/qemuarm64-uboot.conf",children:"qemuarm64-uboot"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["A WIC file is also provided:\n",(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-qemu-bsp/blob/master/wic/qemuarm-uboot-directdisk.wks",children:"qemuarm-uboot-directdisk.wks"}),"\nand it is used when creating wic images."]}),"\n",(0,i.jsx)(n.p,{children:"The meta-qemu-bsp layer was design to use with any other Yocto layer. It's not\nspecific for fwup use cases."}),"\n",(0,i.jsx)(n.h3,{id:"patching-u-boot",children:"Patching u-boot"}),"\n",(0,i.jsxs)(n.p,{children:["The u-boot bootloader was not prepared to load environment variables from virtio\nblock device. So, a patch called\n",(0,i.jsx)(n.a,{href:"https://github.com/meta-erlang/meta-qemu-bsp/blob/master/recipes-bsp/u-boot/files/0001-Load-and-save-environment-from-virtio-block-device.patch",children:"Load and save environment from virtio block device"}),"\nwas developed."]}),"\n",(0,i.jsxs)(n.p,{children:["It allows u-boot to load environment variables from virtio block device reading\ndata from a specific offset and size. As u-boot already provides support for\n",(0,i.jsx)(n.a,{href:"https://docs.u-boot.org/en/stable/develop/driver-model/virtio.html",children:"virtio"}),",\nthe bits needed to load variables from virtio was easy to implement."]}),"\n",(0,i.jsx)(n.p,{children:"So far, this patch was not submited to u-boot upstream project."}),"\n",(0,i.jsx)(n.h3,{id:"fwup-examples-layer",children:"fwup examples layer"}),"\n",(0,i.jsxs)(n.p,{children:["A new layer called\n",(0,i.jsx)(n.a,{href:"https://github.com/joaohf/meta-fwup-examples",children:"meta-fwup-examples"})," was developed\nto hold fwup examples for Yocto images."]}),"\n",(0,i.jsx)(n.p,{children:"The process of enabling Yocto images to use fwup is not so smooth and it depends\non details like:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"partition layout"}),"\n",(0,i.jsx)(n.li,{children:"boot load paramenters"}),"\n",(0,i.jsx)(n.li,{children:"boot load environment scripts"}),"\n",(0,i.jsx)(n.li,{children:"fwup tasks"}),"\n",(0,i.jsx)(n.li,{children:"custom logics"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Then, each of these details is a combination that works for a specific target\nboard. Having a dedicated layer with working fwup examples helps for\ndemonstration and new implementations."}),"\n",(0,i.jsx)(n.p,{children:"The meta-fwup-examples is also a repository of .fwup description files:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/joaohf/meta-fwup-examples/blob/master/fwup/qemuarm-uboot.fwup",children:"qemuarm-uboot.fwup"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/joaohf/meta-fwup-examples/blob/master/fwup/qemuarm64-uboot.fwup",children:"qemuarm64-uboot.fwup"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["It's important to mention that I'm reusing and adapting .fwup files from\n",(0,i.jsx)(n.a,{href:"https://github.com/orgs/nerves-project",children:"Nerves Project"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The .fwup used for raspberrypi in\n",(0,i.jsx)(n.a,{href:"/blog/2024/09/24/index",children:"fwup for A/B image upgrades, part I"})," will be moved to\nthe layer meta-fwup-examples soon."]}),"\n",(0,i.jsx)(n.h2,{id:"conclusions",children:"Conclusions"}),"\n",(0,i.jsx)(n.p,{children:"Yes, QEMU machines with u-boot enabled is feasible. And it will help me to\nreduce time when testing/developing."}),"\n",(0,i.jsxs)(n.p,{children:["While the ",(0,i.jsx)(n.a,{href:"/blog/2024/09/24/index",children:"fwup for A/B image upgrades, part I"})," blog\npost discussed fwup and meta-fwup details, this post explored how QEMU could be\nused instead a real hardware for testing."]}),"\n",(0,i.jsxs)(n.p,{children:["Now it's possible to move fowarding and try some\n",(0,i.jsx)(n.a,{href:"https://github.com/nerves-hub/nerves_hub_link",children:"nerves_hub_link"})," high level\nintegration for A/B upgrades using ",(0,i.jsx)(n.a,{href:"https://www.nerves-hub.org/",children:"nerves-hub"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"But that will be a topic for further blog posts."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(6540);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},3706:e=>{e.exports=JSON.parse('{"permalink":"/blog/2024/12/20/index","editUrl":"https://github.com/meta-erlang/meta-erlang.github.io/tree/master/blog/2024-12-20/index.md","source":"@site/blog/2024-12-20/index.md","title":"fwup for A/B image upgrades on QEMU machines with fwup, part II","description":"This blog post describes all parts involved in order to use QEMU machines with","date":"2024-12-20T00:00:00.000Z","tags":[{"inline":true,"label":"meta-erlang","permalink":"/blog/tags/meta-erlang"},{"inline":true,"label":"fwup","permalink":"/blog/tags/fwup"}],"readingTime":11.15,"hasTruncateMarker":true,"authors":[{"name":"Jo\xe3o Henrique Ferreira de Freitas","title":"Maintainer of meta-erlang","url":"https://github.com/joaohf","imageURL":"https://github.com/joaohf.png","key":"joaohf","page":null}],"frontMatter":{"title":"fwup for A/B image upgrades on QEMU machines with fwup, part II","authors":["joaohf"],"tags":["meta-erlang","fwup"]},"unlisted":false,"prevItem":{"title":"fwup for A/B image upgrades on QEMU machines with NervesCloud, part III","permalink":"/blog/2025/01/26/index"},"nextItem":{"title":"Introducing Gleam to meta-erlang layer","permalink":"/blog/2024/11/03/index"}}')}}]);